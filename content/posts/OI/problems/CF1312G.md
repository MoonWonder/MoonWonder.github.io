---
tags:
  - Notebooks/OI/OJ/Luogu
title: CF1312G-Autocompletion
date: '2020-07-26 19:37:48.145941'
modified: '2020-07-26 19:37:48.145968'

---

# CF1312G-Autocompletion

## 题目:

### 题目描述:

You are given a set of strings $ S $ . Each string consists of lowercase Latin letters.

For each string in this set, you want to calculate the minimum number of seconds required to type this string. To type a string, you have to start with an empty string and transform it into the string you want to type using the following actions:

- if the current string is $ t $ , choose some lowercase Latin letter $ c $ and append it to the back of $ t $ , so the current string becomes $ t + c $ . This action takes $ 1 $ second;
- use autocompletion. When you try to autocomplete the current string $ t $ , a list of all strings $ s \in S $ such that $ t $ is a prefix of $ s $ is shown to you. This list includes $ t $ itself, if $ t $ is a string from $ S $ , and the strings are ordered lexicographically. You can transform $ t $ into the $ i $ -th string from this list in $ i $ seconds. Note that you may choose any string from this list you want, it is not necessarily the string you are trying to type.

What is the minimum number of seconds that you have to spend to type each string from $ S $ ?

Note that the strings from $ S $ are given in an unusual way.

### 输入格式:

The first line contains one integer $ n $ ( $ 1 \le n \le 10^6 $ ).

Then $ n $ lines follow, the $ i $ -th line contains one integer $ p_i $ ( $ 0 \le p_i < i $ ) and one lowercase Latin character $ c_i $ . These lines form some set of strings such that $ S $ is its subset as follows: there are $ n + 1 $ strings, numbered from $ 0 $ to $ n $ ; the $ 0 $ -th string is an empty string, and the $ i $ -th string ( $ i \ge 1 $ ) is the result of appending the character $ c_i $ to the string $ p_i $ . It is guaranteed that all these strings are distinct.

The next line contains one integer $ k $ ( $ 1 \le k \le n $ ) — the number of strings in $ S $ .

The last line contains $ k $ integers $ a_1 $ , $ a_2 $ , ..., $ a_k $ ( $ 1 \le a_i \le n $ , all $ a_i $ are pairwise distinct) denoting the indices of the strings generated by above-mentioned process that form the set $ S $ — formally, if we denote the $ i $ -th generated string as $ s_i $ , then $ S = {s_{a_1}, s_{a_2}, \dots, s_{a_k}} $ .

### 输出格式:

Print $ k $ integers, the $ i $ -th of them should be equal to the minimum number of seconds required to type the string $ s_{a_i} $ .

### 样例:

#### 样例输入 1:

```
10
0 i
1 q
2 g
0 k
1 e
5 r
4 m
5 h
3 p
3 e
5
8 9 1 10 6
```

#### 样例输出 1:

```
2 4 1 3 3
```

#### 样例输入 2:

```
8
0 a
1 b
2 a
2 b
4 a
4 b
5 c
6 d
5
2 3 4 7 8
```

#### 样例输出 2:

```
1 2 2 4 4
```

## 思路:

发现给出的串格式其实就是一个 $trie$。

那把 $trie$ 建出来之后，发现操作就可以变成这样：往自己子节点走，代价 $1$，以及往自己子树内第 $x$ 个关键点走，代价 $x$。

然后可以类似于 $dfs$ 序，只不过如果当前这个位置不在 $S$ 里就不加 $cnt$，然后子树内的关键点 $id$ 就连续了。

连续了之后我们令 $dp_i =$ 到节点 $i$ 的最少步数，很明显可以从 $fa$ 转移，并且还可以从任意一个祖先转移，即 $dp_i = \min(dp_{anc} + id_i - id_{anc} + hav\_{anc})$，这里的 $hav$ 是指祖先是不是关键点。
然后这个移项后就变成了 $dp_i = \min(dp_{anc} - id_{anc} + hav\_{anc})+id_i$​，又因为只有祖先能转移，所以就树上前缀 $min$ 优化一下即可。

## 实现:

```cpp
#include "ybwhead/ios.h"
using namespace std;
int n;
const int maxn = 1e6 + 10;
int a[maxn];
int b[maxn];
vector<int> v[maxn];
int tot, tr[maxn][26];
int num[maxn];
int f[maxn];
int ne(int u, int v, int w)
{
    if (!tr[u][w])
        tr[u][w] = num[v] = ++tot, f[tot] = u;
    else
        num[v] = tr[u][w];
    // cout << u << " " << v << " " << w << " " << endl;
    return 0;
}
int dp[maxn];
int up[maxn];
int dfn;
void dfs(int u)
{
    dfn += a[u];
    dp[u] = min(dp[u], dp[f[u]] + 1);
    if (a[u])
    {
        dp[u] = min(dp[u], up[f[u]] + dfn);
    }
    up[u] = min(up[f[u]], dp[u] - (dfn - a[u]));
    for (int i = 0; i < 26; i++)
        if (tr[u][i])
            dfs(tr[u][i]);
}
int main()
{
    yin >> n;
    num[1] = 1;
    tot = 1;
    for (int i = 2; i <= n + 1; i++)
    {
        int x;
        char c;
        yin >> x >> c;
        ++x;
        ne(num[x], i, c - 'a');
    }
    yin >> n;
    memset(dp, 0x3f, sizeof(dp));
    memset(up, 0x3f, sizeof(up));
    dp[1] = 0;
    for (int i = 1; i <= n; i++)
    {
        yin >> b[i];
        ++b[i];
        ++a[num[b[i]]];
    }
    dfs(1);
    for (int i = 1; i <= n; i++)
        yout << dp[num[b[i]]] << " ";
    return 0;
}
```
