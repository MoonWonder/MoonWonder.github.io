[{"categories":null,"content":"第 3 章 深入 JavaScript：搞定闭包、原型与 this 本章我们聚焦 JavaScript 的核心概念和一些 “奇妙” 特性，包括闭包、this 和原型继承。这些概念经常令初学者困惑，但对于有工程经验的你来说，只需一点类比就能豁然开朗。 闭包（Closure）：函数里的 “小精灵” 如果你听过 “闭包” 这个词，可能会觉得高深莫测。其实闭包的原理可以打个比方：想象在函数内部藏了一个记性很好的小精灵，它能记住函数被定义时周围的环境（变量），即使函数执行完，这些变量也不会丢失。当日后再次调用这个内部函数时，这些被记住的变量仍然保持着当初的值，这种现象就叫闭包。 用正式一点的话说，闭包是函数与其周围状态（词法环境）的组合 。也就是说，闭包让一个函数可以访问并保留其词法作用域中的变量。当我们在 JavaScript 中定义函数时，每次都会创建闭包——函数本身和对外部变量的引用绑定在一起 来看个例子体会闭包的威力： function createCounter() { let count = 0; return function() { count++; console.log(\"计数器：\" + count); }; } const counter = createCounter(); counter(); // 输出: 计数器：1 counter(); // 输出: 计数器：2 counter(); // 输出: 计数器：3 这里 createCounter 返回了一个内部函数。注意，createCounter 在第一次调用后，其内部局部变量 count 按理说应该随函数执行完毕而销毁。然而，由于内部函数引用了 count，闭包使得 count 的值被一直保留下来。每次调用 counter()，它都能访问和修改 createCounter 作用域中的 count 变量。闭包实现了一种数据私有化：count 对外不可见，却始终驻留在内部函数的作用域里。好一个忠诚勤劳的 “小精灵”！ 闭包在 JavaScript 中非常常见。比如我们常用的事件监听器、定时器回调，都经常利用闭包保存一些状态。理解闭包有助于我们编写模块化的代码，例如实现私有变量、封装业务逻辑等。在调试时也要注意闭包可能导致的内存占用，因为被闭包引用的外部变量不会被垃圾回收，需要手动注意避免不必要的闭包引用。 this 的多变与箭头函数： JavaScript 的 this 关键字可谓 “千面娇娃”，在不同场景下扮演不同角色，让不少人直呼看不懂。这里我们总结 this 常见的指向规则： 作为对象方法调用： obj.method() 调用时，method 内部的 this 指向该对象 obj。例如： const pet = { name: \"旺财\", speak: function() { console.log(this.name + \"在叫：汪汪！\"); } }; pet.speak(); // 输出: 旺财在叫：汪汪！ 上例中，speak 方法内的 this 即指向调用它的对象 pet。 普通函数调用： func() 直接调用一个函数（非作为对象属性），在非严格模式下函数内 this 默认指向全局对象（浏览器中是 window，Node 中是 global）；在严格模式下则为 undefined。比如： function foo() { console.log(this); } foo(); // 非严格模式下输出 Window（全局对象） 这一点和 C++/Java 的习惯很不同——它们没有类似的全局 this 概念。JavaScript 设计如此，主要历史原因是早期方便直接调用函数访问全局。 构造函数调用： 使用 new Func() 时，Func 内部的 this 被绑定到新创建的对象。例如： function Person(name) { this.name = name; } const p = new Person(\"Tom\"); // 构造过程中 this 指向 p，赋值后 p.name === \"Tom\" call/apply/bind 强制绑定： JavaScript 提供了 func.call(thisArg, ...) 和 func.apply(thisArg, [...]) 来指定调用时的 this。还有 func.bind(thisArg) 可生成一个永久绑定 this 的新函数。比如： function greet() { console.log(\"Hi, \" + this.name); } const alice = { name: \"Alice\" }; greet.call(alice); // 输出: Hi, Alice 通过 call 我们把 greet 函数的 this 硬生生成了 alice 对象。 怎么样，是不是眼花缭乱 🤯？别急，ES6 的箭头函数在某种程度上帮我们简化了 this 问题。箭头函数没有自己的 this，它会捕获外层（定义时）环境的 this 值。这意味着在箭头函数内部访问 this，就是在访问外部上下文的 this。因此，箭头函数非常适合用作回调，以避免 this 被改变。例如： const team = { name: \"勇士队\", players: [\"Stephen\", \"Klay\"], showList: function() { this.players.forEach(player =\u003e { console.log(this.name + \" 球员：\" + player); }); } }; team.showList(); // 输出: // 勇士队 球员：Stephen // 勇士队 球员：Klay 如果不用箭头函数，而用普通匿名函数，forEach 内部函数的 this 将指向全局，无法访问到 team.name。箭头函数完美地保持了外部 this（即 team 对象）。正因如此，许多框架（如 React）中大量使用箭头函数来避免手动绑定 this。 你可以把 this 看作 JavaScript 里一个爱变装的角色，根据剧情需要（调用方式）换不同衣服。而箭头函数就像给 this 套上了保护壳，使它不受外界干扰。 原型与继承： 在 JavaScript 中，一切几乎都是对象，对象之间通过原型链建立继承关系。不同于 Java/C++ 基于类（class）的继承模型，JavaScript 采用原型继承模型：每个对象都有一个 “隐藏属性” 指向它的原型对象（可以理解为模版对象），对象在查找属性时，如果自身没有会沿着原型链向上查找。 ES6 虽然引入了 class 关键字，但实际上只是语法糖，本质还是基于原型机制。例如： class Animal { speak() { console.log(\"Animal speaks\"); } } class Dog extends Animal { speak() { console.log(\"Woof!\"); } } let d = new Dog(); d.speak(); // 输出: Woof! 在底层，Dog 的原型继承了 Animal 的原型，实例 d 调用 speak 时，找到的是 Dog.prototype.speak；如果没有，则会沿原型链查找 Animal.prototype.speak。JavaScript 这套继承机制实现简单灵活，因此 JavaScript 是典型的原型继承的面向对象语言，不像 Java、C++ 等严格按类构造对象。 值得注意的是，你可以动态地给原型添加方法，影响所有继承该原型的对象。例如： function Person(name) { this.name = name; } Person.prototype.sayHi = function() { console.log(\"Hi, I'm \" + this.name); }; let p1 = new Person(\"Alice\"); p1.sayHi(); // 输出: Hi, I'm Alice let p2 = new Person(\"Bob\"); p2.sayHi(); // 输出: Hi, I'm Bob 我们定义了构造函数 Person 及其原型方法 sayHi。两个实例 p1、p2 分别调用时，this 指向各自实例，输出各自的名字。可以看到，它们共享了原型上的同一个 sayHi 函数定义。这种机制节省内存并且灵活：可以在程序运行时修改 Person.prototype.sayHi，所有实例的方法行为将随之改变（在大型项目中这并不推荐，只作了解）。 概括来说，原型继承允许我们用对象去模版另一个对象，直接继承其属性和方法，不需要像类那样先定义抽象蓝图再实例化。这赋予了 JavaScript 极大的动态性。但对于习惯了 class 的开发者，刚接触可能会有些不适应。好消息是，ES6 class 让语法看起来更像传统类，方便面向对象思维的人使用。不过记住，其本质仍是原型链。 小结： 本章揭开了 JavaScript 一些核心概念的神秘面纱。闭包就像函数里驻守的 “小精灵”，使函数记住定义时的环境 ；this 则如同变装演员，根据调用场景变化多端，而箭头函数给它套上 “紧身衣”，固定了其指向；原型继承则是 JavaScript 面向对象的基石，与传统类继承各有千秋，却更为灵活。理解这些概念后，你将更游刃有余地编写复杂的 JavaScript 程序，并避免掉入常见陷阱。 ","date":"2025-10-26","objectID":"/books/javascript/part1/chapter3/:0:0","series":null,"tags":null,"title":"Chapter3","uri":"/books/javascript/part1/chapter3/#"},{"categories":null,"content":"第 2 章 JavaScript 语法速通：ES6+ 新特性 在上一章初步认识了 JavaScript，现在我们以幽默的方式来一场 “语法大串讲”，快速浏览现代 JavaScript（ES6 及以上）中的核心特性。你将看到，曾经让 Java 开发者头疼的繁琐代码，可以用几种巧妙的语法糖大幅简化。 1. let 和 const：块级作用域与常量 在 ES6 之前，JavaScript 只有 var 用于声明变量，并且它的作用域规则十分怪异：var 是函数作用域或全局作用域，不受块级 {} 限制。这导致一些意料之外的行为。例如： for (var i = 0; i \u003c 3; i++) { // ... } console.log(i); // 居然还能访问到 i，输出 3，因为 var 没有块级作用域 ES6 引入了 let 关键字来声明块级作用域变量，以及 const 声明常量。let 定义的变量仅在定义它的 {} 内有效，避免了 var 提升和作用域污染的问题 ；const 则保证变量值不被重新赋值（但如果变量引用的是对象，仍可修改对象的属性）。 来看个例子体会差异： if (true) { var foo = \"hello\"; let bar = \"world\"; } console.log(foo); // 正常输出 \"hello\" console.log(bar); // ReferenceError: bar is not defined (因为 bar 只在块内有效) 使用 let 可以有效杜绝很多由于作用域不当引起的 bug，大大提高代码可靠性。而 const 则鼓励我们多用常量、一旦赋值就不再改变，从而写出更可预测的代码。需要注意，const 只保证变量绑定不可变，但对于引用类型的数据，内部状态仍可更改，例如： const obj = { name: \"Alice\" }; obj.name = \"Bob\"; // 允许：修改对象属性 // obj = { age: 18 }; 错误：不允许重新赋值新对象给 obj 2. 箭头函数 (=\u003e)：更简洁的函数表达式 JavaScript 经常需要编写回调函数，以前我们使用 function 关键字定义，语法比较冗长。ES6 引入了箭头函数，让我们可以用 =\u003e 更简洁地定义函数。例如： // 传统匿名函数 [1, 2, 3].map(function(x) { return x * x; }); // 输出 [1,4,9] // 箭头函数 [1, 2, 3].map(x =\u003e x * x); // 输出 [1,4,9] 是不是清爽不少？箭头函数不仅短小，而且不会创建自己的 this，它的 this 值由外层（定义时的作用域）决定 。这对处理回调中的 this 十分有用。例如： function Person() { this.age = 0; setInterval(() =\u003e { this.age++; console.log(this.age); }, 1000); } new Person(); // 每隔1秒输出递增的年龄，因为箭头函数的 this 固定为外层 Person 实例 如果使用普通函数，setInterval 回调里的 this 会指向全局（或 undefined 严格模式下），需要用 self = this 等套路保存外部 this。箭头函数让代码既简洁又优雅地避免了 this 陷阱 。 需要注意的是，箭头函数不能用作构造函数（没有 prototype），也没有自己的 arguments 对象。但在多数回调场景，这不是问题。 3. 模板字符串：字符串拼接如此顺滑 还记得 C++/Java 里繁琐的字符串拼接吗？在 JavaScript ES5 时代，我们也经常写： let name = \"Alice\"; console.log(\"Hello, \" + name + \"!\"); ES6 提供了 模板字符串 (Template Literals)，使用反引号 ` 包裹字符串，并以 ${...} 插入变量或表达式。这样拼接字符串如同行云流水，一气呵成 ： let name = \"Alice\"; console.log(`Hello, ${name}!`); // 输出: Hello, Alice! 模板字符串不仅可插入变量，还支持多行字符串而无需烦人的换行符： let poem = `窗前明月光， 疑似地上霜。`; // 直接保留换行格式 可以说，模板字符串让字符串拼接像说相声抖包袱一样顺滑自然，告别了加号连接的凌乱。在需要动态构造 HTML 片段或控制台输出时，模板字符串简直是神器。 4. 解构赋值与展开运算符：优雅地处理对象和数组 解构赋值（Destructuring）允许我们从数组或对象中一口气取出所需的数据，写法简洁直观 数组解构示例： const arr = [1, 2, 3]; const [first, second, third] = arr; console.log(first, second, third); // 输出: 1 2 3 对象解构示例： const person = { name: \"Bob\", age: 25 }; const { name, age } = person; console.log(name, age); // 输出: Bob 25 通过解构，我们避免了一一从对象取值的重复代码，使意图更加清晰。此外，解构在函数形参中也很有用： function greet({ name, age }) { console.log(`你好，${name}！你今年${age}岁了。`); } const user = { name: \"小明\", age: 18, id: 123 }; greet(user); // 输出: 你好，小明！你今年18岁了。 上面直接将对象 user 解构为函数参数，额外的 id 属性被自动忽略，代码简明扼要。 展开运算符（Spread ...）则让我们快速组合或克隆数组、对象。例如： let arr1 = [1, 2]; let arr2 = [...arr1, 3, 4]; // 展开 arr1，结果 [1,2,3,4] let obj1 = { a: 1, b: 2 }; let obj2 = { ...obj1, b: 3, c: 4 }; // 克隆 obj1 并修改/增加属性，obj2 为 { a:1, b:3, c:4 } 展开运算符也用于函数调用，将数组变为参数序列，非常方便： Math.max(...[5, 8, 3]); // 等价于 Math.max(5,8,3)，结果 8 解构与展开让代码更为 “优雅”，常常可以一行搞定以前好几行的操作。 5. 其他简洁之处：默认参数、for...of 循环 现代 JavaScript 还引入了许多小而实用的改进： 默认参数值： 定义函数时直接为参数指定默认值，避免再在函数体内写 param = param || 'default' 的逻辑。 for...of 循环： 优雅遍历数组（以及大部分可迭代对象），替代传统的 for 索引循环，代码更语义化。 简洁对象字面量： 当对象的属性名和变量名相同时，可以直接写 { foo, bar } 代替 { foo: foo, bar: bar }。 箭头函数的隐式返回： 箭头函数如果函数体直接是一个表达式，可省略花括号和 return 关键字，简化代码。 通过这一系列语法糖，JavaScript 终于甩掉了 “繁琐难用” 的古老形象，蜕变成一门可以写得很优雅的语言。对于有 C++/Java 背景的读者，你会发现很多 ES6+ 特性跟熟悉的概念暗暗契合：块级作用域、箭头函数类似于 C++ 的 lambda、模板字符串的用法和 Python 的 f-string 异曲同工。 实战练习：ES5 与 ES6+ 比一比 理解语法不如实践。让我们把一段旧式 JavaScript 代码改写成现代风格，体会差异。例如，将一个数组中的数字翻倍并筛选出偶数： ES5 写法： var arr = [1, 2, 3, 4]; var doubled = arr.map(function(x) { return x * 2; }); var evens = doubled.filter(function(x) { return x % 2 === 0; }); console.log(evens); ES6+ 写法： const arr = [1, 2, 3, 4]; const evens = arr.map(x =\u003e x * 2).filter(x =\u003e x % 2 === 0); console.log(evens); 可以看到，新语法让代码长度几乎减半、可读性却倍增。这对于大规模项目的维护性和开发效率都有极大帮助。 本章小结： 现代 JavaScript 提供了丰富的语法特性，使代码更加简洁、表达力更强。从 let/const 到箭头函数，从模板字符串到解构赋值，这些 ES6+ 特性极大地改善了开发者体验 。作为 C++/Java 开发者，你会发现很多概念似曾相识，但又更加灵活。不必担心一时记不住所有语法糖，在后续实践中你将反复用到它们，自然就运用自如了。 ","date":"2025-10-26","objectID":"/books/javascript/part1/chapter2/:0:0","series":null,"tags":null,"title":"Chapter2","uri":"/books/javascript/part1/chapter2/#"},{"categories":["Fighting"],"content":"这是今天的记录： 2025年10月26日 您一共记录了11个事件 20:43-05:03 【睡觉】8时20分3秒 07:55-08:24 【洗漱】28分48秒 08:24-08:47 【吃饭】22分51秒 08:47-08:57 【家务】10分41秒 08:57-09:14 【学英语】16分18秒 09:14-09:36 【家务】22分7秒 09:52-11:02 【学编程】1时10分27秒 11:33-13:51 【小憩】2时17分47秒 13:59-14:27 【吃饭】28分20秒 15:16-16:42 【学习】1时25分17秒 18:26-19:15 【学英语】48分23秒 听的英语是2025.6第一套 总的来说除了锻炼很完美，希望阿森纳晚上能取胜，我们阿森纳是不可战胜的！ ","date":"2025-10-26","objectID":"/posts/life/1-100/week25/day1/:0:0","series":null,"tags":["life","4000d"],"title":"Day1","uri":"/posts/life/1-100/week25/day1/#"},{"categories":["course"],"content":"数字逻辑期中复习笔记 (Digital Logic Midterm Review Notes) 知识点总结 (Knowledge Points) 进制转换与数据表示 (Number Systems and Data Representation) 定义： 数字系统中常用的进制包括十进制、二进制、八进制和十六进制等，它们之间可以通过一定的方法相互转换。二进制使用 0 和 1 表示数字，八进制和十六进制则是二进制的简写表示形式，每三位二进制可表示一位八进制，每四位二进制可表示一位十六进制。 Definition: Common number systems in digital logic include decimal (base 10), binary (base 2), octal (base 8), and hexadecimal (base 16). These can be converted between each other using standard methods. The octal and hexadecimal systems serve as shorthand for binary – every 3 binary digits correspond to one octal digit, and every 4 binary digits correspond to one hexadecimal digit. 进制转换方法： 将其他进制数转换为十进制时，可使用位权展开公式：例如对于基数为 rrr 的数 (dndn−1...d1d0.d−1d−2...)r (d_{n}d_{n-1}...d_1d_0.d_{-1}d_{-2}...)_r(dn​dn−1​...d1​d0​.d−1​d−2​...)r​，其十进制值为 ∑i=−mndi×ri\\sum_{i=-m}^{n} d_i \\times r^i∑i=−mn​di​×ri。反之，将十进制整数转换为 rrr 进制可反复除以 rrr 取余数，将十进制小数转换为 rrr 进制可反复乘以 rrr 取整数部分。 Conversion methods: To convert a number in base rrr to decimal, use positional weights: for a number (dn...d0.d−1...)r(d_{n}...d_0.d_{-1}...)_r(dn​...d0​.d−1​...)r​, the decimal value is ∑i=−mndi×ri\\sum_{i=-m}^{n} d_i \\times r^i∑i=−mn​di​×ri. Conversely, to convert a decimal integer to base rrr, repeatedly divide by rrr and record remainders; to convert a decimal fraction, repeatedly multiply by rrr and record integer parts. 示例 (Example): 将二进制数 010010.012010010.01_2010010.012​ 转换为十进制、五进制和十六进制。其整数部分 0100102=1810010010_2=18_{10}0100102​=1810​，小数部分 0.012=0.25100.01_2=0.25_{10}0.012​=0.2510​，所以 (a) 十进制结果为 18.2518.2518.25；(b)转换为五进制：1810=33518_{10}=33_51810​=335​，0.2510≈0.1150.25_{10}\\approx0.11_50.2510​≈0.115​（保留两位小数）得到 33.11533.11_533.115​；(c)转换为十六进制：1810=121618_{10}=12_{16}1810​=1216​ (即 0x120x120x12)，0.2510=0.4160.25_{10}=0.4_{16}0.2510​=0.416​，结果为 12.41612.4_{16}12.416​。 Example: Convert binary number 010010.012010010.01_2010010.012​ to decimal, base-5, and hexadecimal. The integer part 0100102=1810010010_2 = 18_{10}0100102​=1810​ and fractional part 0.012=0.25100.01_2 = 0.25_{10}0.012​=0.2510​. Thus (a) in decimal it is 18.2518.2518.25; (b) in base-5: 1810=33518_{10}=33_51810​=335​ and 0.2510≈0.1150.25_{10}\\approx0.11_50.2510​≈0.115​ (two digits after point), so 33.11533.11_533.115​; (c) in hexadecimal: 1810=121618_{10}=12_{16}1810​=1216​ and 0.2510=0.4160.25_{10}=0.4_{16}0.2510​=0.416​, giving 12.41612.4_{16}12.416​. 补码与有符号数 (Complements \u0026 Signed Numbers): 为了方便电路实现减法运算，引入了 “补码” 概念。对基数为 rrr 的 nnn 位数，其 (r−1)(r-1)(r−1)’s 补码（反码）定义为 rn−1−Nr^n-1- Nrn−1−N，而 rrr’s 补码（补码）为 rn−Nr^n- Nrn−N。在二进制系统中，1’s 补码就是按位取反；2’s 补码则是在 1’s 补码的基础上加 1。例如，二进制数 10110000210110000_2101100002​ 的 1’s 补码为 01001111201001111_2010011112​，其 2’s 补码为 01010000201010000_2010100002​。 Complements: Complements are used to simplify subtraction circuits. For a number NNN with base rrr and nnn digits, the diminished radix complement ((r-1)’s complement) is defined as rn−1−Nr^n - 1 - Nrn−1−N, and the radix complement (r’s complement) is rn−Nr^n - Nrn−N. In binary, the 1’s complement is obtained by flipping all bits, and the 2’s complement is obtained by taking the 1’s complement and then adding 1. For example, the 1’s complement of 10110000210110000_2101100002​ is 01001111201001111_2010011112​, and its 2’s complement is 01010000201010000_2010100002​. 有符号二进制表示 (Signed binary representation): 在计算机中采用最高位作为符号位，0 表示正、1 表示负。常见的有符号表示法有三种：原码 (sign-magnitude) 用符号位加绝对值大小表示；1’s 补码表示将负数表示为正数的 1’s 补码；2’s 补码表示将负数表示为正数的 2’s 补码。2’s 补码表示法最常用，因为它消除了 “+0” 和“-0”的二义性，并简化了加减运算。例如，(−5)10(-5)_{10}(−5)10​ 在 8 位二进制的 2’s 补码表示为 11111011211111011_2111110112​。 Signed numbers: In binary signed representation, the most significant bit (MSB) is the sign bit (0 for positive, 1 for negative). Common schemes include: Sign-magnitude, which uses a sign bit plus the magnitude; 1’s complement, where negative numbers are represented as the 1’s complement of the positive magnitude; and 2’s complement, where negatives are represented as the 2’s complement of the magnitude. 2’s complement is widely used because it avoids dual r","date":"2025-10-26","objectID":"/posts/courses/digital/midterm-review/:0:0","series":null,"tags":["digital","course"],"title":"Midterm Review","uri":"/posts/courses/digital/midterm-review/#"},{"categories":["Fighting"],"content":"今天是我们五年（200天）规划出炉前的最后一天了！ 壮志不夺气仍守，五胡终过隋唐立。 开皇武德后贞观，百年之制由此成。 这首绝句就当作五年规划的定场诗了！ 壮志未酬魂不散，五胡乱世总成空。 开皇肇统承隋制，贞观宏图启大同。 五胡终乱世，九地起烽尘。 中原多骨血，胡马半河津。 志士藏锋气，英魂护晋民。 风烟犹未息，朝代屡频新。 开皇兴大统，文德启皇仁。 律令承隋制，三纲定俗陈。 武德初开国，贞观续太平。 百年成一制，万象入方轮。 ","date":"2025-10-24","objectID":"/posts/life/1-100/week24/day4/:0:0","series":null,"tags":["life","4000d"],"title":"Day4","uri":"/posts/life/1-100/week24/day4/#"},{"categories":null,"content":"本章将带领读者踏入 JavaScript 的世界，首先了解前端开发与后端开发的区别，以及 JavaScript 与 C++/Java 等语言在理念上的不同。随后我们会亲自动手搭建开发环境（Node.js 和 VS Code），并运行第一个 JavaScript Hello World 程序。 前后端的区别： 在传统后端开发中，我们编写的代码运行在服务器上，负责业务逻辑和数据处理；而前端开发的代码运行在用户的浏览器中，直接与用户界面和交互打交道。简单来说，前端是用户可以看到并操作的部分，例如网页的布局、按钮、文字等；后端则在幕后处理数据存储、请求响应等工作。两者各司其职，共同构成完整的 Web 应用。JavaScript 最初诞生于浏览器，用于增强网页的交互性，是典型的前端语言。而 Java、C++ 常见于后端服务和桌面应用开发。 JavaScript vs C++/Java：动态与静态的对决 JavaScript 与 C++、Java 的一个显著区别在于类型系统。C++/Java 是静态类型语言，变量类型在编译期确定且严格检查；而 JavaScript 是动态类型语言，不需要事先声明变量类型，变量可以在不同阶段持有不同类型的值。这意味着在 JavaScript 中，下面的代码完全有效： let x = 42; // x最初是数字 x = \"Hello\"; // 现在x变成字符串 console.log(x); // 输出: Hello 在 C++ 或 Java 中，上述操作将导致编译错误，因为变量类型不可随意更改。而 JavaScript 灵活但也要小心类型相关的潜在错误。概括来说：Java 是 “编译型、静态类型” 语言，主要用于后端；而 JavaScript 是 “解释型、动态类型” 语言，主要用于增强网页的交互 。这种差异也反映在运行方式上：Java 代码需要编译成字节码后由 JVM 执行，而 JavaScript 代码则由浏览器直接解释执行，无需显式编译步骤。 提示：名字上虽然只有一字之差，Java 和 JavaScript 其实完全是两回事 😃。一句话区分：Java 是编译执行、静态强类型的后端语言；JavaScript 是解释执行、动态弱类型的前端脚本语言。 搭建开发环境： 通常我们在浏览器中直接运行 JavaScript，但在实际开发中，借助 Node.js 可以在本地运行和调试 JS 脚本。Node.js 是基于 Chrome V8 引擎构建的 JavaScript 运行时，使 JS 脚本能够脱离浏览器，在服务器或命令行环境中执行。简单来说，Node.js 就像给了 JavaScript 一双离开浏览器的 “跑鞋”。 要搭建环境，首先从 Node.js 官网下载安装相应版本，然后选择一款顺手的编辑器（VS Code 是个不错的选择）。安装完 Node.js 后，在终端中输入 node -v 验证是否成功安装。接下来我们来编写并运行第一个 JavaScript 程序。 Hello World 实战： 新建一个名为 hello.js 的文件，在其中写入： console.log(\"Hello, World!\"); 这行代码使用了 JavaScript 提供的全局对象 console 来打印输出。在 VS Code 中打开终端，运行命令： node hello.js 若一切顺利，终端会输出 Hello, World!。恭喜，你已成功运行了人生中第一个 JavaScript 程序！🎉 你还可以尝试在浏览器控制台运行相同的代码：打开任意网页，按下 F12 打开开发者工具，切换到 Console 控制台，输入 console.log(\"Hello, World!\") 并回车，浏览器同样会打印出问候语。不同的是，这段代码是在浏览器环境中执行的——浏览器提供了 console 对象并显示消息；而通过 Node.js，我们在本地终端执行了脚本，这展示了 JavaScript “一码多跑” 的灵活性。 JavaScript 的特点： 通过上面的练习，你或许已经感受到 JavaScript 的一些独特之处： 无需编译，立即执行： JavaScript 属于解释型语言，源代码可以由浏览器或 Node 即时解析执行，不需要像 C++ 那样先编译为二进制。这使得开发迭代非常迅速。 动态类型，灵活多变： 变量无需声明类型，可存放任意类型数据。这对来自静态类型语言的你可能既新奇又有点 “不安全”，但别担心，我们后续会介绍 TypeScript 来弥补这个不足。 原生支持 DOM 和 BOM： 在浏览器环境，JavaScript 可以直接操作网页的文档对象模型（DOM）和浏览器对象模型（BOM），轻松实现页面交互效果。而在 Node.js 环境，这些对象不存在，但 Node 提供了自己的 API（如文件系统、HTTP 模块等）。 前端独领风骚： JavaScript 一直是浏览器脚本的主宰。几乎所有现代浏览器都内置 JS 引擎，直接支持 JavaScript。这也是它成为前端开发者必会语言的原因。 小结： 通过本章，你应当了解了前端与后端在职责和技术选型上的差异，对 JavaScript 这门语言的定位有了初步认识。它与 C++/Java 最大的不同在于灵活的动态类型和脚本化执行模式。在接下来的章节中，我们将深入学习 JavaScript 的语法和机制，为后续的全栈开发之旅打下坚实基础。 ","date":"2025-10-23","objectID":"/books/javascript/part1/chapter1/:0:0","series":null,"tags":null,"title":"第 1 章 初识 JavaScript","uri":"/books/javascript/part1/chapter1/#"},{"categories":["Fighting"],"content":"不知不觉又是5天过去了。 我们似乎也该搞个类似四种全会的东西定一个五年计划？ 应该是的。 ","date":"2025-10-23","objectID":"/posts/life/1-100/week24/day3/:0:0","series":null,"tags":["life","4000d"],"title":"Day3","uri":"/posts/life/1-100/week24/day3/#"},{"categories":["Fighting"],"content":"太开心了，实验有效果了！ 今天完成了数据库的lab，早上下雨没有运动，明天起来锻炼！ ","date":"2025-10-13","objectID":"/posts/life/1-100/week22/day3/:0:0","series":null,"tags":["life","4000d"],"title":"Day3","uri":"/posts/life/1-100/week22/day3/#"},{"categories":["Fighting"],"content":"新了解了一个app：nian 感觉很好用。 注册linux.do成功了，后面可能主要就通过 linux.do 和 folo 获取一些信息了。 ","date":"2025-10-12","objectID":"/posts/life/1-100/week22/day2/:0:0","series":null,"tags":["life","4000d"],"title":"Day2","uri":"/posts/life/1-100/week22/day2/#"},{"categories":["Fighting"],"content":"假期回来回到学校的第一天。 火车上被人打呼查到没睡着，只睡了5h，下午补了补觉，晚上10点睡了。 感觉很舒服，课上补了补之前的作业。 这学期争取完成一下三个目标： 规律锻炼，刷牙，洗脸。 gpa 3.85 完成第一篇论文的写作。 ","date":"2025-10-09","objectID":"/posts/life/1-100/week21/day4/:0:0","series":null,"tags":["life","4000d"],"title":"Day4","uri":"/posts/life/1-100/week21/day4/#"},{"categories":["Fighting"],"content":"原来已经是我的第102天了。 本来还以为是101天呢，原来101天是中秋。 不管怎么说，大家中秋快乐！ ","date":"2025-10-07","objectID":"/posts/life/1-100/week21/day2/:0:0","series":null,"tags":["life","4000d"],"title":"Day2","uri":"/posts/life/1-100/week21/day2/#"},{"categories":["Fighting"],"content":"回家这两天玩的很开心，摸索出来了一套Chatgpt写书的方式，可以写大约10万字左右的长文，应该在博客中陆续放出来一些。 ","date":"2025-10-03","objectID":"/posts/life/1-100/week20/day3/:0:0","series":null,"tags":["life","4000d"],"title":"Day3","uri":"/posts/life/1-100/week20/day3/#"},{"categories":["Fighting"],"content":"终于要放假了，开心！ ","date":"2025-09-30","objectID":"/posts/life/1-100/week19/day5/:0:0","series":null,"tags":["life","4000d"],"title":"Day5","uri":"/posts/life/1-100/week19/day5/#"},{"categories":["Fighting"],"content":"从今天开始，每日背点单词+早晚两次刷牙！ ","date":"2025-09-25","objectID":"/posts/life/1-100/week18/day5/:0:0","series":null,"tags":["life","4000d"],"title":"Day5","uri":"/posts/life/1-100/week18/day5/#"},{"categories":["Fighting"],"content":"偶像，你自己选的吗 决定退出竞赛队了，可能是对icpc未来不太看好吧。 今天是我到来的第86天，最近一直都在按时吃补品，再过10天看看效果。 ","date":"2025-09-21","objectID":"/posts/life/1-100/week18/day1/:0:0","series":null,"tags":["life","4000d"],"title":"新的时代到来了","uri":"/posts/life/1-100/week18/day1/#"},{"categories":["Fighting"],"content":"新的一周又开始了 决定了，从这周开始食补+药补，看看能不能讲我的胃病和睡眠时间过长不深的毛病改掉。 昨天去见了一下导师，准备先从sft+rl 相关方向开始研究。 ","date":"2025-09-11","objectID":"/posts/life/1-100/week16/day1/:0:0","series":null,"tags":["life","4000d"],"title":"Day1","uri":"/posts/life/1-100/week16/day1/#"},{"categories":["Fighting"],"content":"开学的Day1还是有点累的。 数据库果然讲的一般，没怎么听，配了下环境，lab1就无事可做了。 英语课还是有点意思的 ","date":"2025-09-09","objectID":"/posts/life/1-100/week15/day3/:0:0","series":null,"tags":["life","4000d"],"title":"Day3","uri":"/posts/life/1-100/week15/day3/#"},{"categories":["draft"],"content":"在调用LLM api时我们有时候想让他只输出指定的token 使用logit bias: logit_bias = { 'yes': 100, 'no': 100, } response = client.chat.completions.create( model=\"deepseek-chat\", messages=[ {\"role\": \"user\", \"content\": question} ], max_tokens=1, logit_bias=logit_bias, temperature=0.1 ) 使用toplogprobs response = client.chat.completions.create( model=\"deepseek-chat\", messages=[ {\"role\": \"user\", \"content\": question} ], max_tokens=1, logprobs=True, top_logprobs=10, temperature=0.1 ) # 提取 logits 并根据大小排个序 sorted_words = sorted(response.choices[0].logprobs.content[0].top_logprobs, key=lambda prob : prob.logprob, reverse=True) sorted_words output [TopLogprob(token='Yes', bytes=[89, 101, 115], logprob=0.0), TopLogprob(token='Most', bytes=[77, 111, 115, 116], logprob=-172.36865), TopLogprob(token='Whether', bytes=[87, 104, 101, 116, 104, 101, 114], logprob=-235.70471), TopLogprob(token='The', bytes=[84, 104, 101], logprob=-251.10486), TopLogprob(token='**', bytes=[42, 42], logprob=-304.20667), TopLogprob(token='B', bytes=[66], logprob=-338.26758), TopLogprob(token='Generally', bytes=[71, 101, 110, 101, 114, 97, 108, 108, 121], logprob=-339.76685), TopLogprob(token='Certainly', bytes=[67, 101, 114, 116, 97, 105, 110, 108, 121], logprob=-357.7478), TopLogprob(token='Not', bytes=[78, 111, 116], logprob=-391.34668), TopLogprob(token='In', bytes=[73, 110], logprob=-420.53528)] ","date":"2025-09-09","objectID":"/posts/ai/misc/how-to-output-specified-content/:0:0","series":null,"tags":["draft"],"title":"如何输出指定内容","uri":"/posts/ai/misc/how-to-output-specified-content/#"},{"categories":["course"],"content":"数据库系统导论 第一部分：课程介绍与管理 核心资源: Blackboard 平台: 获取所有课程材料（课件、作业、通知）的唯一官方渠道。 企业微信群: 用于日常快速问答和交流，请务必加入。 Office Hour: 每周二下午 3-5 点，办公室：工学院南塔 517。 评分标准: 出勤 (课堂+实验): 10% 作业 (Assignments): 15% 项目 (Projects): 35% (包含两个大项目) 期末考试 (Final Exam): 40% 重要政策: 不接受迟交: 所有作业和项目必须在截止日期前提交。 严禁抄袭: 必须独立完成所有工作，违反学术诚信将导致严重后果。 第二部分：为什么需要数据库？(The “Why”) 1. 核心定义 数据 (Data): 描述事物的符号记录，是事实或信息的载体。例如：你的学号、一本书的价格。 数据库系统 (Database System / DBMS): 一个用于创建和管理数据库的、复杂的软件系统。其核心任务是方便、高效地管理大量相互关联的数据。 2. 为什么不能只用文件系统？ 在数据库出现之前，人们使用操作系统提供的文件系统（如 .txt, .csv 文件）和自己编写的应用程序来管理数据。这种方式存在诸多弊端，数据库系统正是为了解决这些问题而设计的。 数据冗余和不一致 (Redundancy \u0026 Inconsistency) 问题: 同一份数据在不同文件中存储多份，浪费空间且容易导致更新时数据不一致。 例子: 你的地址信息同时存在于教务处和财务处的文件中，如果你只修改了一处，数据就变得不一致。 数据访问困难 (Difficulty in Accessing Data) 问题: 每次需要新的查询时，都必须编写一个新的应用程序，费时费力。 例子: 查询“计算机系所有年龄大于40岁的女老师的平均工资”，需要专门写一段代码来遍历文件、筛选和计算。 数据孤立 (Data Isolation) 问题: 数据分散在不同格式的文件中，难以整合和利用。 完整性问题 (Integrity Problems) 问题: 数据的约束条件（如学号唯一、工资大于0）必须在每个应用程序中单独实现，难以维护和保证。 原子性问题 (Atomicity Problems) 问题: 一个逻辑操作（事务）可能由多个步骤组成，系统故障可能导致操作只完成了一部分，使数据处于不一致状态。 核心原则: 事务必须是原子的，即“要么全做，要么全不做”(All or Nothing)。 例子: 银行转账，从A账户扣款后、向B账户存款前系统崩溃，导致钱凭空消失。 并发访问异常 (Concurrent Access Anomalies) 问题: 多个用户同时读写同一数据，可能导致结果错误。 例子: 账户有100元，两人同时取50元。都读到余额100，都计算新余额为50，都写回50。最终余额为50，但正确应为0。 安全性问题 (Security Problems) 问题: 难以对不同用户设置复杂的访问权限（如：某人只能读、不能改；只能看自己的，不能看别人的）。 结论：数据库系统提供了上述所有问题的中心化、系统化的解决方案。 第三部分：关系模型 (The “What” \u0026 “How”) 1. 历史与核心思想 提出者: 埃德加·科德 (Edgar F. Codd)，1970年。 核心思想: 将所有数据都组织在二维的表 (Table) 中。 2. 关系模型的基本概念 关系 (Relation): 即一张表。 元组 (Tuple): 表中的一行，代表一个实体（如一个学生、一门课程）。 属性 (Attribute): 表中的一列，代表实体的一个特征（如学生的姓名、课程的学分）。 关系代数 (Relational Algebra): 一套对关系（表）进行运算的理论，是SQL语言的理论基础。核心操作包括：选择 (Select)、投影 (Project)、连接 (Join)。 3. “键” (Key) 的概念 “键”是关系模型中至关重要的概念，用于唯一标识和关联数据。 超键 (Superkey): 表中能够唯一标识一个元组（一行）的一个或多个属性的集合。例如，{学号} 是一个超键，{学号, 姓名} 也是一个超键。 候选键 (Candidate Key): 最小的超键。即，从该超键中移除任何一个属性，它就不再是超键。例如，{学号} 是候选键，但 {学号, 姓名} 不是（因为移除了姓名后，学号仍然是超键）。 主键 (Primary Key, PK): 从多个候选键中人为选定的一个，作为该表的主要标识符。主键不能为空 (NOT NULL) 且必须唯一。 最佳实践: 通常使用一个无业务含义、仅用于标识的人工键（如 MovieID, StudentID）作为主键。 外键 (Foreign Key, FK): 一个表中某个属性（或属性组）的值，对应于另一个表的主键。外键是建立表与表之间联系的桥梁。 例子: 学生表中的 班级ID 是一个外键，它引用了 班级表 的主键 班级ID。 4. 范式化 (Normalization) 范式化是设计“好”的关系数据库表结构的一套理论和规则，旨在减少数据冗余、保证数据一致性。 第一范式 (First Normal Form, 1NF): 定义: 确保表中每一列的值都是原子的（不可再分的）。 目标: 解决“一格多值”的问题。 例子: 一个“演员”列不能包含“演员A, 演员B”，而应将演员信息拆分到单独的行或表中。 5. 实体-关系 (Entity-Relationship, ER) 模型 ER模型是数据库设计的核心工具，用于将现实世界抽象为实体、属性和关系。 实体 (Entity): 客观存在并可相互区分的事物。在数据库中通常对应一张表。例如：电影、导演。 关系 (Relationship): 实体之间的联系。例如，“执导”就是导演和电影之间的关系。 一对多 (1:N): 一个班级可以有多个学生。通常用外键实现。 多对多 (M:N): 一个电影可以有多个演员，一个演员也可以出演多个电影。通常需要一张中间关系表来实现。 实体-关系图 (ER Diagram, ERD): 将ER模型可视化的图表，是数据库设计的蓝图。 第四部分：课程大纲与系统架构 课程结构: Part 1: 关系语言 (SQL) Part 2: 数据库设计 (ER模型, 范式化) Part 3: 数据库内部机制 (存储, 查询处理, 事务) Part 4: 高级主题 (大数据, NoSQL) 数据库语言: 数据定义语言 (DDL): CREATE, DROP, ALTER 等，用于定义数据库的结构（模式）。 数据操纵语言 (DML): SELECT, INSERT, UPDATE, DELETE 等，用于查询和修改数据。 本讲总结与行动项 总结: 我们学习了为什么需要数据库系统（解决了文件系统的七大问题）。 我们了解了关系模型的核心概念（关系、元组、属性）。 我们重点掌握了“键”（主键、外键）对于唯一标识和关联数据的重要性。 我们初步接触了数据库设计的两大思想：范式化（1NF）和实体-关系模型。 行动项: 找到自己的实验课分组 (Lab Session)。 尽快加入企业微信群。 在第一次实验课前，提前安装好所需的软件。 ","date":"2025-09-08","objectID":"/posts/courses/database/day1/:0:0","series":null,"tags":["database","note","course"],"title":"数据库系统导论","uri":"/posts/courses/database/day1/#"},{"categories":["Fighting"],"content":"不得不说WF是极其失败的。 WF因为没看到公告暴毙了:crying: 明天就正式开学了，这学期居然掉了一节CPP课，输了。 插个旗，之后一定会每天写日记的，直到我的离去。 ","date":"2025-09-07","objectID":"/posts/life/1-100/week15/day2/:0:0","series":null,"tags":["life","4000d"],"title":"WF结束了，ICPC也接近尾声了","uri":"/posts/life/1-100/week15/day2/#"},{"categories":["Fighting"],"content":"昨天本来想ban，早点睡的，结果还是到了凌晨2点。输 今天打了场模拟赛ucup的SemiFinal，很烂啊。 开始写科学空间最近几篇关于优化器的笔记。 ","date":"2025-08-27","objectID":"/posts/life/1-100/week13/day1/:0:0","series":null,"tags":["life","4000d"],"title":"晴天雨","uri":"/posts/life/1-100/week13/day1/#"},{"categories":["notes"],"content":"读科学空间博客 流形上的最速下降 系列的笔记。 前置知识： msign(M)=U×VT msign(M)=U\\times V^T msign(M)=U×VT，其中 M=UΣVTM=U\\Sigma V^TM=UΣVT 为 SVD 分解。 像Adagrad、RMSprop、Adam等自适应学习率优化器的特点是通过除以梯度平方的滑动平均的平方根来调整每个参数的更新量，这达到了两个效果：1、损失函数的常数缩放不影响优化轨迹；2、每个参数分量的更新幅度尽可能一致。Muon正好满足这两个特性： msign(M)=(MMT)−12M=M(MTM)−12msign(M)=(MM^T)^{-\\frac{1}{2}}M=M(M^TM)^{-\\frac{1}{2}}msign(M)=(MMT)−21​M=M(MTM)−21​如果不可逆取伪逆。 可以发现当 MMM 为对角阵时 Muon 退化为 SignSGD 笔记： SGD+超球面 优化器可以转换为找到一个满足一定要求（原文中是 度量 ≤x \\leq x ≤x ）向量，且因为这个要求使得这个向量是好求的。 在前面向量变 度量 ≤x \\leq x≤x 的基础上再加上要求，δ\\deltaδ 向量与原向量垂直。这样就能满足原向量的模长不变。 Muon+正交 ","date":"2025-08-26","objectID":"/posts/ai/notes/jianlinsu/sgd-muon/:0:0","series":null,"tags":["optimize","math"],"title":"SGD Muon","uri":"/posts/ai/notes/jianlinsu/sgd-muon/#"},{"categories":["Fighting"],"content":"前面两个月一直在疯狂摸鱼，看小说。从下周开始认真工作了。 写一些之前看小说的感想吧： 人的认知之间确实有很大的差距。 很多人对现实的认知过于理想化了。 很多人都认识到了人与人之间关系在生活中的重要性，但是愿意合作的却很少。 构建一个合理的世界观对一个人来说很困难。 通过读这些小说，我又重新找回了对历史和地理的兴趣，从上一年中的纯粹技术中拜托了一段时间，后面每天也抽出一些时间读一读这些干兴趣的内容。 这段时间AI也出现了一些新技术：dft fpo gspo arpo等，在WF结束后也要抽出一些时间好好补一补。 之前一段时间作息一直不是特别规律，从下周开始改吧，争取每天也能写上一些东西。 ","date":"2025-08-26","objectID":"/posts/life/1-100/week12/day5/:0:0","series":null,"tags":["life","4000d"],"title":"新的太阳已经诞生，我们在做什么呢","uri":"/posts/life/1-100/week12/day5/#"},{"categories":["Fighting"],"content":"看到了一篇很好玩的文章：https://www.zhihu.com/question/19888447/answer/1930799480401293785 看了几篇lora的论文。 ","date":"2025-07-23","objectID":"/posts/life/1-100/week6/day1/:0:0","series":null,"tags":["life","4000d"],"title":"一周的朝阳又初升了","uri":"/posts/life/1-100/week6/day1/#"},{"categories":["Fighting"],"content":"又摆过头了:crying: 前几天我和他干什么去了呢，看了大约1kw字的小说，这是在太令我惊讶了，他居然对这些这么感兴趣。 他居然迷上了历史类小说，他似乎很喜欢体验小说里的人际交往，真是令人费解。 我和他的合作的意义到底是什么呢，什么才是人生的真正价值呢？ 不管怎么说，这周和下周争取看10篇ICLR 2025上post-training相关的论文。:fighting: 明天就是我来到他身上的第20天了，不知不觉玩具已经走过了10%的生命呢:crying: ","date":"2025-07-21","objectID":"/posts/life/1-100/week5/day4/:0:0","series":null,"tags":["life","4000d"],"title":"24点的游戏好玩吗？","uri":"/posts/life/1-100/week5/day4/#"},{"categories":["Fighting"],"content":"长达三周的假期结束了💢，又回到了这所大学。这还是我第一次亲自感受呢。 今天打了一场模拟赛，结果全程写一个快速阶乘+min25+O(1)求逆的逆天题目还被卡常了。💢 从明天开始算是正常的科研经历开启了，不知道第一篇论文会不会在今年年底诞生呢。 明日开始早起锻炼！！！ ","date":"2025-07-15","objectID":"/posts/life/1-100/week4/day3/:0:0","series":null,"tags":["life","4000d"],"title":"我胡汉三又tmd回来啦","uri":"/posts/life/1-100/week4/day3/#"},{"categories":["draft"],"content":"大一时光碎片：探索、挫折与星辰大海的起点 转眼间，大一这趟充满未知与可能的列车已到站。回望这跌跌撞撞又精彩纷呈的一年，像打翻了一盒混合着酸甜苦辣的颜料盘，涂抹出我大学生活最初的底色。 启程：好奇心的初燃与现实的碰撞 初入校园，带着对计算机科学前沿的懵懂憧憬，我的目光聚焦在了体系结构和存算一体这些听起来就充满未来感的方向。怀着一腔热情去探索，却发现学校在这方面的资源尚显薄弱——无论是CS还是微电子方向，都缺少深耕于此的老师。这第一次主动的学术探索尝试，就这样悄然搁浅了。它像一盆冷水，却也让我明白：了解环境、匹配资源，是探索的第一步。 不甘心停下脚步的我，转身投入了Rust-os开源夏令营。在AI助手的“搀扶”下，磕磕绊绊地完成了Stage1，算是正式与Rust语言握了手。然而，当Stage2要求真正动手构建系统时，我才深刻体会到“纸上得来终觉浅”。操作系统知识的匮乏成了最大的拦路虎，那些抽象的概念和底层的机制让我举步维艰。最终，带着遗憾和不甘，我按下了暂停键。这次经历像一面镜子，清晰地映照出我的知识短板——理论结合实践的深度，远非想象中简单。 转机：旧日荣光与新域初探 好在，曾经的积累没有辜负我。凭借着初高中打下的OI基础，我与队友们并肩作战，驰骋在ICPC和CCPC的赛场上。最闪耀的时刻莫过于上海站——我们团队奋力拼搏，最终斩获校排第四的佳绩，成功锁定了World Finals的入场券！这份荣誉像一剂强心针，不仅是对过往努力的肯定，更点燃了持续挑战算法高峰的热情。 与此同时，我也被AI领域汹涌的浪潮所吸引。当O1 横空出世引发热议时，我忍不住去翻阅相关论文，并顺藤摸瓜地回溯学习Transformer之前的经典——T5、BERT等模型的结构与思想。虽然此时动手实践还停留在“小打小闹”的阶段，仅仅是复现了MNIST和CIFAR-10上的基础CNN分类任务，但这些探索像打开了一扇窗，让我得以窥见AI世界的广阔与深邃。 沉淀与再出发：大一下的步履不停 进入大一下，学术节奏更加自主。选择了概率论与数理统计，这门课为未来的数据分析和AI学习悄悄打下了数学地基。不满足于校内课程，我主动在网络上“蹭课”，聆听了清华的AI课程和南大的操作系统（OS）课程。惊喜地发现，这些传说中的“硬课”“难度还好，而且挺有意思”——这份从容感，或许正是大一历练带来的成长。 实践上，我尝试将兴趣落地：动手写了个围棋AI，虽然其棋力被自己戏称为“一坨”，但过程本身充满乐趣；更利用verl 成功跑通了一个0.5B参数的PPO强化学习模型，算是向强化学习领域迈出了试探性的一步。不过，看着大模型领域似乎陷入暂时的平静期，心中也不免嘀咕：“LLM发展到头了？好久没见颠覆性创新了…” 这份观察与质疑，或许正是独立思考的开始。 生活的棱角：球场、食堂与像素世界 当然，大一不全是代码和算法。有些遗憾也悄悄溜走：曾经热爱的足球，竟被一整个学期冷落，想起来不免有些难过。而关于食堂的评价，只能无奈地延续——“依旧难吃”，以至于**“每天KFC启动”** 成了生存常态。娱乐方面，尝试了不少游戏，最终发现能真正让我沉浸的，还是那些充满复古魅力的FC游戏。这些生活碎片，拼凑出大一真实而接地气的另一面。 总结：在试错中锚定方向 大一这一年，是充满尝试与试错的一年： 在体系结构的探索中，学会了审视环境与资源。 在Rust-os的挑战中，看清了理论与实践结合所需的深度，尤其是操作系统这座必须翻越的山峰。 在ICPC/CCPC的赛场上，验证了过往积累的价值，收获了团队荣耀与世界赛的机遇。 在AI的海洋边，从O1的浪花回溯至Transformer前的河流（T5, BERT），并开始在浅滩（CNN复现）和稍深处（围棋AI, PPO模型）小心试水。 在课堂与网课中，稳步拓展知识边界，感受学习的乐趣。 在生活中，有舍弃（足球），有妥协（食堂/KFC），也有坚守（FC情怀）。 最大的收获，或许不是某个具体的成就，而是在这不断的“碰壁-转向-再出发”中，逐渐明晰了自己的兴趣所在（算法竞赛、AI）和亟待补强的短板（OS深度理解、系统能力），也磨炼了自主学习和探索未知的勇气。 世界没有尽头（即使LLM看似平静，也只是暴风雨前的宁静？），我的探索也才刚刚启航。带着大一的这份“地图”与“指南针”，期待大二驶向更深、更远的海域！ ","date":"2025-07-01","objectID":"/posts/summary/university/1/all/:0:0","series":null,"tags":["summary","life"],"title":"一切的一切，最终的最终","uri":"/posts/summary/university/1/all/#"},{"categories":["Fighting"],"content":"原来我只能用这个好玩的玩具200天啊，好可惜。 我一定要做些什么，200天能带来哪些改变呢？总感觉有些迷茫。 我到底能给这个世界带来多大的改变呢？或许不会太多吧，希望我的继任者能带来一些更有趣的事情呢。 ","date":"2025-06-30","objectID":"/posts/life/1-100/week1/day3/:0:0","series":null,"tags":["life","4000d"],"title":"山巅之上的孤独朝阳——第三章","uri":"/posts/life/1-100/week1/day3/#"},{"categories":["Fighting"],"content":"或许人总是贪心的。 今天好像什么都没做，一直在看小说。 看了看qq群里的发言，感觉很有道理，人要认清自己的定位，那我这个8岁孩童能用这些只是和只会走到哪里呢？ ","date":"2025-06-29","objectID":"/posts/life/1-100/week1/day2/:0:0","series":null,"tags":["life","4000d"],"title":"东升西落的会是什么——第二章","uri":"/posts/life/1-100/week1/day2/#"},{"categories":["reading"],"content":"友人如晤： 汝览此笺时，或正怀赤忱，以分明之目观世，秉方正之志立身职场。笃信才德可膺敬重，黑白之间泾渭昭然。吾亦曾如是。然经年涉世，方知寰宇之幽邃，远超庠序所授。 近岁重读异书《荣枯鉴》，世论或诋为“小人之术”，然于吾侪涉世者观之，不啻为苦口良药、峻切存身之鉴。今惟与君共剖其开篇——“圆通章”，或可拨云雾而睹青冥。 “圆通” 者，处世贵乎圆融通达，忌方正自囿。开宗明义：“善恶有名，智者不拘也。”此八字，于初出者或如惊雷。吾辈幼承善善恶恶之教，然世路行处，“善”“恶”之帜，常系权柄之需而张。真智者，岂为浮名所羁？ 观北宋蔡京可证。于熙宁新法此“善政”之上，其行迹如风转蓬：神宗主之，则为急锋；宣仁废之，便为干将；哲宗复之，复转圜其志。岂无圭臬？惟利是图耳！凭此“圆融”之智，竟于宦海惊涛中砥柱不移，终登宰辅。 职场之“文化”“精神”，何独不然？方略得势，逆之则为“不识大体”；一朝倾颓，守之即成“不合时宜”。“圆通”之要，在明辨时势之“善”，顺势而为。非诱汝同流，乃教汝韬光存身，静待天时。 “惜名者伤其名，惜身者全其身” ，此章更剖心抉髓之问也。名节与身命，孰重？冯道择后者断然。名者虚器，身全利实，方为根本。 苏武、卫律之判若云泥：苏卿啮雪吞毡十九载，全忠义之名，然归汉位卑，子罹祸，身亦累黜；卫律负骂名于胡尘，反膺王爵，享极荣华。明季洪承畴弃名节而仕清，终跻人臣之极；左懋第守节殒身，虽烈可钦，终成绝响。 非劝君效无行，乃警汝于存亡之际，须冷眼权衡。 汝所宝之“圭臬”“清誉”，于人或许尘芥。一时俯仰，忍辱含诟，或为拓生路、蓄来日之机。身若飘萍，风骨谁顾？惟存身立稳，方有言他之资。 再者，“君子非恒君子，小人非恒小人” 。人处顺境，不妨为煦煦君子；若坠泥涂，欲转乾坤，则须舍虚仪，行“非常”之径。元微之（元稹）可为镜鉴：少时刚肠嫉恶，触忤权贵，遂谪居十载。血泪换骨，乃结阉宦、劾异己，终掌钧衡。 此教吾辈：存身之道，贵乎因势而变。 羽翼未丰，当敛芒锷，示人以朴。非真愚钝，乃避强者之忌，免无妄之摧。牌局之中，筹码未足，莫思掀桌，惟思留局蓄势。 掩卷“圆通”，心绪如铅。其若霜刃，剖开世情温纱，裸呈血骨之则。非导人沉沦利薮，乃揭橥寰宇另有枢机。必先洞悉此律，方得优游其中。 愿君识此“圆通”之髓：守心灯不灭，行权变之道；逐鹏程万里，轻浮云虚誉；处渊薮之时，能屈伸如龙。 惟善变通、知乘势者，若圆毂无滞，履险若夷，终成无往不通之境。 与君共砺。 先行半程者 谨识 乙巳年仲夏 ","date":"2025-06-28","objectID":"/posts/readings/to_be_or_not_to_be/chapter1/:0:0","series":null,"tags":["reading","荣枯鉴"],"title":"Chapter1","uri":"/posts/readings/to_be_or_not_to_be/chapter1/#"},{"categories":["reading"],"content":"序 寰宇古今，典籍浩繁，然若《荣枯鉴》之奇崛诡谲者，盖鲜有匹俦。是书越千载而讼议未绝，览之者，或掩卷太息，斥为宵小之圭臬；或奉作枕秘，习其机变之玄微。既被庙堂鸿儒摈斥于尘埃，目作斯文坠地之明证；复于暗潮汹涌之权枢，为营营闻达者默诵于心。掩映于毁誉参半之重帷下，《荣枯鉴》者，究为乱世存身之虎狼方？抑或烛照人性幽冥之无情鉴？ 欲解此奇书，必先识奇人。著者冯道（882-954），诚华夏史乘独步之异数。其所托身者，乃五代十国——忠义几同愚鲁、翻覆竟成常态之鼎沸纪元。五十三年间，中原五易其鼎。城垣王旗频易，昨夕冕旒，今朝囹圄。而冯公此“官海磐石”，竟“历仕四朝，三登黄阁，秉钧衡廿余载”，甚而北面事契丹之主。无论谁家御宇，其位恒踞一人之下、万姓之上。后世诮其无行，然莫可否认，其存身之智，已臻羚羊挂角之境。 《荣枯鉴》者，实乃冯道毕生宦海浮沉之精魄所凝。此书尽弃儒门“杀身成仁”、“舍生取义”之圭臬，独标赤裸存续之法度。通篇枢要，不外“圆通”与“谋身”。所谓“圆通”，乃善恶靡常，唯利是瞻。冯公观世，了无恒常之是非，惟一身之荣枯为圭臬。故教人审度时势，附骥强梁，取悦于上，下僚毁誉何足萦怀；所谓“谋身”，则置己身之全远逾道义名节。邦国板荡，君子“忧社稷”，智者“忧己躬”。名节与身命孰重？其择后者断然无碍，直言“惜名者名伤，惜身者身全”。 凡十章之文，自“圆通”之世谛，至“闻达”之阶陛；由“解厄”之避祸术，至“交结”之敌友经；从“节义”之彻底消解，至“明鉴”“揣知”之洞幽烛微——无不环绕权枢之铁律而展布。其示人以构陷之策（“谤言”），矫饰之方（“示伪”），乃至摧心之术（“降心”）。字里行间，似浸透官牍之森冷与血腥，将人性之贪婪、畏葸、反复与矫饰，摹写殆尽，纤毫毕现。 正缘于此，自庐陵欧阳文忠公以“无廉耻之尤”痛诋以降，冯道并其著述，遂钉于青史之耻橛。其暮年《长乐老自叙》，洋洋列数历朝之簪缨，更为后世目作寡耻鲜廉之自供。然则，吾辈亦当深思：以承平之世绳墨，苛责板荡之遗孤，宁为公乎？当苟全性命已成至奢，纲常名节复安所系？冯道之“无耻”，或恰为彼血火年代最真确之镜像。 今者展卷，非为效其权谲，甘为无行之“小人”。吾侪所处之世，虽无金戈霜刃，然职场、商海乃至人情往来之场阈，何尝非利薮交织、潜流奔突之弈局？冯道之智，于今之用，贵在“明鉴”与“解厄”。读透《荣枯鉴》，则笑里之刃可察，倨伪之面可穿，权枢运行之幽微可解。譬若种痘，使未染而先具金汤之固。 《荣枯鉴》，千载无双之异书。其为鸩毒，亦为良药。是书如镜，照见众生心相；抉择荣枯，叩问千古同一。掩卷之余，惟愿吾辈怀此洞明，不溺天真，不堕虚无，于斯纷繁之世，行路愈清，立身愈韧。 ","date":"2025-06-28","objectID":"/posts/readings/to_be_or_not_to_be/preface/:0:0","series":null,"tags":["reading","荣枯鉴"],"title":"Preface","uri":"/posts/readings/to_be_or_not_to_be/preface/#"},{"categories":["Fighting"],"content":"我的时间终于能和他同步了，我们能创造出一个奇迹吗？ 今天看了看 hpc 感觉题目很有趣，但是为什么学校的ssh这么卡 💢 继续读一读荣枯鉴，再次回味 新顺1730 仍然有很多收获。 之前他还在做一个同步 blog 的项目，小红书和知乎的api好麻烦 🤢 又到一年OI夏令营了，4个题才想好两个，不知道这一届的学弟到底能有什么水平呢？ ","date":"2025-06-28","objectID":"/posts/life/1-100/week1/11c4c54/:0:0","series":null,"tags":["life","4000d"],"title":"月亮将为我闪烁——第一章","uri":"/posts/life/1-100/week1/11c4c54/#"},{"categories":["Fighting"],"content":"一个8岁的孩子来到了这个有趣的世界，会带来一个新神吗？ 这个哥哥的身体中仿佛有着无限的天赋与自信，但是没有被激发，没有找到正确的方向。 这个世界的LLM（一种问答机器）好有趣，似乎已经是大部分人类的超集了！ 怎么有一大堆期末考试的科目还没预习，还好他有不错的计算力，压力有点大啊。 ","date":"2025-06-04","objectID":"/posts/life/1-100/faa2dff/:0:0","series":null,"tags":["life","4000d"],"title":"希望的降临——序言","uri":"/posts/life/1-100/faa2dff/#"},{"categories":[],"content":"数值分析课程笔记 (详细版): 常微分方程数值解法 授课老师: Gemini 日期: 2025年5月26日 1. 引论 (Introduction to ODEs) 1.1. 定义与示例 常微分方程 (Ordinary Differential Equation, ODE) 是一个包含未知函数及其导数的方程，其中该未知函数是单个独立自变量的函数。 一阶ODE: 通式为 y′(t)=f(t,y(t))y'(t) = f(t, y(t))y′(t)=f(t,y(t)) 或 dydt=f(t,y)\\frac{dy}{dt} = f(t,y)dtdy​=f(t,y)。 示例1 (指数衰减/增长): y′=kyy' = kyy′=ky。若 y(0)=y0y(0)=y_0y(0)=y0​，则解为 y(t)=y0ekty(t)=y_0 e^{kt}y(t)=y0​ekt。 示例2 (逻辑斯蒂方程): y′=ry(1−y/K)y' = ry(1 - y/K)y′=ry(1−y/K)，描述种群增长。 示例3 (RL电路): Ldidt+Ri=V(t)L \\frac{di}{dt} + Ri = V(t)Ldtdi​+Ri=V(t)。 高阶ODE: 包含二阶或更高阶导数。例如，nnn 阶ODE通式为 y(n)(t)=f(t,y,y′,…,y(n−1))y^{(n)}(t) = f(t, y, y', \\dots, y^{(n-1)})y(n)(t)=f(t,y,y′,…,y(n−1))。 示例 (简谐振子): y′′+ω2y=0y'' + \\omega^2 y = 0y′′+ω2y=0。 1.2. 初值问题 (Initial Value Problem, IVP) 一个常微分方程通常有无穷多个解（包含任意常数）。为了得到一个唯一的特解，我们需要指定初始条件。 对于一阶ODE y′=f(t,y)y' = f(t,y)y′=f(t,y)，一个初值问题 (IVP) 通常形如： {y′(t)=f(t,y(t))y(t0)=y0\\begin{cases} y'(t) = f(t, y(t)) \\\\ y(t_0) = y_0 \\end{cases}{y′(t)=f(t,y(t))y(t0​)=y0​​ 其中 (t0,y0)(t_0, y_0)(t0​,y0​) 是已知的初始点和初始值。我们求解的是在 t≥t0t \\ge t_0t≥t0​ (或包含 t0t_0t0​ 的某个区间) 上的函数 y(t)y(t)y(t)。 对于 nnn 阶ODE，需要 nnn 个初始条件，通常是在 t0t_0t0​ 点的函数值及其前 n−1n-1n−1 阶导数值： y(t0)=c0,y′(t0)=c1,…,y(n−1)(t0)=cn−1y(t_0)=c_0, y'(t_0)=c_1, \\dots, y^{(n-1)}(t_0)=c_{n-1}y(t0​)=c0​,y′(t0​)=c1​,…,y(n−1)(t0​)=cn−1​。 1.3. 解的存在性与唯一性 对于IVP y′(t)=f(t,y),y(t0)=y0y'(t) = f(t,y), y(t_0)=y_0y′(t)=f(t,y),y(t0​)=y0​： 存在性: 如果 f(t,y)f(t,y)f(t,y) 在包含点 (t0,y0)(t_0, y_0)(t0​,y0​) 的某个矩形区域 D={(t,y)∣∣t−t0∣≤a,∣y−y0∣≤b}D = \\{(t,y) | |t-t_0| \\le a, |y-y_0| \\le b \\}D={(t,y)∣∣t−t0​∣≤a,∣y−y0​∣≤b} 内连续，则IVP至少在区间 ∣t−t0∣≤min⁡(a,b/M)|t-t_0| \\le \\min(a, b/M)∣t−t0​∣≤min(a,b/M) (其中 M=max⁡D∣f(t,y)∣M=\\max_D |f(t,y)|M=maxD​∣f(t,y)∣) 内存在一个解。 唯一性: 如果在上述区域 DDD 内，f(t,y)f(t,y)f(t,y) 关于 yyy 还满足利普希茨条件 (Lipschitz condition)，即存在常数 L\u003e0L\u003e0L\u003e0 使得对区域 DDD 内的任意 (t,y1)(t,y_1)(t,y1​) 和 (t,y2)(t,y_2)(t,y2​)，都有： ∣f(t,y1)−f(t,y2)∣≤L∣y1−y2∣|f(t,y_1) - f(t,y_2)| \\le L|y_1 - y_2|∣f(t,y1​)−f(t,y2​)∣≤L∣y1​−y2​∣ 则IVP在该存在区间内有唯一的解。 一个更强的（但更容易验证的）条件是：如果 ∂f∂y\\frac{\\partial f}{\\partial y}∂y∂f​ 在 DDD 内存在且有界，则 fff 满足利普希茨条件。 1.4. 为何需要数值方法？ 无解析解: 大多数实际问题中的ODE（尤其非线性ODE）无法找到用初等函数表示的解析解。 解析解复杂: 即使存在解析解，形式也可能非常复杂，不便于实际计算或分析。 模型仿真: 物理、化学、生物、工程、经济等领域的许多动态系统用ODE建模，数值解法是进行系统行为预测和仿真的关键。 1.5. 数值解法的基本思想 给定IVP y′(t)=f(t,y),y(t0)=y0y'(t) = f(t,y), y(t_0)=y_0y′(t)=f(t,y),y(t0​)=y0​。我们希望在离散时间点 t0,t1,t2,…,tNt_0, t_1, t_2, \\dots, t_Nt0​,t1​,t2​,…,tN​ 上找到解的近似值 y0,y1,y2,…,yNy_0, y_1, y_2, \\dots, y_Ny0​,y1​,y2​,…,yN​。通常取等距节点 tk=t0+kht_k = t_0 + khtk​=t0​+kh，其中 hhh 是步长 (step size)。 数值方法提供一个递推关系，从已知的 (tk,yk)(t_k, y_k)(tk​,yk​) 和微分方程本身，计算出下一个点的近似值 yk+1≈y(tk+1)y_{k+1} \\approx y(t_{k+1})yk+1​≈y(tk+1​)。 2. 欧拉方法 (Euler’s Method) 2.1. 推导 泰勒展开: y(tk+1)=y(tk+h)=y(tk)+hy′(tk)+h22y′′(ξk)y(t_{k+1}) = y(t_k+h) = y(t_k) + h y'(t_k) + \\frac{h^2}{2} y''(\\xi_k)y(tk+1​)=y(tk​+h)=y(tk​)+hy′(tk​)+2h2​y′′(ξk​) for ξk∈(tk,tk+1)\\xi_k \\in (t_k, t_{k+1})ξk​∈(tk​,tk+1​)。 已知 y′(tk)=f(tk,y(tk))y'(t_k) = f(t_k, y(t_k))y′(tk​)=f(tk​,y(tk​))。忽略 O(h2)O(h^2)O(h2) 项，并用 yky_kyk​ 近似 y(tk)y(t_k)y(tk​)： yk+1=yk+hf(tk,yk)y_{k+1} = y_k + h f(t_k, y_k)yk+1​=yk​+hf(tk​,yk​) 差分近似: y′(tk)≈y(tk+1)−y(tk)hy'(t_k) \\approx \\frac{y(t_{k+1}) - y(t_k)}{h}y′(tk​)≈hy(tk+1​)−y(tk​)​ (向前差分)。 f(tk,yk)≈yk+1−ykh ⟹ yk+1=yk+hf(tk,yk)f(t_k, y_k) \\approx \\frac{y_{k+1} - y_k}{h} \\implies y_{k+1} = y_k + h f(t_k, y_k)f(tk​,yk​)≈hyk+1​−yk​​⟹yk+1​=yk​+hf(tk​,yk​)。 2.2. 几何解释 在点 (tk,yk)(t_k, y_k)(tk​,yk​) 处，解曲线的斜率为 f(tk,yk)f(t_k, y_k)f(tk​,yk​)。欧拉法沿着这条切线方向前进一个步长 hhh，到达的点 (tk+1,yk+hf(tk,yk))(t_{k+1}, y_k + hf(t_k,y_k))(tk+1​,yk​+hf(tk​,yk​)) 作为 y(tk+1)y(t_{k+1})y(tk+1​) 的近似值 yk+1y_{k+1}yk+1​。本质上是用直线段逼近解曲线。 2.3. 误差分析 局部截断误差 (LTE): 假设 yk=y(tk)y_k = y(t_k)yk​=y(tk​) (当前步初值精确)，一步计算产生的误差。 LTE =y(tk+1)−(yk+hf(tk,yk))=y(tk+1)−(y(tk)+hy′(tk))=h22y′′(ξk)= y(t_{k+1}) - (y_k + h f(t_k, y_k)) = y(t_{k+1}) - (y(t_k) + h y'(t_k)) = \\frac{h^2}{2} y''(\\xi_k)=y(tk+1​)−(yk​+hf(tk​,yk​))=y(tk+1​)−(y(tk​)+hy′(tk​))=2h2​y′′(ξk​)。 所以欧拉法的 LTE 是 O(h2)O(h^2)O(h2)。 全局截断误差 (GTE): 在某个固定时间 T=t0+NhT = t_0 + NhT=t0​+Nh 处的累积误差 EN=∣y(T)−yN∣E_N = |y(T) - y_N|EN​=∣y(T)−yN​∣。 可以证明，对于欧拉方法，GTE 是 O(h","date":"2025-05-26","objectID":"/posts/math/mathmatic-analysis/notes5/:0:0","series":null,"tags":[],"title":"数值分析笔记——ODE","uri":"/posts/math/mathmatic-analysis/notes5/#"},{"categories":[],"content":" 综合学习笔记 📝 本笔记整合了关于 vLLM、Ray、VerL (强化学习库) 的使用说明，以及 python -m 命令的工作原理解释。 1. vLLM: 高效的 LLM 推理和服务 🚀 vLLM 是什么? vLLM 是一个专注于大型语言模型 (LLM) 推理和服务的开源库。它通过创新的 PagedAttention 机制，显著提高了 LLM 推理的吞吐量和内存效率。 核心特性: PagedAttention: 核心技术，优化 KV 缓存管理，减少内存浪费，支持更长上下文和更多并发。 高吞吐量: 通常比 Hugging Face Transformers 有数倍提升。 易用性: 提供与 OpenAI API 兼容的接口。 流式输出 (Streaming): 支持 token 级别流式输出。 分布式推理: 支持张量并行。 多模型架构支持: Llama, GPT 系列, OPT, BLOOM, Mixtral 等。 快速上手: 安装: pip install vllm Python API 示例: from vllm import LLM, SamplingParams llm = LLM(model=\"meta-llama/Meta-Llama-3-8B-Instruct\") # 示例模型 sampling_params = SamplingParams(temperature=0.7, top_p=0.95, max_tokens=256) prompts = [\"The capital of France is\"] outputs = llm.generate(prompts, sampling_params) print(f\"Prompt: {outputs[0].prompt!r}, Generated text: {outputs[0].outputs[0].text!r}\") OpenAI 兼容 API 服务: python -m vllm.entrypoints.openai.api_server --model meta-llama/Meta-Llama-3-8B-Instruct 服务地址: http://localhost:8000/v1/... 使用场景: 高吞吐量、低延迟 LLM 推理。 聊天机器人、文本生成服务。 需要长上下文的应用。 注意事项: 主要为 NVIDIA GPU 设计。 关注模型兼容性和 GPU 显存。 2. Ray: 分布式计算的通用框架 🌐 Ray 是什么? Ray 是一个开源的、用于构建和运行分布式应用程序的通用框架，简化了 Python 代码从单机到大规模集群的扩展。 核心概念与特性: 任务 (Tasks): @ray.remote 装饰的无状态 Python 函数，可远程异步执行。 import ray ray.init() @ray.remote def slow_function(x): return x * 2 futures = [slow_function.remote(i) for i in range(4)] print(ray.get(futures)) # [0, 2, 4, 6] ray.shutdown() Actor: @ray.remote 装饰的有状态 Python 类，可远程实例化和调用方法。 import ray ray.init() @ray.remote class Counter: def __init__(self): self.value = 0 def increment(self): self.value += 1; return self.value counter_actor = Counter.remote() print(ray.get([counter_actor.increment.remote() for _ in range(3)])) # [1, 2, 3] ray.shutdown() 对象存储 (Object Store): 内置分布式内存对象存储，通过 ray.put() 和 ray.get() 高效共享数据。 Ray AI Runtime (AIR): 集成 Ray Data (数据处理), Ray Train (模型训练), Ray Tune (超参数调整), Ray Serve (模型部署) 的机器学习工具集。 可扩展性与容错性。 快速上手: 安装: pip install ray[default] 初始化/关闭: ray.init() 和 ray.shutdown()。 使用场景: 并行化 Python 代码。 分布式机器学习 (数据处理、训练、调优、部署)。 构建复杂分布式应用 (如强化学习)。 vLLM + Ray Serve: 分布式部署 LLM 服务。 注意事项: 有一定学习曲线 (Task, Actor, ObjectRef)。 分布式调试相对复杂 (可使用 Ray Dashboard)。 注意数据序列化。 3. VerL: PyTorch 原生强化学习研究库 🤖🎮 VerL 是什么? VerL (根据 verl.readthedocs.io) 是一个为强化学习 (RL) 研究设计的 Python 库，基于 PyTorch，旨在提供模块化和可扩展的组件。 核心特性 (根据文档推断): PyTorch 原生: 深度集成 PyTorch。 模块化设计: 提供可重用组件 (环境、模型、训练循环等)。 强化学习算法: 可能包含常见 RL 算法实现。 研究友好: 易于实验、修改和扩展。 快速上手 (通用 RL 库实践推测): 安装: 遵循其官方文档的安装指南 (可能为 pip install verl 或从源码安装)。 核心组件使用流程 (推测): 环境 (Environment): 定义或加载 RL 环境 (可能与 Gym/Gymnasium 兼容)。 智能体/策略 (Agent/Policy): 定义 RL 智能体和神经网络模型。 数据收集/经验回放 (Data Collection/Replay Buffer): 收集经验并存储。 训练循环 (Training Loop): 更新智能体策略。 日志与评估 (Logging \u0026 Evaluation): 记录指标，评估性能。 使用场景: 实现和测试新的 RL 算法。 进行 RL 学术研究和实验。 快速搭建 RL 问题原型。 注意事项: 仔细阅读官方文档，特别是 API 和示例。 文档完整性和社区支持可能不如成熟库。 研究性质库的 API 可能在迭代中变化。 4. python -m \u003cmodule-name\u003e 工作原理解析 ⚙️ python -m \u003cmodule-name\u003e 是一种将 Python 模块作为脚本来运行的方式。 工作流程: 模块定位: Python 在其模块搜索路径 (sys.path) 中查找 \u003cmodule-name\u003e。sys.path 包括当前目录、标准库、第三方库 (site-packages) 和 PYTHONPATH 环境变量中的路径。 作为脚本执行: 找到模块后，Python 会将其作为顶层代码执行。 该模块的内置变量 __name__ 会被设置为字符串 \"__main__\"。 这使得可以使用 if __name__ == \"__main__\": 结构来包含仅在模块作为脚本运行时才执行的代码。 包 (Package) 的执行: 如果 \u003cmodule-name\u003e 是一个包，Python 会查找并执行该包下的 __main__.py 文件 (如果存在)。 与 python script.py 的区别: 模块解析: python script.py: 将脚本所在目录添加到 sys.path 开头，直接执行文件。 python -m module_name: 在整个 sys.path 中搜索模块，不依赖当前工作目录。 用途: python script.py: 运行独立脚本。 python -m module_name: 运行标准库工具 (e.g., python -m http.server, python -m venv)。 运行已安装第三方包的 CLI (e.g., python -m pip install ..., python -m pytest, python -m vllm.entrypoints.openai.api_server ...)。 运行自定义包或模块作为应用入口。 为什么使用 python -m? 避免路径问题: 确保 Python 正确找到模块，无需手动处理路径。 包的入口点: 允许包定义清晰的命令行入口 (__main__.py)。 一致性: 标准的模块执行方式。 工具便捷访问: 许多 Python 工具利用此机制提供命令行功能。 ","date":"2025-05-25","objectID":"/posts/ai/frame/verl1/:0:0","series":null,"tags":["AI","system"],"title":"AI架构学习笔记","uri":"/posts/ai/frame/verl1/#"},{"categories":[],"content":"信息瓶颈：像 RWKV 这样的线性注意力模型是否“压缩”过紧？ 大语言模型 (LLM) 正在彻底改变我们与信息交互的方式，但它们处理和“记忆”长文本的能力——即上下文窗口——是一个关键的角力场。我们都希望模型能理解整本书，而不仅仅是段落。然而，扩展这个上下文窗口并非易事，常常会遇到计算瓶颈，或者更微妙地，信息瓶颈。 近期的计算和领域内的观察揭示了一种有趣的权衡。让我们深入探讨其中一些见解，特别是关于采用线性注意力机制的模型，如 RWKV。 理想 vs. 现实：信息需求 理论上，要有效捕捉长度为 ’n’ 的序列中所有细微的依赖关系，像 MQAR (多查询注意力与旋转位置编码) 这样的注意力机制可能需要处理或表示至少 nlog⁡nn \\log nnlogn 比特量级的信息。这是一个理论基准，代表了理想注意力机制所能处理的连接和信息的丰富程度。可以将其想象为完全描绘出长文本中所有重要词语间关系所需的数据量。 现在，让我们考虑线性注意力 (Linear Attention) 模型。这些架构是一个突破，因为它们将注意力机制的计算复杂度从随序列长度的 O(n2)O(n^2)O(n2)（平方级）降低到了 O(n)O(n)O(n)（线性级）。这对于处理更长序列而无需担心 GPU 过载来说是一个巨大的胜利。RWKV 是成功实现这种线性方法的一个著名例子，使其能够在推理时作为循环神经网络 (RNN) 运行，从而提供了效率。 然而，这种效率可能需要以信息吞吐量为代价。据估计，线性注意力机制，特别是考虑到其内部状态表示时，在其每一步能够“携带”或处理的信息量方面可能受到限制。如果我们考虑这类模型的隐藏状态维度 ’d’，其信息容量可能更多地与 d2d^2d2 相关。 RWKV-6 与一个计算得出的 25% 利用率？ 根据用户的计算，基于 FP8 精度（每个数字使用 8 比特存储），一个线性注意力模型可以有效地传递或利用一个包含大约 d2⋅8d^2 \\cdot 8d2⋅8 比特信息的状态。 比较这两个数字——全面注意力理论上需要的 nlog⁡nn \\log nnlogn 比特和线性注意力状态的 d2⋅8d^2 \\cdot 8d2⋅8 比特容量——得出了一个有趣（且发人深省）的计算结果： 如果 (d2⋅8)/(nlog⁡n)≈0.25(d^2 \\cdot 8) / (n \\log n) \\approx 0.25(d2⋅8)/(nlogn)≈0.25，这将意味着对于给定的序列长度 ’n’ 和隐藏维度 ’d’，像 RWKV-6 这样的模型可能仅利用了更具表现力（但计算成本更高）的注意力机制所期望达到的理论信息容量的约 25%。 这并不意味着 RWKV-6 无效；其在现实世界中的表现已经证明了自己。相反，这突显出当前高效线性注意力机制的信息处理能力与理论上无需任何损失即可捕获所有潜在长程依赖关系所需的能力之间可能存在显著差距。该模型很可能学会了在其确实拥有的比特数下实现高度效率，专注于最重要的信息。 对“无损”上下文的追求与 O(n2)O(n^2)O(n2) 的阴影 “现在的linear-attention其实只能做到n*(sqrt(n)^2)也就是n^2的复杂度下才能无损上下文。” 让我们解读一下。线性注意力的主要吸引力在于其每一步的 O(n)O(n)O(n) 计算扩展性。但是，如果我们要求“无损”上下文呢？这里的“无损”可能意味着保留与二次注意力机制（具有 O(n2)O(n^2)O(n2) 复杂度）理论上可以捕获的相同水平的细节和依赖信息。 该论点表明，对于当前的线性注意力机制，要在长度为 ’n’ 的序列上真正实现这种“无损”状态，所需的有效资源或内部表征能力可能隐含地以一种反映 O(n2)O(n^2)O(n2) 的方式扩展。例如，如果隐藏维度 ’d’ 需要与 n\\sqrt{n}n​ 成比例增长以在 ’n’ 增加时保持信息保真度，那么我们容量估计（d2⋅8d^2 \\cdot 8d2⋅8 比特）中的 d2d^2d2 项将变得与 ’n’ 成比例。 这并不一定意味着线性注意力的计算步骤会再次变为 O(n2)O(n^2)O(n2)。相反，它可能意味着实现“无损”所需的总信息容量或表征丰富度在根本上仍然以接近 n2n^2n2（序列中所有可能的成对交互的数量）的规模扩展。如果线性注意力每步的容量没有固有地如此快速增长，那么在没有其他架构创新或显著更大的 ’d’ 值（这反过来又会增加计算和内存需求）的情况下，它可能难以在非常长的序列上实现真正的“无损”。 同样至关重要的是要记住，这些大O表示法中的常数因子在实际性能和容量中可能扮演重要角色。d2⋅8d^2 \\cdot 8d2⋅8 中的“8”就是这样一个与 FP8 相关的因子。其他架构细节可能会引入不同的常数。 结论：一场持续的平衡之舞 这些观察结果强调了 LLM 架构设计中复杂的权衡： 标准（二次）注意力为捕获依赖关系提供了丰富的容量，但在处理较长序列时会遇到计算瓶颈。 **线性注意力（如 RWKV 中的）**突破了计算瓶颈，实现了更长的上下文窗口，但可能面临信息瓶颈，与理论上的理想情况甚至二次注意力所能保留的信息（尽管成本更高）相比，可能会“有损”。 如果特定的模型配置和序列长度证实了 RWKV-6 的 25% 利用率这一数字，那么这将是对这种潜在瓶颈的一个鲜明提醒。认为当前线性注意力的“无损”上下文可能仍带有 n2n^2n2 复杂度的阴影（就所需信息而言，如果不是直接的每步计算）的观点表明，我们尚未完全摆脱长序列带来的挑战。 研究仍在不断突破界限，探索新的注意力机制、不同的信息压缩和检索方法以及混合方法。目标始终如一：构建能够高效理解海量上下文且不丢失关键信息的模型。显然，实现这一目标的旅程仍然充满着激动人心的挑战和巧妙的解决方案。 ","date":"2025-05-25","objectID":"/posts/ai/views/1/:0:0","series":null,"tags":["AI","Linear Attention"],"title":"ai随想1——Linear Attention真的能成功吗？","uri":"/posts/ai/views/1/#"},{"categories":[],"content":"好的，这是一份根据您提供的PPT内容整理的详细中文笔记。 课程笔记：化学基础 第一部分：第16章 酸碱平衡 (Acid–Base Equilibria) 1. 酸碱定义 (Some Definitions) 阿伦尼乌斯 (Arrhenius) 定义： 酸： 在水溶液中电离时，产生的阳离子全部是氢离子 (H⁺) 的化合物。即在水中溶解时增加氢离子浓度的物质。 碱： 在水溶液中电离时，产生的阴离子全部是氢氧根离子 (OH⁻) 的化合物。即在水中溶解时增加氢氧根离子浓度的物质。 局限性： 仅限于水溶液，且对某些不含H⁺或OH⁻但表现出酸碱性的物质无法解释（如NH₃）。 布朗斯特-劳里 (Brønsted–Lowry) 定义 (质子理论)： 酸： 凡是能给出质子 (H⁺) 的物质（质子给予体/质子给体）。 碱： 凡是能接受质子 (H⁺) 的物质（质子接受体/质子受体）。 特点： 酸碱的共轭关系： 酸失去质子后变成其共轭碱；碱得到质子后变成其共轭酸。例如：HA (酸) ⇌ H⁺ + A⁻ (共轭碱)；B (碱) + H⁺ ⇌ BH⁺ (共轭酸)。 酸碱反应的实质： 质子在两种物质间的传递。 相对性： 一种物质是酸还是碱，取决于它与哪种物质反应。例如，水在与强酸反应时是碱，与强碱反应时是酸。 广泛性： 不局限于水溶液，可用于非水体系和气相反应。 布朗斯特-劳里酸必须至少有一个可离解的（酸性）质子 (H⁺) 供捐赠。 布朗斯特-劳里碱必须至少有一对未成键电子对以接受质子 (H⁺)。 水的特殊性 (What Is Different about Water?) 水可以作为布朗斯特-劳里碱，接受来自酸的质子（如 HCl + H₂O → H₃O⁺ + Cl⁻，水是碱）。 水也可以作为布朗斯特-劳里酸，提供质子（如 NH₃ + H₂O ⇌ NH₄⁺ + OH⁻，水是酸）。 因此，水是两性物质 (amphiprotic/amphoteric)，既能作为酸也能作为碱。 两性 (amphiprotic) 特指能给出或接受质子的物质。 两性 (amphoteric) 泛指既能与酸反应又能与碱反应的物质（如Al₂O₃）。 路易斯 (Lewis) 酸碱理论 (电子理论)： 路易斯酸： 凡是能接受电子对的物质（电子对接受体）。 路易斯碱： 凡是能给出电子对的物质（电子对给予体）。 特点： 范围最广，包含所有阿伦尼乌斯酸碱和布朗斯特-劳里酸碱。 有些化合物不符合布朗斯特-劳里定义，但符合路易斯定义（例如BF₃是路易斯酸，NH₃是路易斯碱，BF₃接受NH₃的孤对电子形成配位键）。 酸碱反应的实质是形成配位键。 三种酸碱定义比较： 定义 酸 碱 阿伦尼乌斯 H⁺ 产生者 水中OH⁻ 产生者 布朗斯特-劳里 H⁺ 给予体 H⁺ 接受体 路易斯 电子对接受体 电子对给予体 2. 共轭酸碱对 (Conjugate Acids and Bases) “共轭 (conjugate, 共轭)” 意为“成对连接”。 酸碱反应总是产生它们的共轭碱和共轭酸。 例如：HNO₂(aq) (酸) + H₂O(l) (碱) ⇌ NO₂⁻(aq) (共轭碱) + H₃O⁺(aq) (共轭酸) HNO₂ 失去H⁺ 变为 NO₂⁻。 H₂O 得到H⁺ 变为 H₃O⁺。 3. 酸碱的相对强度 (Relative Strengths of Acids and Bases) 强酸： 在水中完全电离，其共轭碱是非常弱的碱（碱性可忽略，在水中不表现碱性）。例如HCl的共轭碱Cl⁻。 弱酸： 在水中部分电离，其共轭碱是弱碱。 强碱： 在水中完全接受质子或电离出OH⁻，其共轭酸是非常弱的酸（酸性可忽略）。例如O²⁻的共轭酸OH⁻。 弱碱： 在水中部分接受质子，其共轭酸是弱酸。 规律： 酸越强，其共轭碱越弱；碱越强，其共轭酸越弱。 酸碱反应方向： 反应倾向于从强酸向强碱转移质子，生成较弱的酸和较弱的碱。 HCl(aq) + H₂O(l) → H₃O⁺(aq) + Cl⁻(aq) (K » 1)，HCl是强酸，H₂O比Cl⁻是更强的碱，平衡极度偏右。 CH₃COOH(aq) + H₂O(l) ⇌ H₃O⁺(aq) + CH₃COO⁻(aq) (K \u003c 1)，CH₃COO⁻比H₂O是更强的碱，平衡偏左。 4. 水的自偶电离 (Autoionization of Water) 水是两性物质，纯水中少数水分子会发生质子转移，一个水分子作为酸，另一个作为碱。 H₂O(l) + H₂O(l) ⇌ H₃O⁺(aq) + OH⁻(aq) 这个过程称为水的自偶电离 (自电离)。 5. 水的离子积常数 (Ion Product Constant, Kw) 水的自偶电离平衡表达式：Kc = [H₃O⁺][OH⁻] 这个特殊的平衡常数称为水的离子积常数，用 Kw 表示。 在 25 °C 时，Kw = [H₃O⁺][OH⁻] = 1.0 × 10⁻¹⁴。 6. 溶液的酸碱性 中性溶液： [H⁺] = [OH⁻] (在25°C时，均为1.0 × 10⁻⁷ M) 酸性溶液： [H⁺] \u003e [OH⁻] 碱性溶液： [H⁺] \u003c [OH⁻] 7. pH 和 pOH pH： 报告水合氢离子 (H₃O⁺ 或 H⁺) 浓度的一种方法。 pH = –log[H⁺] pH 标度： 中性 pH = 7.00 (25 °C) 酸性 pH \u003c 7.00 碱性 pH \u003e 7.00 其他 “p” 标度： “p” 表示对某个量取负对数。 pOH = –log[OH⁻] pKw = –logKw pH 和 pOH 的关系： 因为 [H₃O⁺][OH⁻] = Kw = 1.0 × 10⁻¹⁴ 两边取负对数：–log[H₃O⁺] + (–log[OH⁻]) = –logKw 所以：pH + pOH = pKw = 14.00 (在 25 °C) 8. pH 的测量 (How Do We Measure pH?) 指示剂 (Indicators)： 包括石蕊试纸，用于不太精确的测量。指示剂在其酸式和碱式形态下呈现不同颜色。 pH 计 (pH meters)： 用于精确测量 pH。电极检测电压的微小变化来指示 pH。 9. 强酸和强碱 (Strong Acids and Strong Bases) 强酸： 七种常见强酸：HCl, HBr, HI, HNO₃, H₂SO₄ (第一步电离), HClO₃, HClO₄。 它们是强电解质，在水溶液中完全电离成离子。 HA + H₂O → H₃O⁺ + A⁻ 对于单质子强酸，[H₃O⁺] = [酸的初始浓度]。 强碱： 可溶性氢氧化物，主要是碱金属氢氧化物和较重的碱土金属氢氧化物 (Ca(OH)₂, Sr(OH)₂, Ba(OH)₂)。 它们在水溶液中完全解离。 MOH(aq) → M⁺(aq) + OH⁻(aq) 或 M(OH)₂(aq) → M²⁺(aq) + 2OH⁻(aq) 10. 弱酸 (Weak Acids) 弱酸在水中部分电离：HA(aq) + H₂O(l) ⇌ H₃O⁺(aq) + A⁻(aq) 其平衡常数称为 酸解离常数 (acid-dissociation constant, Ka) (酸解离常数，酸离解常数)。 Ka = [H₃O⁺][A⁻] / [HA] Ka 值越大，酸性越强。 比较强酸和弱酸： 强酸完全解离成离子。 弱酸仅部分解离成离子。 11. 计算 Ka 和 pH 由 pH 计算 Ka： 根据 pH 计算 [H₃O⁺] ([H₃O⁺] = 10^(-pH))。对于一元弱酸，[H₃O⁺] = [A⁻]。 建立 ICE 表（Initial, Change, Equilibrium），列出初始浓度、变化浓度和平衡浓度。 代入 Ka 表达式计算。 例如：0.10 M HCOOH，pH=2.38。[H₃O⁺] = [HCOO⁻] = 10⁻²·³⁸ = 4.2 × 10⁻³ M。 平衡时 [HCOOH] = 0.10 - 4.2 × 10⁻³ = 0.0958 M。 Ka = (4.2 × 10⁻³)² / 0.0958 ≈ 1.8 × 10⁻⁴。 百分电离度 (Percent Ionization)： 百分电离度 = ([H₃O⁺]_eq / [HA]_initial) × 100% 由 Ka 计算 pH (ICE表法)： 写出电离方程式。 写出 Ka 表达式。 建立 ICE 表，设未知数 x 表示 [H₃O⁺]_eq。 将平衡浓度代入 Ka 表达式，解出 x。 近似： 如果 Ka 很小且酸的初始浓度较大 ([HA]_initial / Ka \u003e 400 或 x 远小于初始浓度，通常 x \u003c 5% 初始浓度)，则可以近似 [HA]_eq ≈ [HA]_initial，简化计算，避免解二次方程。 计算 pH (pH = -log(x))。 例如：计算 0.30 M CH₃COOH 的 pH，Ka = 1.8 × 10⁻⁵。 CH₃COOH + H₂O ⇌ H₃O⁺ + CH₃COO⁻ ICE表：初 0.30, 0, 0; 变 -x, +x, +x; 平 0.30-x, x, x。 Ka = x² / (0.30 - x) = 1.8 × 10⁻⁵。 近似：x² / 0.30 ≈ 1.8 × 10⁻⁵，x ≈ 2.3 × 10⁻³。 检验近似：(2.3 × 10⁻³ / 0.30) × 100% ≈ 0.77% \u003c 5%，近似成立。 pH = -log(2.3 × 10⁻³) = 2.64。 12. 多质子酸 (Polyprotic Aci","date":"2025-05-23","objectID":"/posts/chemistry/review1/:0:0","series":null,"tags":[],"title":"化学复习笔记1","uri":"/posts/chemistry/review1/#"},{"categories":[],"content":"数值分析课程笔记: 数值积分 授课老师: Gemini 日期: 2025年5月19日 1. 数值积分引论 (Numerical Integration / Quadrature) 目的: 计算定积分 I=∫abf(x)dxI = \\int_a^b f(x) dxI=∫ab​f(x)dx 的近似值。 需求场景: 被积函数 f(x)f(x)f(x) 的原函数 F(x)F(x)F(x) 难以找到或不存在初等函数形式。 f(x)f(x)f(x) 仅以离散数据点形式给出。 基本思想: 用一个能够容易积分的函数 P(x)P(x)P(x) (通常是多项式) 来近似 f(x)f(x)f(x)，即 ∫abf(x)dx≈∫abP(x)dx\\int_a^b f(x) dx \\approx \\int_a^b P(x) dx∫ab​f(x)dx≈∫ab​P(x)dx。 求积公式一般形式: ∫abf(x)dx≈∑i=0nwif(xi)\\int_a^b f(x) dx \\approx \\sum_{i=0}^n w_i f(x_i)∫ab​f(x)dx≈∑i=0n​wi​f(xi​) xix_ixi​: 求积节点 (nodes / abscissas) wiw_iwi​: 求积权重 (weights / coefficients) 2. 牛顿-柯特斯公式 (Newton-Cotes Formulas) 基于在等距节点上对 f(x)f(x)f(x) 进行多项式插值，然后对插值多项式积分。 wi=∫abLi(x)dxw_i = \\int_a^b L_i(x) dxwi​=∫ab​Li​(x)dx，其中 Li(x)L_i(x)Li​(x) 是拉格朗日基函数。 2.1. 闭型公式 (Closed Formulas - 节点包含端点) a) 梯形法则 (Trapezoidal Rule, n=1n=1n=1) 用连接 (a,f(a))(a, f(a))(a,f(a)) 和 (b,f(b))(b, f(b))(b,f(b)) 的直线段近似 f(x)f(x)f(x)。 公式: ∫abf(x)dx≈b−a2[f(a)+f(b)]\\int_a^b f(x) dx \\approx \\frac{b-a}{2} [f(a) + f(b)]∫ab​f(x)dx≈2b−a​[f(a)+f(b)] 令 h=b−ah=b-ah=b−a。 截断误差: ET=−h312f′′(ξ)=−(b−a)312f′′(ξ)E_T = -\\frac{h^3}{12} f''(\\xi) = -\\frac{(b-a)^3}{12} f''(\\xi)ET​=−12h3​f′′(ξ)=−12(b−a)3​f′′(ξ), ξ∈(a,b)\\xi \\in (a,b)ξ∈(a,b)。精度为1。 b) 辛普森法则 (Simpson’s Rule, n=2n=2n=2) 用通过 (a,f(a))(a, f(a))(a,f(a)), (a+b2,f(a+b2))(\\frac{a+b}{2}, f(\\frac{a+b}{2}))(2a+b​,f(2a+b​)), (b,f(b))(b, f(b))(b,f(b)) 的抛物线近似 f(x)f(x)f(x)。 令 h=(b−a)/2h = (b-a)/2h=(b−a)/2 (注意这里的 hhh 是半区间宽度)。节点为 a,a+h,a+2h=ba, a+h, a+2h=ba,a+h,a+2h=b。 公式: ∫abf(x)dx≈h3[f(a)+4f(a+h)+f(b)]=b−a6[f(a)+4f(a+b2)+f(b)]\\int_a^b f(x) dx \\approx \\frac{h}{3} [f(a) + 4f(a+h) + f(b)] = \\frac{b-a}{6} \\left[f(a) + 4f\\left(\\frac{a+b}{2}\\right) + f(b)\\right]∫ab​f(x)dx≈3h​[f(a)+4f(a+h)+f(b)]=6b−a​[f(a)+4f(2a+b​)+f(b)] 截断误差: ET=−h590f(4)(ξ)=−(b−a)52880f(4)(ξ)E_T = -\\frac{h^5}{90} f^{(4)}(\\xi) = -\\frac{(b-a)^5}{2880} f^{(4)}(\\xi)ET​=−90h5​f(4)(ξ)=−2880(b−a)5​f(4)(ξ), ξ∈(a,b)\\xi \\in (a,b)ξ∈(a,b)。精度为3。 2.2. 更高阶牛顿-柯特斯公式及其局限性 n=3n=3n=3 (辛普森3/8法则): ∫x0x3f(x)dx≈3h8[f(x0)+3f(x1)+3f(x2)+f(x3)]\\int_{x_0}^{x_3} f(x)dx \\approx \\frac{3h}{8}[f(x_0)+3f(x_1)+3f(x_2)+f(x_3)]∫x0​x3​​f(x)dx≈83h​[f(x0​)+3f(x1​)+3f(x2​)+f(x3​)], ET=O(h5)E_T=O(h^5)ET​=O(h5)。精度3。 n=4n=4n=4 (布尔法则): ∫x0x4f(x)dx≈2h45[7f0+32f1+12f2+32f3+7f4]\\int_{x_0}^{x_4} f(x)dx \\approx \\frac{2h}{45}[7f_0+32f_1+12f_2+32f_3+7f_4]∫x0​x4​​f(x)dx≈452h​[7f0​+32f1​+12f2​+32f3​+7f4​], ET=O(h7)E_T=O(h^7)ET​=O(h7)。精度5。 误差规律: n+1n+1n+1 个节点的闭型公式，若 nnn 为奇数，精度为 nnn；若 nnn 为偶数，精度为 n+1n+1n+1。 局限性: 负权系数: 当 n≥8n \\ge 8n≥8 时，部分 wi\u003c0w_i \u003c 0wi​\u003c0，可能导致数值不稳定和舍入误差放大。 不稳定性: 高阶等距节点插值可能出现龙格现象，积分结果可能不收敛或发散。 因此，通常不使用非常高阶的牛顿-柯特斯公式，而是采用复化低阶公式。 3. 复化求积公式 (Composite Quadrature Rules) 将区间 [a,b][a,b][a,b] 分成 NNN 个等长的子区间，宽度 h=(b−a)/Nh=(b-a)/Nh=(b−a)/N。在每个子区间上应用低阶牛顿-柯特斯公式。 3.1. 复化梯形法则 ∫abf(x)dx≈h2[f(x0)+2f(x1)+⋯+2f(xN−1)+f(xN)]\\int_a^b f(x) dx \\approx \\frac{h}{2} [f(x_0) + 2f(x_1) + \\dots + 2f(x_{N-1}) + f(x_N)]∫ab​f(x)dx≈2h​[f(x0​)+2f(x1​)+⋯+2f(xN−1​)+f(xN​)] 截断误差: ET=−(b−a)h212f′′(ξˉ)E_T = -\\frac{(b-a)h^2}{12} f''(\\bar{\\xi})ET​=−12(b−a)h2​f′′(ξˉ​), ξˉ∈(a,b)\\bar{\\xi} \\in (a,b)ξˉ​∈(a,b)。全局误差 O(h2)O(h^2)O(h2)。 3.2. 复化辛普森法则 (NNN 必须为偶数) 将 [a,b][a,b][a,b] 分成 NNN 个子区间，应用 N/2N/2N/2 次基本辛普森法则。 ∫abf(x)dx≈h3[f(x0)+4f(x1)+2f(x2)+4f(x3)+⋯+2f(xN−2)+4f(xN−1)+f(xN)]\\int_a^b f(x) dx \\approx \\frac{h}{3} [f(x_0) + 4f(x_1) + 2f(x_2) + 4f(x_3) + \\dots + 2f(x_{N-2}) + 4f(x_{N-1}) + f(x_N)]∫ab​f(x)dx≈3h​[f(x0​)+4f(x1​)+2f(x2​)+4f(x3​)+⋯+2f(xN−2​)+4f(xN−1​)+f(xN​)] 截断误差: ET=−(b−a)h4180f(4)(ξˉ)E_T = -\\frac{(b-a)h^4}{180} f^{(4)}(\\bar{\\xi})ET​=−180(b−a)h4​f(4)(ξˉ​), ξˉ∈(a,b)\\bar{\\xi} \\in (a,b)ξˉ​∈(a,b)。全局误差 O(h4)O(h^4)O(h4)。 4. 龙贝格积分 (Romberg Integration) 基础: 复化梯形法则 T(h)T(h)T(h)。 误差展开 (欧拉-麦克劳林公式): ∫abf(x)dx=T(h)+C1h2+C2h4+C3h6+…\\int_a^b f(x)dx = T(h) + C_1 h^2 + C_2 h^4 + C_3 h^6 + \\dots∫ab​f(x)dx=T(h)+C1​h2+C2​h4+C3​h6+… 理查森外推: 利用不同步长的 T(h)T(h)T(h) 值消除误差项。 龙贝格表 (Romberg Tableau): Rk,0=T(hk)R_{k,0} = T(h_k)Rk,0​=T(hk​)，其中 hk=(b−a)/2kh_k = (b-a)/2^khk​=(b−a)/2k。 R0,0=b−a2[f(a)+f(b)]R_{0,0} = \\frac{b-a}{2}[f(a)+f(b)]R0,0​=2b−a​[f(a)+f(b)] Rk,0=12Rk−1,0+hk∑i=12k−1f(a+(2i−1)hk)R_{k,0} = \\frac{1}{2} ","date":"2025-05-19","objectID":"/posts/math/mathmatic-analysis/notes4/:0:0","series":null,"tags":[],"title":"数值分析笔记四——数值积分","uri":"/posts/math/mathmatic-analysis/notes4/#"},{"categories":[],"content":"数值分析课程笔记 (详细版：切比雪夫节点 至 数值微分结束) 授课老师: Gemini 日期: 2025年5月16日 7. 插值法 (续) 7.5. 切比雪夫节点 (Chebyshev Nodes) 7.5.1. 动机与目的 多项式插值的误差公式为： En(x)=f(x)−Pn(x)=f(n+1)(ξx)(n+1)!∏i=0n(x−xi)E_n(x) = f(x) - P_n(x) = \\frac{f^{(n+1)}(\\xi_x)}{(n+1)!} \\prod_{i=0}^n (x-x_i)En​(x)=f(x)−Pn​(x)=(n+1)!f(n+1)(ξx​)​i=0∏n​(x−xi​) 为减小误差，除了依赖于被插函数 fff 的高阶导数 f(n+1)(ξx)f^{(n+1)}(\\xi_x)f(n+1)(ξx​) 外，我们主要能控制的是节点 xix_ixi​ 的选取，以使 max⁡x∈[a,b]∣∏i=0n(x−xi)∣\\max_{x \\in [a,b]} \\left| \\prod_{i=0}^n (x-x_i) \\right|maxx∈[a,b]​∣∏i=0n​(x−xi​)∣ 尽可能小。等距节点在区间端点附近会导致这一项的值很大，从而引发龙格现象。切比雪夫节点的选取正是为了优化这一连乘项。 7.5.2. 切比雪夫多项式 (第一类) 第一类 kkk 次切比雪夫多项式 Tk(x)T_k(x)Tk​(x) 定义在 [−1,1][-1, 1][−1,1] 上： Tk(x)=cos⁡(karccos⁡x),x∈[−1,1]T_k(x) = \\cos(k \\arccos x), \\quad x \\in [-1, 1]Tk​(x)=cos(karccosx),x∈[−1,1] 例如： T0(x)=1T_0(x) = 1T0​(x)=1 T1(x)=xT_1(x) = xT1​(x)=x T2(x)=2x2−1T_2(x) = 2x^2 - 1T2​(x)=2x2−1 Tk(x)T_k(x)Tk​(x) 的首项系数为 2k−12^{k-1}2k−1 (对于 k≥1k \\ge 1k≥1)。 重要性质: 在 [−1,1][-1,1][−1,1] 上，所有首项系数为1的 nnn 次多项式中，12n−1Tn(x)\\frac{1}{2^{n-1}}T_n(x)2n−11​Tn​(x) 的最大绝对值是最小的，为 12n−1\\frac{1}{2^{n-1}}2n−11​。 7.5.3. 切比雪夫插值节点 要使 ωn+1(x)=∏i=0n(x−xi)\\omega_{n+1}(x) = \\prod_{i=0}^n (x-x_i)ωn+1​(x)=∏i=0n​(x−xi​) (一个 n+1n+1n+1 次首一多项式) 的最大绝对值最小，应使其等于 12nTn+1(x)\\frac{1}{2^n}T_{n+1}(x)2n1​Tn+1​(x)。因此，插值节点 xix_ixi​ (对于 nnn 次插值多项式，共 n+1n+1n+1 个节点) 应取为 Tn+1(x)T_{n+1}(x)Tn+1​(x) 在 [−1,1][-1,1][−1,1] 上的零点。 Tn+1(x)=cos⁡((n+1)arccos⁡x)=0 ⟹ (n+1)arccos⁡x~k=(2k+1)π2T_{n+1}(x) = \\cos((n+1)\\arccos x) = 0 \\implies (n+1)\\arccos \\tilde{x}_k = \\frac{(2k+1)\\pi}{2}Tn+1​(x)=cos((n+1)arccosx)=0⟹(n+1)arccosx~k​=2(2k+1)π​ 标准区间 [−1,1][-1, 1][−1,1] 上的 n+1n+1n+1 个切比雪夫节点为： x~k=cos⁡((2k+1)π2(n+1)),k=0,1,…,n\\tilde{x}_k = \\cos\\left(\\frac{(2k+1)\\pi}{2(n+1)}\\right), \\quad k=0, 1, \\dots, nx~k​=cos(2(n+1)(2k+1)π​),k=0,1,…,n7.5.4. 节点变换至一般区间 [a,b][a,b][a,b] 通过线性变换 x=a+b2+b−a2x~x = \\frac{a+b}{2} + \\frac{b-a}{2}\\tilde{x}x=2a+b​+2b−a​x~，可得 [a,b][a,b][a,b] 上的切比雪夫节点： xk=a+b2+b−a2cos⁡((2k+1)π2(n+1)),k=0,1,…,nx_k = \\frac{a+b}{2} + \\frac{b-a}{2} \\cos\\left(\\frac{(2k+1)\\pi}{2(n+1)}\\right), \\quad k=0, 1, \\dots, nxk​=2a+b​+2b−a​cos(2(n+1)(2k+1)π​),k=0,1,…,n 这些节点在区间两端较为密集，中间较为稀疏，能有效减轻龙格现象。使用这些节点进行多项式插值，通常能获得比等距节点更好的逼近效果。 7.6. 分段插值与样条插值 7.6.1. 分段插值的动机 高次多项式插值可能导致龙格现象，且计算复杂，对数据扰动敏感。分段插值通过在每个子区间上使用低次多项式来避免这些问题。 7.6.2. 分段线性插值 定义: 在每对相邻数据点 (xi,yi)(x_i, y_i)(xi​,yi​) 和 (xi+1,yi+1)(x_{i+1}, y_{i+1})(xi+1​,yi+1​) 之间用直线段连接。 Pi(x)=yi+yi+1−yixi+1−xi(x−xi),x∈[xi,xi+1]P_i(x) = y_i + \\frac{y_{i+1}-y_i}{x_{i+1}-x_i}(x-x_i), \\quad x \\in [x_i, x_{i+1}]Pi​(x)=yi​+xi+1​−xi​yi+1​−yi​​(x−xi​),x∈[xi​,xi+1​] 性质: 整体函数 P(x)P(x)P(x) 是连续的 (C0C^0C0 连续)。但在节点处，导数通常不连续，形成尖角，不够光滑。 7.6.3. 样条插值的引入 为了获得更光滑的插值曲线，我们不仅要求函数在节点处连续，还要求其导数也连续。样条插值就是满足这种要求的特定分段多项式。 7.7. 三次样条插值详解 (Cubic Spline Interpolation) 7.7.1. 定义 一个在区间 [x0,xn][x_0, x_n][x0​,xn​] 上的三次样条函数 S(x)S(x)S(x) 是一个满足以下条件的函数： 在每个子区间 [xi,xi+1][x_i, x_{i+1}][xi​,xi+1​] 上 (i=0,…,n−1i=0, \\dots, n-1i=0,…,n−1)，S(x)S(x)S(x) 是一个三次多项式，记为 Si(x)S_i(x)Si​(x)。 S(x)S(x)S(x) 在整个区间 [x0,xn][x_0, x_n][x0​,xn​] 上具有二阶连续导数 (即 S(x)∈C2[x0,xn]S(x) \\in C^2[x_0, x_n]S(x)∈C2[x0​,xn​])。这意味着： S(xi)=yiS(x_i) = y_iS(xi​)=yi​ (插值条件) Si(xi+1)=Si+1(xi+1)=yi+1S_i(x_{i+1}) = S_{i+1}(x_{i+1}) = y_{i+1}Si​(xi+1​)=Si+1​(xi+1​)=yi+1​ (函数值在内部节点连续) Si′(xi+1)=Si+1′(xi+1)S'_i(x_{i+1}) = S'_{i+1}(x_{i+1})Si′​(xi+1​)=Si+1′​(xi+1​) (一阶导数在内部节点连续) Si′′(xi+1)=Si+1′′(xi+1)S''_i(x_{i+1}) = S''_{i+1}(x_{i+1})Si′′​(xi+1​)=Si+1′′​(xi+1​) (二阶导数在内部节点连续) 7.7.2. Si(x)S_i(x)Si​(x) 的表示与二阶导数 MiM_iMi​ 令 Mi=S′′(xi)M_i = S''(x_i)Mi​=S′′(xi​) 为节点 xix_ixi​ 处的二阶导数值。由于 Si(x)S_i(x)Si​(x) 是三次多项式，其二阶导数 Si′′(x)S_i''(x)Si′′​(x) 是线性函数。在 [xi,xi+1][x_i, x_{i+1}][xi​,xi+1​] 上， Si′′(xi)=Mi,Si′′(xi+1)=Mi+1S_i''(x_i)=M_i, S_i''(x_{i+1})=M_{i+1}Si′′​(xi​)=Mi​,Si′′​(xi+1​)=Mi+1​，因此： Si′′(x)=Mixi+1−xhi+Mi+1x−xihiS_i''(x) = M_i \\frac{x_{i+1}-x}{h_i} + M_{i+1} \\frac{x-x_i}{h_i}Si′′​(x)=Mi​hi​xi+1​−x​+Mi+1​hi​x−xi​​ 其中 hi=xi+1−xih_i = x_{i+1}-x_ihi​=xi+1​−xi​。 对 Si′′(x)S_i''(x)Si′′​(x) 积分两次可得 Si(x)S_i(x)Si​(x)： Si(x)=Mi(xi+1−x)36hi+Mi+1(x−xi)36hi+C1(x−xi)+C2S_i(x) = M_i \\frac{(x_{i+1}-x)^3}{6h_i} + M_{i+1} \\frac{(x-x_i)^3}{6h_i} + C","date":"2025-05-16","objectID":"/posts/math/mathmatic-analysis/notes3/:0:0","series":null,"tags":["Math","Compute"],"title":"数值分析笔记三","uri":"/posts/math/mathmatic-analysis/notes3/#"},{"categories":[],"content":"数值分析学习笔记 (第六至十讲汇总) 第六讲：线性方程组的误差分析与条件数的影响 1. 回顾与背景 在求解线性方程组 Ax=bAx=bAx=b 时，输入数据 A,bA, bA,b 的不精确性或计算过程中的舍入误差都会影响解的精度。条件数 κ(A)=∥A∥⋅∥A−1∥\\kappa(A) = \\|A\\| \\cdot \\|A^{-1}\\|κ(A)=∥A∥⋅∥A−1∥ (κ(A)≥1\\kappa(A) \\ge 1κ(A)≥1) 是衡量这种敏感性的关键指标。 κ(A)\\kappa(A)κ(A) 接近 1：矩阵 AAA 是良态的 (well-conditioned)。 κ(A)\\kappa(A)κ(A) 很大：矩阵 AAA 是病态的 (ill-conditioned)。 2. 右端项 bbb 的扰动对解的影响 设 AAA 精确且非奇异， bbb 有扰动 Δb\\Delta bΔb。 原系统：Ax=bAx=bAx=b。扰动后系统：A(x+Δx)=b+ΔbA(x+\\Delta x) = b + \\Delta bA(x+Δx)=b+Δb。 推导可得： ∥Δx∥∥x∥≤κ(A)∥Δb∥∥b∥ \\frac{\\|\\Delta x\\|}{\\|x\\|} \\le \\kappa(A) \\frac{\\|\\Delta b\\|}{\\|b\\|} ∥x∥∥Δx∥​≤κ(A)∥b∥∥Δb∥​ 解读：解 xxx 的相对误差上界是右端项 bbb 的相对扰动乘以条件数 κ(A)\\kappa(A)κ(A)。 3. 系数矩阵 AAA 的扰动对解的影响 设 bbb 精确，AAA 有扰动 ΔA\\Delta AΔA。 原系统：Ax=bAx=bAx=b。扰动后系统：(A+ΔA)(x+Δx)=b(A+\\Delta A)(x+\\Delta x) = b(A+ΔA)(x+Δx)=b。 推导可得 (若 x+Δx≠0x+\\Delta x \\neq 0x+Δx=0): ∥Δx∥∥x+Δx∥≤κ(A)∥ΔA∥∥A∥ \\frac{\\|\\Delta x\\|}{\\|x+\\Delta x\\|} \\le \\kappa(A) \\frac{\\|\\Delta A\\|}{\\|A\\|} ∥x+Δx∥∥Δx∥​≤κ(A)∥A∥∥ΔA∥​ 解读：解 xxx 的相对变化上界是系数矩阵 AAA 的相对扰动乘以条件数 κ(A)\\kappa(A)κ(A)。 4. AAA 和 bbb 同时存在扰动 若 (A+ΔA)(x+Δx)=b+Δb(A+\\Delta A)(x+\\Delta x) = b+\\Delta b(A+ΔA)(x+Δx)=b+Δb，且 κ(A)∥ΔA∥∥A∥\u003c1\\kappa(A) \\frac{\\|\\Delta A\\|}{\\|A\\|} \u003c 1κ(A)∥A∥∥ΔA∥​\u003c1，则有： ∥Δx∥∥x∥≤κ(A)1−κ(A)∥ΔA∥∥A∥(∥ΔA∥∥A∥+∥Δb∥∥b∥) \\frac{\\|\\Delta x\\|}{\\|x\\|} \\le \\frac{\\kappa(A)}{1 - \\kappa(A) \\frac{\\|\\Delta A\\|}{\\|A\\|}} \\left( \\frac{\\|\\Delta A\\|}{\\|A\\|} + \\frac{\\|\\Delta b\\|}{\\|b\\|} \\right) ∥x∥∥Δx∥​≤1−κ(A)∥A∥∥ΔA∥​κ(A)​(∥A∥∥ΔA∥​+∥b∥∥Δb∥​)5. 残差 (Residual) 与误差 (Error) 对于近似解 x~\\tilde{x}x~，误差 e=x−x~e = x - \\tilde{x}e=x−x~，残差 r=b−Ax~r = b - A\\tilde{x}r=b−Ax~。 可以推导出： ∥e∥∥x∥≤κ(A)∥r∥∥A∥∥x∥或近似地∥e∥∥x∥≤κ(A)∥r∥∥b∥ \\frac{\\|e\\|}{\\|x\\|} \\le \\kappa(A) \\frac{\\|r\\|}{\\|A\\|\\|x\\|} \\quad \\text{或近似地} \\quad \\frac{\\|e\\|}{\\|x\\|} \\le \\kappa(A) \\frac{\\|r\\|}{\\|b\\|} ∥x∥∥e∥​≤κ(A)∥A∥∥x∥∥r∥​或近似地∥x∥∥e∥​≤κ(A)∥b∥∥r∥​ 关键结论：即使相对残差很小，如果条件数 κ(A)\\kappa(A)κ(A) 很大，解的相对误差仍然可能很大。 6. 条件数的实际意义与精度损失 若 κ(A)≈10k\\kappa(A) \\approx 10^kκ(A)≈10k，并且计算精度为 ppp 位有效数字，则解 xxx 中可靠的有效数字大约只有 p−kp-kp−k 位。 7. 如何估计条件数 直接计算 A−1A^{-1}A−1 代价高。实际中，数值库 (如 LAPACK) 提供了高效的条件数估计器。 第七讲：线性方程组的迭代法 (一) —— 基本概念、雅可比法与高斯-赛德尔法 1. 迭代法的基本思想 对于大型稀疏线性方程组 Ax=bAx=bAx=b，迭代法提供了一种替代直接法的方案。 核心思想：从初始猜测 x(0)x^{(0)}x(0) 开始，通过迭代规则 x(k+1)=f(x(k))x^{(k+1)} = f(x^{(k)})x(k+1)=f(x(k)) 生成序列 x(1),x(2),…x^{(1)}, x^{(2)}, \\dotsx(1),x(2),…，若收敛则逼近真解 xxx。 一般形式：将 AAA 分裂为 A=M−NA=M-NA=M−N (MMM 易求逆)，则 Mx=Nx+bMx=Nx+bMx=Nx+b。迭代格式为 Mx(k+1)=Nx(k)+bMx^{(k+1)} = Nx^{(k)} + bMx(k+1)=Nx(k)+b，即 x(k+1)=M−1Nx(k)+M−1b=Tx(k)+cx^{(k+1)} = M^{-1}Nx^{(k)} + M^{-1}b = Tx^{(k)} + cx(k+1)=M−1Nx(k)+M−1b=Tx(k)+c。 优点：能利用矩阵稀疏性，每步计算量小，内存需求低，可控精度。 收敛性：不保证收敛，依赖于迭代矩阵 TTT 的性质（如谱半径 ρ(T)\u003c1\\rho(T)\u003c1ρ(T)\u003c1）。 停止条件：基于解的连续变化、残差大小或最大迭代次数。 2. 雅可比法 (Jacobi Method) 将 A=D−L−UA=D-L-UA=D−L−U（DDD 为对角阵，−L-L−L 为严格下三角，−U-U−U 为严格上三角）。 迭代公式：Dx(k+1)=(L+U)x(k)+bDx^{(k+1)} = (L+U)x^{(k)} + bDx(k+1)=(L+U)x(k)+b，即（假设 aii≠0a_{ii} \\neq 0aii​=0）： xi(k+1)=1aii(bi−∑j=1,j≠inaijxj(k)),i=1,…,n x_i^{(k+1)} = \\frac{1}{a_{ii}} \\left( b_i - \\sum_{j=1, j \\neq i}^{n} a_{ij}x_j^{(k)} \\right), \\quad i=1, \\dots, n xi(k+1)​=aii​1​​bi​−j=1,j=i∑n​aij​xj(k)​​,i=1,…,n 实现：x(k+1)x^{(k+1)}x(k+1) 的各分量可独立计算（并行性好）。 示例：{4x1−x2=1−x1+3x2=2\\begin{cases} 4x_1 - x_2 = 1 \\\\\\\\ -x_1 + 3x_2 = 2 \\end{cases}⎩⎨⎧​4x1​−x2​=1−x1​+3x2​=2​. 若 x(0)=(0,0)Tx^{(0)}=(0,0)^Tx(0)=(0,0)T, 则 x(1)=(0.25,0.6667)Tx^{(1)}=(0.25, 0.6667)^Tx(1)=(0.25,0.6667)T. 收敛条件 (充分)：AAA 严格对角占优 (SDD)。 3. 高斯-赛德尔法 (Gauss-Seidel Method) 计算 xi(k+1)x_i^{(k+1)}xi(k+1)​ 时使用本轮已更新的 xj(k+1)x_j^{(k+1)}xj(k+1)​ (j\u003cij\u003cij\u003ci)。 迭代公式：(D−L)x(k+1)=Ux(k)+b(D-L)x^{(k+1)} = Ux^{(k)} + b(D−L)x(k+1)=Ux(k)+b，即： xi(k+1)=1aii(bi−∑j=1i−1aijxj(k+1)−∑j=i+1naijxj(k)),i=1,…,n x_i^{(k+1)} = \\frac{1}{a_{ii}} \\left( b_i - \\sum_{j=1}^{i-1} a_{ij}x_j^{(k+1)} - \\sum_{j=i+1}^{n} a_{ij}x_j^{(k)} \\right), \\quad i=1, \\dots, n xi(k+1)​=aii​1​(bi​−j=1∑i−1​aij​xj(k+1)​−j=i+1∑n​aij​xj(k)​),i=1,…,n 实现：顺序计算，可原地更新。 示例 (同上方程组)：若 x(0)=(0,0)Tx^{(0)}=(0,0)^Tx(0)=(0,0)T, 则 x1(1)=0.25,x2(1)=0.75x_1^{(1)}=0.25, x_2^{(1)}=0.75x1(1)​=0.25,x2(1)​=0.75. 收敛条件 (充分)：AAA SDD, 或 AAA 对称正定 (SPD)。 第八讲：迭代法的收敛性与逐次超松弛法 (SOR) 1. 迭代法的收敛性分析 (续) 迭代格式 x(k+1)=Tx(k)+cx^{(k+1)} = Tx^{(k","date":"2025-05-15","objectID":"/posts/math/mathmatic-analysis/notes2/:0:0","series":null,"tags":["Math","Compute"],"title":"数值分析笔记二","uri":"/posts/math/mathmatic-analysis/notes2/#"},{"categories":[],"content":"数值分析学习笔记 整理日期: 2025年5月14日 课程引言：什么是数值分析？ 数值分析是一门研究如何用计算机来寻找数学问题近似解的学科。其核心思想包括： 近似 (Approximation)：用计算机可执行的有限步骤逼近真实的数学解。 算法 (Algorithm)：设计清晰的、一步一步的计算流程。 误差分析 (Error Analysis)：评估近似解与真实解的差距，并控制误差。 我们学习数值分析是为了理解计算机如何处理数学问题，解决实际工程与科学中那些没有解析解或解析解过于复杂的问题，并能明智地选择和使用数值方法。 第一讲：数值计算中的“误差” 误差是数值分析中无法回避的伙伴，理解和控制误差至关重要。 1.1 误差的来源 (Sources of Error) 模型误差 (Modeling Error)：将现实问题简化为数学模型时产生的误差。 测量误差 (Measurement Error / Data Error)：输入数据本身带有的误差。 截断误差 (Truncation Error)：用有限过程近似无限过程产生的误差。 例如，泰勒级数展开 ex=1+x+x22!+x33!+…e^x = 1 + x + \\frac{x^2}{2!} + \\frac{x^3}{3!} + \\dotsex=1+x+2!x2​+3!x3​+…，若只取前几项，则被截断部分构成截断误差。 舍入误差 (Round-off Error)：计算机存储数字位数有限导致的误差。 例如，1/3=0.33333…1/3 = 0.33333\\dots1/3=0.33333… 在计算机中可能被存储为有限位数的小数。 1.2 误差的度量 (Measuring Error) 设 p∗p^*p∗ 为真实值，ppp 为近似值。 绝对误差 (Absolute Error)： Ea=∣p∗−p∣E_a = |p^* - p|Ea​=∣p∗−p∣ 相对误差 (Relative Error)： Er=∣p∗−p∣∣p∗∣E_r = \\frac{|p^* - p|}{|p^*|}Er​=∣p∗∣∣p∗−p∣​ (前提 p∗≠0p^* \\neq 0p∗=0) 相对误差通常更能反映近似的“质量”。在实际中，若 p∗p^*p∗ 未知，可用相邻两次迭代结果的差异来近似误差。 1.3 数字表示、有效数字与灾难性抵消 计算机通常使用浮点表示法存储实数，其精度有限。 有效数字 (Significant Digits)：一个数中被认为是可靠的数字。 灾难性抵消 (Catastrophic Cancellation)：两个相近的数相减，可能导致有效数字急剧损失。例如，计算 0.1234567−0.12345550.1234567 - 0.12345550.1234567−0.1234555，如果精度有限，结果的有效数字位数会显著减少。 1.4 误差传播、算法稳定性与问题条件 误差传播 (Error Propagation)：初始误差或计算过程中的误差如何影响最终结果。 算法稳定性 (Stability)：稳定的算法对初始数据的小扰动不敏感。不稳定的算法会放大误差。 问题条件 (Condition of a Problem)： 病态问题 (Ill-conditioned problem)：输入数据的微小变化导致解的巨大变化。 良态问题 (Well-conditioned problem)：解对输入数据的微小变化不敏感。 稳定性是算法的属性，条件是问题本身的属性。 第二讲：方程求根 (f(x)=0f(x) = 0f(x)=0) 寻找使得函数 f(x)f(x)f(x) 值为零的 xxx。 2.1 求根方法的分类 区间法 (Bracketing Methods)：如二分法。需要包含根的初始区间，通常稳健。 开区间法 (Open Methods)：如牛顿法、割线法。需要初始猜测点，收敛时较快，但不保证收敛。 2.2 二分法 (Bisection Method) 依据：介值定理。若 f(x)f(x)f(x) 在 [a,b][a,b][a,b] 连续且 f(a)f(b)\u003c0f(a)f(b)\u003c0f(a)f(b)\u003c0，则 (a,b)(a,b)(a,b) 内有根。 步骤： 给定初始区间 [a0,b0][a_0, b_0][a0​,b0​] 使得 f(a0)f(b0)\u003c0f(a_0)f(b_0)\u003c0f(a0​)f(b0​)\u003c0，设定容差 ϵ\\epsilonϵ。 计算中点 mk=(ak+bk)/2m_k = (a_k + b_k)/2mk​=(ak​+bk​)/2。 判断根的位置： 若 f(mk)≈0f(m_k) \\approx 0f(mk​)≈0 或 ∣bk−ak∣/2\u003cϵ|b_k-a_k|/2 \u003c \\epsilon∣bk​−ak​∣/2\u003cϵ（或 ∣mk−mk−1∣\u003cϵ|m_k - m_{k-1}| \u003c \\epsilon∣mk​−mk−1​∣\u003cϵ），则 mkm_kmk​ 为近似根，停止。 若 f(ak)f(mk)\u003c0f(a_k)f(m_k) \u003c 0f(ak​)f(mk​)\u003c0，则新区间为 [ak+1,bk+1]=[ak,mk][a_{k+1}, b_{k+1}] = [a_k, m_k][ak+1​,bk+1​]=[ak​,mk​]。 否则，新区间为 [ak+1,bk+1]=[mk,bk][a_{k+1}, b_{k+1}] = [m_k, b_k][ak+1​,bk+1​]=[mk​,bk​]。 重复步骤 2-3。 例子：f(x)=x3−x−2=0f(x) = x^3 - x - 2 = 0f(x)=x3−x−2=0 在 [1,2][1,2][1,2] 内的根。 a0=1,f(1)=−2a_0=1, f(1)=-2a0​=1,f(1)=−2; b0=2,f(2)=4b_0=2, f(2)=4b0​=2,f(2)=4. m0=1.5,f(1.5)=−0.125m_0 = 1.5, f(1.5)=-0.125m0​=1.5,f(1.5)=−0.125. 新区间 [1.5,2][1.5, 2][1.5,2]. m1=1.75,f(1.75)≈1.609m_1 = 1.75, f(1.75) \\approx 1.609m1​=1.75,f(1.75)≈1.609. 新区间 [1.5,1.75][1.5, 1.75][1.5,1.75]. (以此类推) 特点： 优点：简单，一定收敛。误差 ∣x∗−mn∣≤(b0−a0)/2n+1|x^* - m_n| \\le (b_0-a_0)/2^{n+1}∣x∗−mn​∣≤(b0​−a0​)/2n+1。 缺点：线性收敛 (p=1p=1p=1)，速度慢。不能处理偶数重根。 2.3 不动点迭代法 (Fixed-Point Iteration) 将 f(x)=0f(x)=0f(x)=0 转化为 x=g(x)x=g(x)x=g(x) 的形式。迭代公式：xi+1=g(xi)x_{i+1} = g(x_i)xi+1​=g(xi​)。 收敛条件：若在根 x∗x^*x∗ 附近 ∣g′(x)∣≤L\u003c1|g'(x)| \\le L \u003c 1∣g′(x)∣≤L\u003c1，则迭代收敛。 例子：f(x)=x2−2x−3=0f(x) = x^2 - 2x - 3 = 0f(x)=x2−2x−3=0。 若 x=2x+3=g1(x)x = \\sqrt{2x+3} = g_1(x)x=2x+3​=g1​(x)，对于根 x\\*=3x^\\*=3x\\*=3，g1′(3)=1/3\u003c1g_1'(3)=1/3 \u003c 1g1′​(3)=1/3\u003c1，收敛。 若 x=(x2−3)/2=g2(x)x = (x^2-3)/2 = g_2(x)x=(x2−3)/2=g2​(x)，对于根 x\\*=3x^\\*=3x\\*=3，g2′(3)=3\u003e1g_2'(3)=3 \u003e 1g2′​(3)=3\u003e1，发散。 2.4 牛顿-拉夫逊法 (Newton-Raphson Method) 利用函数在 xix_ixi​ 处的切线与x轴的交点 xi+1x_{i+1}xi+1​ 作为新的近似根。 迭代公式：xi+1=xi−f(xi)f′(xi)x_{i+1} = x_i - \\frac{f(x_i)}{f'(x_i)}xi+1​=xi​−f′(xi​)f(xi​)​ 例子：f(x)=x3−x−2=0f(x) = x^3 - x - 2 = 0f(x)=x3−x−2=0, f′(x)=3x2−1f'(x) = 3x^2 - 1f′(x)=3x2−1. 若 x0=1.5,f(1.5)=−0.125,f′(1.5)=5.75x_0 = 1.5, f(1.5)=-0.125, f'(1.5)=5.75x0​=1.5,f(1.5)=−0.125,f′(1.5)=5.75. x1=1.5−−0.1255.75≈1.521739x_1 = 1.5 - \\frac{-0.125}{5.75} \\approx 1.521739x1​=1.5−5.75−0.125​≈1.521739. (收敛非常快) 特点： 优点：若收敛，则为二次收敛 (p=2p=2p=2)，速度快。 缺点：需计算导数 f′(x)f'(x)f′(x)。若 f′(xi)≈0f'(x_i) \\approx 0f′(xi​)≈0 或初值不好则可能不收敛。对重根收敛变慢。 2.4.1 牛顿法二次收敛性证明 设 x\\*x^\\*x\\* 为根，f(x\\*)=0f(x^\\*)=0f(x\\*)=0。误差 ei=xi−x\\*e_i = x_i - x^\\*ei​=xi​−x\\*","date":"2025-05-14","objectID":"/posts/math/mathmatic-analysis/notes1/:0:0","series":null,"tags":["Math","Compute"],"title":"数值分析笔记一","uri":"/posts/math/mathmatic-analysis/notes1/#"},{"categories":[],"content":"第13讲：同步 (Synchronization) 本讲深入讨论多线程/多进程环境下共享资源的访问控制和协调问题，即同步。 并发执行与竞争 (Concurrent Execution and Race) 并发是指多个任务（线程或进程）在宏观上同时执行。在多处理器或支持时间片轮转的单处理器上都会发生并发。 竞争条件 (Race Condition): 当多个控制流（线程或进程）访问和修改同一个共享状态时，如果最终结果取决于这些控制流执行的精确交错顺序，那么就存在竞争条件。 示例：计数器增加 考虑一个全局变量 ‘count’，初始为 0。两个线程都执行 ‘count++’ 1000次。期望最终结果是 2000。 ‘count++’ 在硬件层面通常不是原子操作，例如可能被翻译成以下指令序列： Load R, count ; 从内存加载 count 的值到寄存器 R Add R, 1 ; 寄存器 R 中的值加一 Store R, count ; 将寄存器 R 中的值存回内存 count 如果在两个线程并发执行时发生如下交错： 线程 A: ‘Load R1, count’ (R1 = 0) 线程 B: ‘Load R2, count’ (R2 = 0) 线程 A: ‘Add R1, 1’ (R1 = 1) 线程 B: ‘Add R2, 1’ (R2 = 1) 线程 A: ‘Store R1, count’ (count = 1) 线程 B: ‘Store R2, count’ (count = 1) 尽管执行了两次 ‘count++’，最终 ‘count’ 的值却是 1，而不是期望的 2。这就是更新丢失，由竞争导致。 临界区 (Critical Section): 访问共享资源的代码段称为临界区。同步问题本质上是保证对临界区的互斥访问。 互斥 (Mutual Exclusion) 目标是保证在任何时刻，最多只有一个线程在执行临界区中的代码。 锁 (Lock / Mutex) 锁是实现互斥的最常用工具。它是一个对象，可以在进入临界区前获取，在离开临界区后释放。 acquire(lock); // 临界区 (Critical Section) // 访问或修改共享资源 release(lock); 锁的性质: 一个好的锁实现应该满足以下性质： **互斥 (Mutual Exclusion):** 任何时刻只有一个线程持有锁。 **线程可用 (Progress):** 如果没有线程在临界区内，并且有线程想进入临界区，那么在有限时间内，某个想进入临界区的线程必须能够成功获取锁并进入临界区。 **有限等待 (Bounded Waiting):** 如果一个线程请求进入临界区，那么在它被允许进入之前，其他线程进入临界区的次数是有限制的。这避免了 (Starvation)。 锁的实现方式: **禁用中断 (Disabling Interrupts):** 在单处理器上，进入临界区前禁用中断，离开后恢复。简单但粗暴，可能导致丢失重要中断，且在多处理器上无效。 **自旋锁 (Spin Lock):** 线程在 ‘acquire()’ 时，如果锁被持有，就在一个循环中不断\"自旋\"检查锁状态，直到锁可用。 acquire(lock): while (test_and_set(\u0026lock-\u003eflag)); // 原子操作，设置标志并返回原值 release(lock): lock-\u003eflag = 0; ’test_and_set’ 是一个原子硬件指令。自旋锁在多处理器且临界区非常短时有效（避免上下文切换开销），但如果临界区长，会导致大量 CPU 浪费在忙等上。 **阻塞锁 (Blocking Lock):** 线程在 ‘acquire()’ 时，如果锁被持有，则将自己放入一个等待队列并进入睡眠状态（阻塞）。当锁被 ‘release()’ 时，唤醒等待队列中的一个或所有线程。 acquire(lock): while (lock_is_held) { add_to_wait_queue(current_thread); sleep(); // 线程阻塞，让出 CPU } lock_is_held = true; release(lock): lock_is_held = false; if (wait_queue_not_empty) { wakeup(a_waiting_thread); } 阻塞锁适用于临界区较长的情况，避免 CPU 浪费，但上下文切换有开销。 信号量 (Semaphore) 信号量是一个整数变量 SSS，只能通过两个原子操作 ‘P’ (或 ‘wait’, ‘acquire’) 和 ‘V’ (或 ‘signal’, ‘release’) 来访问。 ‘P(S)’: S=S−1S = S - 1S=S−1。如果 SSS 变为负值，则执行 ‘P’ 的线程阻塞，放入信号量的等待队列。 ‘V(S)’: S=S+1S = S + 1S=S+1。如果 SSS 原本是负值（意味着有线程在等待），则唤醒等待队列中的一个线程。 信号量可以用来实现互斥和更复杂的同步。 二元信号量 (Binary Semaphore): 初始值为 1 的信号量，功能与互斥锁类似。 semaphore mutex = 1; P(mutex); // 临界区 V(mutex); 计数信号量 (Counting Semaphore): 初始值大于 1 的信号量，用于控制对具有多个相同资源的访问。初始值表示可用资源的数量。 生产者-消费者问题 (Producer-Consumer Problem): 使用有限大小的缓冲区同步生产者和消费者。 ‘mutex = 1’: 保护缓冲区本身的数据访问。 ’empty = N’: 表示缓冲区中空槽的数量 (初始为缓冲区大小 N)。 ‘full = 0’: 表示缓冲区中已填充槽的数量 (初始为 0)。 生产者代码: while (true) { item = produce_item(); // 生产物品 P(empty); // 等待空槽可用 P(mutex); // 锁定缓冲区 add_item_to_buffer(item); // 将物品放入缓冲区 V(mutex); // 解锁缓冲区 V(full); // 通知消费者，有新物品可用 } 消费者代码: while (true) { P(full); // 等待物品可用 P(mutex); // 锁定缓冲区 item = remove_item_from_buffer(); // 从缓冲区取出物品 V(mutex); // 解锁缓冲区 V(empty); // 通知生产者，有空槽可用 consume_item(item); // 消费物品 } 注意 ‘P(empty)’ 和 ‘P(full)’ 在 ‘P(mutex)’ 之前，这是为了避免可能的死锁（例如，如果先获取 mutex，但发现条件不满足需要等待 full/empty，而释放 mutex 才能让对方生产/消费，就可能死锁）。 管程 (Monitor) 管程是一种更高级的同步抽象，它将共享数据和访问这些数据的过程（函数）封装在一个模块中。管程保证在任何时刻，只有一个线程可以在管程内的某个过程中执行。 管程通常包含： 共享数据 (Shared data) 访问共享数据的过程 (Procedures/Functions) 管程锁 (Monitor Lock): 隐式地由管程机制管理，确保互斥。 条件变量 (Condition Variables): 用于线程在管程内部等待某个条件成立。 条件变量 (Condition Variable): 用于线程在持有管程锁的情况下，等待某个条件（基于共享数据）成立。有两个基本操作： ‘wait(condition_variable)’: 调用线程原子地释放管程锁并进入该条件变量对应的等待队列中睡眠。当被唤醒时，线程会重新尝试获取管程锁，成功后从 ‘wait’ 调用点返回。 ‘signal(condition_variable)’: 如果有线程在 ‘condition_variable’ 上等待，唤醒其中一个。如果没有线程等待，‘signal’ 操作无效果（与信号量的 ‘V’ 不同）。唤醒的线程会排队等待获取管程锁。 ‘wait()’ 和 ‘signal()’ 都必须在持有管程锁的情况下调用。 关于 ‘signal’ 的语义有两种常见实现：Hoare 语义（发出 signal 的线程立即将管程交给被唤醒的线程）和 Mesa 语义（发出 signal 的线程继续执行直到退出管程或再次等待，被唤醒的线程需要重新竞争管程锁）。Java 使用的是 Mesa 语义。 经典同步问题 **读者-写者问题 (Readers-Writers Problem):** 允许多个读者同时访问共享数据，但写者必须独占访问。有偏向读者和偏向写者的不同策略。 **哲学家进餐问题 (Dining Philosophers Problem):** 五个哲学家围坐，每人左右一把筷子，思考或吃饭。吃饭需要两把筷子。这是一个经典的死锁和饥饿问题示例。解决方法包括：最多允许四个哲学家同时拿左手筷子、奇数号哲学家先拿左筷子偶数号先拿右筷子、使用管程等。 第14讲：内存管理 (Memory Management) 本讲深入探讨操作系统如何管理计算机的内存资源，包括地址空间、地址翻译、以及虚拟内存等核心概念。 内存层次 (Memory Hierarchy) 现代计算机系统采用分","date":"2025-05-14","objectID":"/posts/os/13-14/:0:0","series":null,"tags":["OS"],"title":"chapter 13 14","uri":"/posts/os/13-14/#"},{"categories":null,"content":"博客每日字数和发文统计热力图","date":"2025-05-14","objectID":"/heatmap/","series":null,"tags":null,"title":"博客活动热力图","uri":"/heatmap/"},{"categories":null,"content":"这个页面展示了博客每天的发文数量和字数统计的热力图。 文章发布热力图 字数统计热力图 ","date":"2025-05-14","objectID":"/heatmap/:0:0","series":null,"tags":null,"title":"博客活动热力图","uri":"/heatmap/#"},{"categories":[],"content":"衍射现象简介 当光在传播过程中遇到障碍物或小孔时，它会偏离直线传播路径，绕到障碍物的阴影区，这种现象称为光的衍射 (Diffraction)。衍射是波动的重要特征之一。 cite:1cite: 1cite:1菲涅尔衍射与夫琅禾费衍射 根据观察屏与障碍物/小孔的距离不同，衍射现象可以分为两类： 菲涅尔衍射 (Fresnel Diffraction)：也称为近场衍射，此时光源或观察屏与障碍物/小孔的距离是有限的，入射光和衍射光都不是平行光。 cite:6cite: 6cite:6 例如，观察刀片边缘在单色点光源照射下产生的衍射条纹。 cite:2cite: 2cite:2 夫琅禾费衍射 (Fraunhofer Diffraction)：也称为远场衍射，此时光源和观察屏与障碍物/小孔的距离都可视为无限远，入射光和衍射光都可视为平行光。 cite:7cite: 7cite:7 在实验中，通常使用透镜来实现夫琅禾费衍射条件。 cite:8cite: 8cite:8 一个著名的例子是泊松亮斑 (Poisson Spot / Arago Spot)。1818年，菲涅尔基于波动理论解释衍射现象，泊松推断出在圆形障碍物阴影中心应出现一个亮点，后被阿拉果实验证实，有力支持了光的波动说。 cite:3cite: 3cite:3单缝衍射 当平行单色光垂直入射到一个宽度为 aaa 的狭缝时，会在远处的屏幕上形成一系列明暗相间的条纹，中央条纹最亮最宽，两侧条纹对称分布，宽度变窄，亮度减弱。 暗纹条件 根据惠更斯原理，狭缝上的每一点都可以看作是新的子波源。 cite:4,5cite: 4, 5cite:4,5 考虑从狭缝边缘发出的两条光线到达屏幕上某点P，如果P点为暗纹，则来自狭缝上半部分的光与来自狭缝下半部分的光在该点发生相消干涉。 第一条暗纹的位置满足： a2sin⁡θ=±λ2\\frac{a}{2} \\sin\\theta = \\pm \\frac{\\lambda}{2}2a​sinθ=±2λ​ 推广到第 mmm 级暗纹 (m=±1,±2,±3,…m = \\pm 1, \\pm 2, \\pm 3, \\dotsm=±1,±2,±3,…)： asin⁡θ=mλa \\sin\\theta = m\\lambdaasinθ=mλ 或者，对于小角度 θ\\thetaθ (以弧度为单位)： θ≈mλa\\theta \\approx \\frac{m\\lambda}{a}θ≈amλ​ 其中 λ\\lambdaλ 是光的波长。m=0m=0m=0 对应中央亮纹，不是暗纹。 cite:10,12,13,14cite: 10, 12, 13, 14cite:10,12,13,14 如果屏幕距离狭缝为 xxx，则暗纹离中心的距离 ymy_mym​ 为： ym=xtan⁡θ≈xsin⁡θ=xmλay_m = x \\tan\\theta \\approx x \\sin\\theta = x \\frac{m\\lambda}{a}ym​=xtanθ≈xsinθ=xamλ​ cite:15,16cite: 15, 16cite:15,16单缝衍射的强度分布 通过矢量叠加法 (Phasor Diagram) 分析，可以得到单缝衍射的强度 III 分布公式： cite:17,20,21,22,23,24cite: 17, 20, 21, 22, 23, 24cite:17,20,21,22,23,24 I=I0(sin⁡αα)2I = I_0 \\left( \\frac{\\sin\\alpha}{\\alpha} \\right)^2I=I0​(αsinα​)2 其中 I0I_0I0​ 是中央亮纹的最大强度，α\\alphaα 是与衍射角 θ\\thetaθ 相关的相位因子： α=β2=πasin⁡θλ\\alpha = \\frac{\\beta}{2} = \\frac{\\pi a \\sin\\theta}{\\lambda}α=2β​=λπasinθ​ β\\betaβ 是从狭缝两边缘到达屏幕某点的光的相位差： cite:25cite: 25cite:25 β=2πλasin⁡θ\\beta = \\frac{2\\pi}{\\lambda} a \\sin\\thetaβ=λ2π​asinθ 暗纹位置由 sin⁡α=0\\sin\\alpha = 0sinα=0 但 α≠0\\alpha \\neq 0α=0 给出，即 α=mπ\\alpha = m\\piα=mπ (m=±1,±2,…m = \\pm 1, \\pm 2, \\dotsm=±1,±2,…)，这与之前的暗纹条件 asin⁡θ=mλa \\sin\\theta = m\\lambdaasinθ=mλ 一致。 cite:26cite: 26cite:26 亮纹位置 (除中央亮纹外) 近似发生在 α\\alphaα 使得 dIdα=0\\frac{dI}{d\\alpha} = 0dαdI​=0 的地方，这导致方程 tan⁡α=α\\tan\\alpha = \\alphatanα=α。 cite:30cite: 30cite:30 其近似解为 α≈±1.43π,±2.46π,…\\alpha \\approx \\pm 1.43\\pi, \\pm 2.46\\pi, \\dotsα≈±1.43π,±2.46π,…。 cite:31,33cite: 31, 33cite:31,33 旁轴亮纹的强度远小于中央亮纹： 第一级旁轴亮纹 (α≈1.43π\\alpha \\approx 1.43\\piα≈1.43π) 的强度约为 I0(sin⁡(1.43π)1.43π)2≈0.0472I0I_0 \\left( \\frac{\\sin(1.43\\pi)}{1.43\\pi} \\right)^2 \\approx 0.0472 I_0I0​(1.43πsin(1.43π)​)2≈0.0472I0​ (即 4.72%I04.72\\% I_04.72%I0​)。 cite:35cite: 35cite:35 第二级旁轴亮纹 (α≈2.46π\\alpha \\approx 2.46\\piα≈2.46π) 的强度约为 I0(sin⁡(2.46π)2.46π)2≈0.0165I0I_0 \\left( \\frac{\\sin(2.46\\pi)}{2.46\\pi} \\right)^2 \\approx 0.0165 I_0I0​(2.46πsin(2.46π)​)2≈0.0165I0​ (即 1.65%I01.65\\% I_01.65%I0​)。 cite:35cite: 35cite:35 例题1 aaa 单缝衍射图样的中央强度为 I0I_0I0​。当缝两边缘发出的子波到达屏上某点的相位差为 666666 弧度时，该点的光强是多少？ cite:36cite: 36cite:36 (b) 如果此点偏离中央亮纹 7.0∘7.0^\\circ7.0∘，那么缝宽是波长的多少倍？ cite:37cite: 37cite:37解： (a) 相位差 β=66 rad\\beta = 66 \\text{ rad}β=66 rad。则 α=β/2=33 rad\\alpha = \\beta/2 = 33 \\text{ rad}α=β/2=33 rad。 cite:38cite: 38cite:38 光强 I=I0(sin⁡αα)2=I0(sin⁡(33 rad)33 rad)2≈I0(0.999533)2≈(9.2×10−4)I0I = I_0 \\left( \\frac{\\sin\\alpha}{\\alpha} \\right)^2 = I_0 \\left( \\frac{\\sin(33 \\text{ rad})}{33 \\text{ rad}} \\right)^2 \\approx I_0 \\left( \\frac{0.9995}{33} \\right)^2 \\approx (9.2 \\times 10^{-4}) I_0I=I0​(αsinα​)2=I0​(33 radsin(33 rad)​)2≈I0​(330.9995​)2≈(9.2×10−4)I0​。 cite:38cite: 38cite:38 (b) 由 β=2πasin⁡θλ\\beta = \\frac{2\\pi a \\sin\\theta}{\\lambda}β=λ2πasinθ​，可得缝宽与波长的关系： cite:38cite: 38cite:38 aλ=β2πsin⁡θ=66 rad2π rad⋅sin⁡(7.0∘)≈662π⋅0.1219≈86\\frac{a}{\\lambda} = \\frac{\\beta}{2\\pi \\sin\\theta} = \\frac{66 \\text{ rad}}{2\\pi \\text{ rad} \\cdot \\sin(7.0^\\circ)} \\approx \\frac{66}{2\\pi \\cdot 0.1219} \\approx 86λa​=2πsinθβ​=2π rad⋅sin(7.0∘)66 rad​≈2π⋅0.121966​≈86 所以，缝宽约为波长的 868686 倍。 cite:38cite: 38cite:38双缝干涉的实际情况 (考虑衍射) 在实际的双缝干涉实验中，每个狭缝都有一定的宽度 aaa，因此不仅会发生两束光之间的干涉，每个狭缝自身也会产生衍射。 cite:39,40,41cite: 39, 40, 41cite:39,40,41 最终的强度分布是双缝干涉因子和单缝衍射因子的乘积： cite:42,44,45cite: 42, 44, 45cite:42,44,45 IP=Imaxcos⁡2(ϕ2)[s","date":"2025-05-13","objectID":"/posts/physics/ch36/:0:0","series":null,"tags":["Physics"],"title":"Ch36","uri":"/posts/physics/ch36/#"},{"categories":[],"content":"光作为波 光表现出波的特性。 惠更斯原理：波前的每一点都可以看作是次级球面子波的波源。新的波前是所有这些次级子波的包络面（切面）。 这是一种可视化光传播的便捷方法。 麦克斯韦方程组是电磁波传播的基本关系。 惠更斯原理可以用来解释折射定律。 光在折射率为 nnn 的介质中的波长为 λn=λn\\lambda_n = \\frac{\\lambda}{n}λn​=nλ​，其中 λ\\lambdaλ 是在真空中的波长。 干涉 (Interference) 当两个或多个波在空间中重叠时，会发生干涉。 两束光波发生干涉的条件： 相干性：单色光（相同的频率/波长）且具有恒定的相位关系。 振幅相等。 偏振方向相同（波的振动在同一平面内）。 干涉与衍射： 两者之间没有本质的区别。都是叠加原理和惠更斯原理的结果。 干涉：通常指涉及来自少量波源（通常是两个）的波的效应。 衍射：通常涉及惠更斯子波在孔径区域的连续分布，或大量波源或孔径。 杨氏双缝干涉实验 演示了光波通过两条狭缝时的干涉现象。 相干的单色光照射两条窄缝（S1S_1S1​ 和 S2S_2S2​）。 在屏幕上观察到明暗相间的条纹（干涉图样）。 亮条纹（相长干涉）：波前同相到达。 暗条纹（相消干涉）：波前反相到达。 程差和相位差： 假设到屏幕的距离 RRR 远大于狭缝间距 ddd（R≫dR \\gg dR≫d），则光线可以视为平行。 程差：Δr=r2−r1=dsin⁡θ\\Delta r = r_2 - r_1 = d \\sin\\thetaΔr=r2​−r1​=dsinθ。 相位差：Δϕ=2πλ(dsin⁡θ)\\Delta\\phi = \\frac{2\\pi}{\\lambda} (d \\sin\\theta)Δϕ=λ2π​(dsinθ)。 条纹条件（近似几何）： 相长干涉（亮条纹）： dsin⁡θ=mλd \\sin\\theta = m\\lambdadsinθ=mλ，其中 m=0,±1,±2,…m = 0, \\pm1, \\pm2, \\dotsm=0,±1,±2,… 相位差：Δϕ=2mπ\\Delta\\phi = 2m\\piΔϕ=2mπ。 相消干涉（暗条纹）： dsin⁡θ=(m+12)λd \\sin\\theta = (m + \\frac{1}{2})\\lambdadsinθ=(m+21​)λ，其中 m=0,±1,±2,…m = 0, \\pm1, \\pm2, \\dotsm=0,±1,±2,… 相位差：Δϕ=(2m+1)π\\Delta\\phi = (2m+1)\\piΔϕ=(2m+1)π。 屏幕上条纹的位置： 对于小角度 θ\\thetaθ，sin⁡θ≈tan⁡θ≈ymR\\sin\\theta \\approx \\tan\\theta \\approx \\frac{y_m}{R}sinθ≈tanθ≈Rym​​。 亮条纹的位置：ym=Rmλdy_m = R \\frac{m\\lambda}{d}ym​=Rdmλ​。 由此可以测定光的波长：λ=ymdmR\\lambda = \\frac{y_m d}{mR}λ=mRym​d​。 例题1：计算波长 在杨氏双缝干涉实验中，双缝间距 d=0.200 mmd = 0.200 \\text{ mm}d=0.200 mm，屏幕到双缝的距离 R=1.00 mR = 1.00 \\text{ m}R=1.00 m。测得第三级亮条纹 (m=3m=3m=3) 到中心亮纹的距离为 y3=9.49 mmy_3 = 9.49 \\text{ mm}y3​=9.49 mm。求入射光的波长。 解：根据亮条纹位置公式 ym=Rmλdy_m = R \\frac{m\\lambda}{d}ym​=Rdmλ​，可得 λ=ymdmR\\lambda = \\frac{y_m d}{mR}λ=mRym​d​。 代入数据：λ=(9.49×10−3 m)(0.200×10−3 m)(3)(1.00 m)=632.67×10−9 m≈633 nm\\lambda = \\frac{(9.49 \\times 10^{-3} \\text{ m})(0.200 \\times 10^{-3} \\text{ m})}{(3)(1.00 \\text{ m})} = 632.67 \\times 10^{-9} \\text{ m} \\approx 633 \\text{ nm}λ=(3)(1.00 m)(9.49×10−3 m)(0.200×10−3 m)​=632.67×10−9 m≈633 nm。 由介质差异引起的相位差 当光在不同介质中传播时，在距离 LLL 内的波长数会发生变化。 在介质1中的波长数：N1=Lλn1=Ln1λaN_1 = \\frac{L}{\\lambda_{n1}} = \\frac{Ln_1}{\\lambda_a}N1​=λn1​L​=λa​Ln1​​。 在介质2中的波长数：N2=Lλn2=Ln2λaN_2 = \\frac{L}{\\lambda_{n2}} = \\frac{Ln_2}{\\lambda_a}N2​=λn2​L​=λa​Ln2​​。 相位差：Δϕ=2π(N2−N1)=2πLλa(n2−n1)\\Delta\\phi = 2\\pi (N_2 - N_1) = \\frac{2\\pi L}{\\lambda_a} (n_2 - n_1)Δϕ=2π(N2​−N1​)=λa​2πL​(n2​−n1​)。 这种相位差可以改变干涉条纹的位置。 例题：介质移动条纹 考虑将一块厚度为 LLL、折射率为 n2n_2n2​ 的透明介质插入杨氏双缝实验的一条光路中（原光路在空气中，折射率 n1≈1n_1 \\approx 1n1​≈1）。如果希望将原先的 m=0m=0m=0 级亮条纹移动到原先 m=1m=1m=1 级亮条纹的位置，介质的厚度 LLL 应为多少？假设空气中波长为 λa\\lambda_aλa​。 解：条纹移动一个条纹间距，相当于引入的相位差为 2π2\\pi2π (或光程差为一个波长)。 由介质引入的光程差为 L(n2−n1)L(n_2 - n_1)L(n2​−n1​)。 因此 L(n2−n1)=1⋅λaL(n_2 - n_1) = 1 \\cdot \\lambda_aL(n2​−n1​)=1⋅λa​。 L=λan2−n1L = \\frac{\\lambda_a}{n_2 - n_1}L=n2​−n1​λa​​。如果 n1=1n_1=1n1​=1 (空气)，则 L=λan2−1L = \\frac{\\lambda_a}{n_2 - 1}L=n2​−1λa​​。 例如，如果 λa=600 nm\\lambda_a = 600 \\text{ nm}λa​=600 nm，n2=1.5n_2=1.5n2​=1.5，n1=1n_1=1n1​=1，则 L=600 nm1.5−1=1200 nm=1.2μmL = \\frac{600 \\text{ nm}}{1.5-1} = 1200 \\text{ nm} = 1.2 \\mu\\text{m}L=1.5−1600 nm​=1200 nm=1.2μm。 干涉图样的强度 假设两个相干波具有相同的振幅 E0E_0E0​ 和相同的偏振方向。 强度 I∝E02I \\propto E_0^2I∝E02​。 使用相量图来计算电场的叠加： E1(t)=E0cos⁡(ωt)E_1(t) = E_0 \\cos(\\omega t)E1​(t)=E0​cos(ωt) E2(t)=E0cos⁡(ωt+ϕ)E_2(t) = E_0 \\cos(\\omega t + \\phi)E2​(t)=E0​cos(ωt+ϕ)，其中 ϕ=2πdsin⁡θλ\\phi = \\frac{2\\pi d \\sin\\theta}{\\lambda}ϕ=λ2πdsinθ​。 合成振幅：E=2E0cos⁡(12ϕ)E = 2E_0 \\cos(\\frac{1}{2}\\phi)E=2E0​cos(21​ϕ)。 合成强度：I=4I0cos⁡2(12ϕ)I = 4I_0 \\cos^2(\\frac{1}{2}\\phi)I=4I0​cos2(21​ϕ)，其中 I0I_0I0​ 是单个狭缝在该处的强度（对于窄缝，常假定处处相等）。 最大强度 Imax=4I0I_{max} = 4I_0Imax​=4I0​。 能量被重新分配，总量不变。 强度分布： 最大值（cos⁡2(12ϕ)=1\\cos^2(\\frac{1}{2}\\phi) = 1cos2(21​ϕ)=1）：ϕ=2mπ ⟹ 程差 ΔL=mλ\\phi = 2m\\pi \\implies \\text{程差 } \\Delta L = m\\lambdaϕ=2mπ⟹程差 ΔL=mλ。 最小值（cos⁡2(12ϕ)=0\\cos^2(\\frac{1}{2}\\phi) = 0cos2(21​ϕ)=0）：ϕ=(2m+1)π ⟹ 程差 ΔL=(m+12)λ\\phi = (2m+1)\\pi \\implies \\text{程差 } \\Delta L = (m+\\frac{1}{2})\\lambdaϕ=(2m+1)π⟹程差 ΔL=(m+21​)λ。 薄膜干涉 由于光在薄膜上下表面的反射而产生的干涉现象。 关键因素： 光在薄膜材料中波长的改变。 反射时的相位变化。 反射时的相位变化： 如果光从折射率较小的介质入射到折射率较大的介质界面反射（na\u003cnbn_a \u003c n_bna​\u003cnb​），则会发生 π\\piπ 弧度（半个周期）的相位跃变。 如果光从折射率较大的介质入射到折射率较小的介质界面反射（na\u003enbn_a \u003e n_bna​\u003enb​），则没有相位跃变。 肥皂膜的反射（例如，空气-薄膜-空气，n1=n","date":"2025-05-13","objectID":"/posts/physics/ch35/:0:0","series":null,"tags":["Physics"],"title":"Ch35","uri":"/posts/physics/ch35/#"},{"categories":[],"content":" AC自动机不能直接从后往前拓扑,需要拓扑排序,与SAM一样. ","date":"2021-03-01","objectID":"/posts/oi/attention/:0:0","series":null,"tags":[],"title":"注意事项","uri":"/posts/oi/attention/#"},{"categories":null,"content":"P2476-[SCOI2008]着色方案 题目: 题目描述: 有 nnn 个木块排成一行，从左到右依次编号为 111 至 nnn。 你有 kkk 种颜色的油漆，第 iii 种颜色的油漆足够涂 cic_ici​ 个木块。 所有油漆刚好足够涂满所有木块，即∑i=1kci=n\\sum_{i=1}^kc_i=n∑i=1k​ci​=n。 由于相邻两个木块涂相同色显得很难看，所以你希望统计任意两个相邻木块颜色不同的着色方案。 由于答案可能很大，请输出对 109+710^9+7109+7 取模的结果。 输入格式: 第一行，一个整数 kkk，表示颜色数量。 第二行 kkk 个整数 c1,c2,…,ckc_1, c_2, \\dots, c_kc1​,c2​,…,ck​，表示每种颜色能够涂木块的个数。 输出格式: 一行一个整数，表示答案对 109+710^9+7109+7 取模的结果。 样例: 样例输入1: 3 1 2 3 样例输出1: 10 样例输入2: 5 2 2 2 2 2 样例输出2: 39480 样例输入3: 10 1 1 2 2 3 3 4 4 5 5 样例输出3: 85937576 思路: 我们发现颜色个数最多只有5种, 且每种颜色只与它的出现次数有关, 所以就可以将他计入状态转移 实现: // Problem: P2476 [SCOI2008]着色方案 // Contest: Luogu // URL: https://www.luogu.com.cn/problem/P2476 // Memory Limit: 125 MB // Time Limit: 1000 ms // Author: Ybw051114 // // Powered by CP Editor (https://cpeditor.org) #include \"ybwhead/ios.h\" #define int long long using namespace std; const int N = 21, mod = 1e9 + 7; int f[N][N][N][N][N][6]; int dp(int a, int b, int c, int d, int e, int l) { if ((a | b | c | d | e) == 0) return 1; if (f[a][b][c][d][e][l] != 0) return f[a][b][c][d][e][l]; long long ret = 0; if (a) ret = (ret + dp(a - 1, b, c, d, e, 1) * (a - (l == 2))) % mod; if (b) ret = (ret + dp(a + 1, b - 1, c, d, e, 2) * (b - (l == 3))) % mod; if (c) ret = (ret + dp(a, b + 1, c - 1, d, e, 3) * (c - (l == 4))) % mod; if (d) ret = (ret + dp(a, b, c + 1, d - 1, e, 4) * (d - (l == 5))) % mod; if (e) ret = (ret + dp(a, b, c, d + 1, e - 1, 5) * (e)) % mod; f[a][b][c][d][e][l] = ret; return ret; } int b[6]; int getAnswer(int m, vector\u003cint\u003e a) { for (int i = 0; i \u003c m; i++) b[a[i]]++; return dp(b[1], b[2], b[3], b[4], b[5], 0); } signed main() { int m; yin \u003e\u003e m; vector\u003cint\u003e a; for (int i = 0; i \u003c m; ++i) { int x; yin \u003e\u003e x; a.push_back(x); } yout \u003c\u003c getAnswer(m, a) \u003c\u003c endl; return 0; } ","date":"2021-02-13","objectID":"/posts/oi/problems/p2476/:0:0","series":null,"tags":["dp"],"title":"P2476-[SCOI2008]着色方案","uri":"/posts/oi/problems/p2476/#"},{"categories":[],"content":"线段树分治 有的时候我们会碰到一类数据结构问题，它需要我们支持往集合中插入一个元素、删除一个元素、询问三个操作。如果我们发现，插入一个元素时信息很容易维护，但删除一个元素时就不那么容易了，那么我们可以考虑线段树分治，来离线解决这类在线算法不那么优秀的数据结构题。 线段树分治，说白了就是按照时间轴建一棵线段树。容易发现集合中每个元素存活的时间是一个区间。于是考虑对线段树上每一个节点建立一个 vector。对于每个元素在线段树上递归，如果发现该元素的存活时间区间完全覆盖了当前节点所表示的区间就直接将该元素的编号插入当前节点的 vector 中，否则就按照线段树区间查询的套路将大区间拆成左右两个小区间分别递归即可。最后一遍 dfs，递归到某个节点 xxx 的时候就将 xxx 的 vector 中的元素的贡献计算出来并分别递归左右儿子节点，如果是叶子节点就直接输出答案，回溯的时候撤销贡献即可。 伪代码大致长这样： void iterate(int k){ for(int i=0;i\u003cs[k].v.size();i++){ int x=s[k].v[i]; 计算 x 的贡献 } if(s[k].l==s[k].r) 输出答案 else iterate(k\u003c\u003c1),iterate(k\u003c\u003c1|1);//递归左右儿子 撤销贡献 } ","date":"2021-02-13","objectID":"/posts/oi/algorithm/ds/segmenttree_divide/:0:0","series":null,"tags":[],"title":"SegmentTree_Divide","uri":"/posts/oi/algorithm/ds/segmenttree_divide/#"},{"categories":null,"content":"P5610-[Ynoi2013] 大学 题目: 题目描述: 一个长为 nnn 的非负整数序列 aaa，支持以下两个操作： 1 l r x：把区间 [l,r][l, r][l,r] 中所有 xxx 的倍数除以 xxx。 2 l r：查询区间 [l,r][l, r][l,r] 的和。 本题强制在线，每次的 l,r,xl, r, xl,r,x 需要 xor 上上次答案，如果之前没有询问，则上次答案为 000。 输入格式: 第一行两个整数表示 n,mn, mn,m。 第二行 nnn 个非负整数表示 aia_iai​。 之后 mmm 行每行一个操作。 1 l r x：把区间 [l,r][l, r][l,r] 中所有 xxx 的倍数除以 xxx。 2 l r：查询区间 [l,r][l, r][l,r] 的和。 输出格式: 对于每次询问，输出一行一个整数表示答案。 样例: 样例输入1: 5 2 1 2 3 4 5 1 1 5 2 2 1 5 样例输出1: 12 思路: 实现: // Problem: P5610 [Ynoi2013] 大学 // Contest: Luogu // URL: https://www.luogu.com.cn/problem/P5610 // Memory Limit: 500 MB // Time Limit: 500 ms // Author: Ybw051114 // // Powered by CP Editor (https://cpeditor.org) #include \u003calgorithm\u003e #include \u003ccstdio\u003e #include \u003ccstring\u003e inline char getch() { static const int N = 1e6; static char buf[N], *p1 = NULL, *p2 = NULL; return (p1 == p2) \u0026\u0026 (p2 = (p1 = buf) + fread(buf, 1, N, stdin), p1 == p2) ? EOF : *p1++; } inline void putch(char c) { #define flush() fwrite(buf, 1, len, stdout), len = 0 static const int N = 1e6; static char buf[N]; static int len = 0; if (c == EOF) flush(); else buf[len++] = c; if (len == N) flush(); #undef flush } inline long long getint() { long long a = 0; char ch; do ch = getch(); while (ch \u003c '0' || ch \u003e '9'); do a = a * 10 + ch - '0', ch = getch(); while (ch \u003e= '0' \u0026\u0026 ch \u003c= '9'); return a; } inline void writeint(long long a) { static char buf[20], len = 0; if (a \u003c 0) putch('-'), a = -a; do buf[len++] = a % 10 + '0', a /= 10; while (a); while (len) putch(buf[--len]); } const int N = 1e5 + 10, M = 5e5 + 10, sqrtN = 720; int n, m, q, a[N], s[M], cnt[M], id[N * sqrtN], fa[N * sqrtN], las[M], nxt[M * 20], to[M * 20], cntt; inline void add(const int \u0026x, const int \u0026y) { if (cnt[x]) { ++cntt; to[cntt] = y; nxt[cntt] = las[x]; las[x] = cntt; } } inline int find(register int x) { while (x != fa[x]) x = fa[x] = fa[fa[x]]; return x; } long long c[N], lastans; inline void update(register int x, const int \u0026a) { for (; x \u003c= n; x += x \u0026 -x) c[x] += a; } inline long long query(register int x) { register long long a = 0; for (; x; x -= x \u0026 -x) a += c[x]; return a; } inline int lower_bound(register int l, register int r, const int \u0026x) { register int m; while (l \u003c r) { m = (l + r) \u003e\u003e 1; if (x \u003c= id[m]) r = m; else l = m + 1; } return l; } inline int upper_bound(register int l, register int r, const int \u0026x) { int m; while (l \u003c r) { m = (l + r) \u003e\u003e 1; if (x \u003c id[m]) r = m; else l = m + 1; } return l; } int main() { register int i, j, opt; register long long l, r, x; n = getint(); q = getint(); for (i = 1; i \u003c= n; ++i) { a[i] = getint(); if (m \u003c a[i]) m = a[i]; ++cnt[a[i]]; update(i, a[i]); } for (i = 2; i \u003c= m; ++i) { add(i, i); for (j = i \u003c\u003c 1; j \u003c= m; j += i) cnt[i] += cnt[j], add(j, i); } for (i = 2; i \u003c= m + 1; ++i) s[i] = s[i - 1] + cnt[i - 1] + 2, cnt[i - 1] = 0, id[s[i] - 1] = 1e9; for (i = 1; i \u003c= s[m + 1]; ++i) fa[i] = i; for (i = 1; i \u003c= n; ++i) if (a[i] \u003e 1) { for (j = las[a[i]]; j; j = nxt[j]) id[s[to[j]] + ++cnt[to[j]]] = i; } while (q--) { opt = getint(); l = getint() ^ lastans; r = getint() ^ lastans; if (opt == 1) { x = getint() ^ lastans; if (x \u003e 1) { l = find(lower_bound(s[x], s[x + 1] - 1, l)); r = find(upper_bound(s[x], s[x + 1] - 1, r)); for (i = l; i \u003c r; i = find(i + 1)) if (a[id[i]] % x) fa[i] = find(i + 1); else update(id[i], -a[id[i]] + a[id[i]] / x), a[id[i]] /= x; } } else writeint(lastans = query(r) - query(l - 1)), putch('\\n'); } putch(EOF); return 0; } ","date":"2021-02-10","objectID":"/posts/oi/problems/p5610/:0:0","series":null,"tags":["dsu","链表"],"title":"P5610-[Ynoi2013] 大学","uri":"/posts/oi/problems/p5610/#"},{"categories":null,"content":"CF1140F-Extending Set of Points 题目: 题目描述: For a given set of two-dimensional points S S S , let’s denote its extension E(S) E(S) E(S) as the result of the following algorithm: Create another set of two-dimensional points R R R , which is initially equal to S S S . Then, while there exist four numbers x1 x_1 x1​ , y1 y_1 y1​ , x2 x_2 x2​ and y2 y_2 y2​ such that (x1,y1)∈R (x_1, y_1) \\in R (x1​,y1​)∈R , (x1,y2)∈R (x_1, y_2) \\in R (x1​,y2​)∈R , (x2,y1)∈R (x_2, y_1) \\in R (x2​,y1​)∈R and (x2,y2)∉R (x_2, y_2) \\notin R (x2​,y2​)∈/R , add (x2,y2) (x_2, y_2) (x2​,y2​) to R R R . When it is impossible to find such four integers, let R R R be the result of the algorithm. Now for the problem itself. You are given a set of two-dimensional points S S S , which is initially empty. You have to process two types of queries: add some point to S S S , or remove some point from it. After each query you have to compute the size of E(S) E(S) E(S) . 输入格式: The first line contains one integer q q q ( 1≤q≤3⋅105 1 \\le q \\le 3 \\cdot 10^5 1≤q≤3⋅105 ) — the number of queries. Then q q q lines follow, each containing two integers xi x_i xi​ , yi y_i yi​ ( 1≤xi,yi≤3⋅105 1 \\le x_i, y_i \\le 3 \\cdot 10^5 1≤xi​,yi​≤3⋅105 ), denoting i i i -th query as follows: if (xi,yi)∈S (x_i, y_i) \\in S (xi​,yi​)∈S , erase it from S S S , otherwise insert (xi,yi) (x_i, y_i) (xi​,yi​) into S S S . 输出格式: Print q q q integers. i i i -th integer should be equal to the size of E(S) E(S) E(S) after processing first i i i queries. 样例: 样例输入1: 7 1 1 1 2 2 1 2 2 1 2 1 3 2 1 样例输出1: 1 2 4 4 4 6 3 思路: 我们将原来的(x,y)(x, y)(x,y)这个点转化为一条x\\to y(x代表行, y代表列)的边, 然后发现答案为每一个连通块中x的个数*y的个数 的总和. 用线段树分治维护每条边出现的时间, 并查集维护连通性 实现: // Problem: CF1140F Extending Set of Points // Contest: Luogu // URL: https://www.luogu.com.cn/problem/CF1140F // Memory Limit: 1000 MB // Time Limit: 3500 ms // Author: Ybw051114 // // Powered by CP Editor (https://cpeditor.org) #include \"ybwhead/ios.h\" map\u003cpair\u003cint, int\u003e, int\u003e ss; const int maxn = 6e5 + 10; vector\u003cpair\u003cint, int\u003e\u003e q[maxn \u003c\u003c 2]; void add(int p, int l, int r, int ll, int rr, pair\u003cint, int\u003e d) { if (l \u003e rr || r \u003c ll) return; if (ll \u003c= l \u0026\u0026 r \u003c= rr) { q[p].push_back(d); return; } int mid = l + r \u003e\u003e 1; if (ll \u003c= mid) add(p \u003c\u003c 1, l, mid, ll, rr, d); if (rr \u003e mid) add(p \u003c\u003c 1 | 1, mid + 1, r, ll, rr, d); } int top; int s[maxn]; int n; int f[maxn], xc[maxn], yc[maxn]; int find(int x) { if (x == f[x]) return x; return find(f[x]); } long long ans; void merge(int x, int y) { int sx = find(x), sy = find(y); if (sx == sy) return; ans -= 1ll * xc[sx] * yc[sx] + 1ll * xc[sy] * yc[sy]; if (xc[sx] + yc[sx] \u003e xc[sy] + yc[sy]) swap(sx, sy); s[++top] = sx; f[sx] = sy; xc[sy] += xc[sx]; yc[sy] += yc[sx]; ans += 1ll * xc[sy] * yc[sy]; } void solve(int p, int l, int r) { int tmp = top; for (auto x : q[p]) { int a = x.first, b = x.second; merge(a, b + 3e5); } if (l == r) yout \u003c\u003c ans \u003c\u003c \" \"; else { int mid = l + r \u003e\u003e 1; solve(p \u003c\u003c 1, l, mid); solve(p \u003c\u003c 1 | 1, mid + 1, r); } while (top \u003e tmp) { int x = s[top], y = f[s[top]]; ans -= 1ll * xc[y] * yc[y]; f[x] = x; xc[y] -= xc[x]; yc[y] -= yc[x]; ans += 1ll * xc[y] * yc[y] + 1ll * xc[x] * yc[x]; --top; } } int main() { yin \u003e\u003e n; for (int i = 1; i \u003c= 6e5; i++) { f[i] = i; xc[i] = (i \u003c= 3e5); yc[i] = !xc[i]; } for (int i = 1; i \u003c= n; i++) { int x, y; yin \u003e\u003e x \u003e\u003e y; pair\u003cint, int\u003e t = make_pair(x, y); if (ss[t]) { add(1, 1, n, ss[t], i - 1, t); ss[t] = 0; } else ss[t] = i; } for (auto x : ss) if (x.second != 0) add(1, 1, n, x.second, n, x.first); solve(1, 1, n); return 0; } ","date":"2021-02-10","objectID":"/posts/oi/problems/cf1140f/:0:0","series":null,"tags":["线段树分治"],"title":"CF1140F-Extending Set of Points","uri":"/posts/oi/problems/cf1140f/#"},{"categories":null,"content":"P5787-二分图 /【模板】线段树分治 题目: 题目描述: 神犇有一个 nnn 个节点的图。 因为神犇是神犇，所以在 kkk 时间内有 mmm 条边会出现后消失。 神犇要求出每一时间段内这个图是否是二分图。 这么简单的问题神犇当然会做了，于是他想考考你。 原 BZOJ4025。 输入格式: 第一行三个整数 n,m,kn, m, kn,m,k。 接下来 mmm 行，每行四个整数 x,y,l,rx, y, l, rx,y,l,r，表示有一条连接 x,yx, yx,y 的边在 lll 时刻出现 rrr 时刻消失。 输出格式: kkk 行，第 iii 行一个字符串 Yes 或 No ，表示在第 iii 时间段内这个图是否是二分图。 样例: 样例输入1: 3 3 3 1 2 0 2 2 3 0 3 1 3 1 2 样例输出1: Yes No Yes 思路: 首先我们知道可以用扩展域并查集维护一个图是否为二分图, 于是我们用线段树分治维护每条边出现的时间即可 实现: // Problem: P5787 二分图 /【模板】线段树分治 // Contest: Luogu // URL: https://www.luogu.com.cn/problem/P5787 // Memory Limit: 256 MB // Time Limit: 1000 ms // Author: Ybw051114 // // Powered by CP Editor (https://cpeditor.org) #include \"ybwhead/ios.h\" const int maxn = 1e6 + 10; struct node { int a, b; }; vector\u003cnode\u003e q[maxn]; void add(int p, int l, int r, int ll, int rr, node d) { if (l \u003e rr || r \u003c ll) return; if (ll \u003c= l \u0026\u0026 r \u003c= rr) { q[p].push_back(d); return; } int mid = l + r \u003e\u003e 1; if (ll \u003c= mid) add(p \u003c\u003c 1, l, mid, ll, rr, d); if (rr \u003e mid) add(p \u003c\u003c 1 | 1, mid + 1, r, ll, rr, d); } int n, m, k; int top, s1[maxn], s2[maxn]; int f[maxn], siz[maxn]; int find(int x) { if (f[x] == x) return x; return find(f[x]); } void merge(int x, int y) { x = find(x), y = find(y); if (x == y) return; if (siz[x] \u003e siz[y]) { swap(x, y); } s1[++top] = x; s2[top] = y; f[x] = y; siz[y] += siz[x]; return; } void solve(int p, int l, int r) { bool flg = 1; int tmp = top; for (auto x : q[p]) { int a = find(x.a); int b = find(x.b); // yout \u003c\u003c a \u003c\u003c \" \" \u003c\u003c b \u003c\u003c endl; if (a == b) { for (int k = l; k \u003c= r; k++) puts(\"No\"); flg = 0; break; } merge(x.a, x.b + n); merge(x.a + n, x.b); } if (flg) { if (l == r) { puts(\"Yes\"); } else { int mid = l + r \u003e\u003e 1; solve(p \u003c\u003c 1, l, mid); solve(p \u003c\u003c 1 | 1, mid + 1, r); } } while (top \u003e tmp) { siz[s2[top]] -= siz[s1[top]]; f[s1[top]] = s1[top]; top--; } return; } int main() { yin \u003e\u003e n \u003e\u003e m \u003e\u003e k; for (int i = 1; i \u003c= m; i++) { int l, r, a, b; yin \u003e\u003e a \u003e\u003e b \u003e\u003e l \u003e\u003e r; ++l; // ++r; node v = (node){a, b}; add(1, 1, k, l, r, v); } for (int i = 1; i \u003c= 2 * n; i++) f[i] = i, siz[i] = 1; solve(1, 1, k); return 0; } ","date":"2021-02-10","objectID":"/posts/oi/problems/p5787/:0:0","series":null,"tags":["线段树分治","扩展域并查集"],"title":"P5787-二分图 /【模板】线段树分治","uri":"/posts/oi/problems/p5787/#"},{"categories":null,"content":"P4396-[AHOI2013]作业 题目: 题目描述: 此时己是凌晨两点，刚刚做了 Codeforces 的小 A 掏出了英语试卷。英语作业其实不算多，一个小时刚好可以做完。然后是一个小时可以做完的数学作业，接下来是分别都是一个小时可以做完的化学，物理，语文……小 A 压力巨大。 这时小 A 碰见了一道非常恶心的数学题，给定了一个长度为 nnn 的数列和若干个询问，每个询问是关于数列的区间表示数列的第 lll 个数到第 rrr 个数)，首先你要统计该区间内大于等于 aaa，小于等于 bbb 的数的个数，其次是所有大于等于 aaa，小于等于 bbb 的，且在该区间中出现过的数值的个数。 小 A 望着那数万的数据规模几乎绝望，只能向大神您求救，请您帮帮他吧。 输入格式: 第一行两个整数 n,mn, mn,m 接下来 nnn 个不超过 10510^5105 的正整数表示数列 接下来 mmm 行，每行四个整数 l,r,a,bl, r, a, bl,r,a,b，具体含义参见题意。 输出格式: 输出 mmm 行，分别对应每个询问，输出两个数，分别为在 lll 到 rrr 这段区间中大小在 [a,b][a, b][a,b] 中的数的个数，以及大于等于 aaa，小于等于 bbb 的，且在该区间中出现过的数值的个数（具体可以参考样例）。 样例: 样例输入1: 3 4 1 2 2 1 2 1 3 1 2 1 1 1 3 1 3 2 3 2 3 样例输出1: 2 2 1 1 3 2 2 1 思路: 建立一棵权值线段树, 在权值线段树上进行分治, 于是问题就转化为统计区间内l→rl\\to rl→r的数和不同的数, 两问均可以使用树状数组实现. 实现: // Problem: P4396 [AHOI2013]作业 // Contest: Luogu // URL: https://www.luogu.com.cn/problem/P4396 // Memory Limit: 125 MB // Time Limit: 1000 ms // Author: Ybw051114 // // Powered by CP Editor (https://cpeditor.org) #include \"ybwhead/ios.h\" int n, m; const int maxm = 1e5 + 10; const int maxn = 1e5 + 10; struct node { int l, r, a, b, id; } q[maxm]; int ans[maxm], ans2[maxm]; struct tree { int d[maxn]; #define lowbit(x) x \u0026 -x void add(int p, int c) { for (; p \u003c= n; p += lowbit(p)) d[p] += c; } int q(int p) { int ans = 0; for (; p; p -= lowbit(p)) ans += d[p]; return ans; } } c1, c2; int rt, cnt; struct nd2 { int ls, rs; vector\u003cnode\u003e qu; vector\u003cpair\u003cint, int\u003e\u003e c; } c[maxn \u003c\u003c 1]; void build(int \u0026p, int l, int r) { if (!p) p = ++cnt; if (l == r) return; if (!c[p].ls) c[p].ls = ++cnt; if (!c[p].rs) c[p].rs = ++cnt; int mid = l + r \u003e\u003e 1; for (auto x : c[p].c) if (x.second \u003c= mid) c[c[p].ls].c.push_back(x); else c[c[p].rs].c.push_back(x); build(c[p].ls, l, mid); build(c[p].rs, mid + 1, r); } void add(int \u0026p, node t, int l, int r) { // cerr \u003c\u003c p \u003c\u003c \" \" \u003c\u003c c[p].l \u003c\u003c \" \" \u003c\u003c c[p].r \u003c\u003c \" \" \u003c\u003c t.a \u003c\u003c ' ' \u003c\u003c t.b \u003c\u003c endl; if (t.a \u003c= l \u0026\u0026 r \u003c= t.b) { c[p].qu.push_back(t); return; } int mid = l + r \u003e\u003e 1; if (t.a \u003c= mid) { add(c[p].ls, t, l, mid); } if (t.b \u003e mid) add(c[p].rs, t, mid + 1, r); } int cmp(node a, node b) { return a.r \u003c b.r; } int e[maxn]; int lst[maxn]; int main() { yin \u003e\u003e n \u003e\u003e m; int mx = 0; for (int i = 1; i \u003c= n; i++) { int x; yin \u003e\u003e x; c[1].c.push_back(make_pair(i, x)), mx = max(mx, x); } build(rt, 1, n); for (int i = 1; i \u003c= m; i++) { int l, r, a, b; yin \u003e\u003e l \u003e\u003e r \u003e\u003e a \u003e\u003e b; node tmp = (node){l, r, a, b, i}; add(rt, tmp, 1, n); } // cerr \u003c\u003c \"!!!\" \u003c\u003c endl; for (int i = 1; i \u003c= cnt; i++) { if (c[i].qu.empty() || c[i].c.empty()) continue; sort(c[i].qu.begin(), c[i].qu.end(), cmp); int j = 1, k = 0; while (k \u003c c[i].qu.size() \u0026\u0026 c[i].qu[k].r \u003c c[i].c[0].first) ++k; for (auto x : c[i].c) { if (lst[x.second]) c1.add(lst[x.second], -1); lst[x.second] = j; c1.add(j, 1); c2.add(j, 1); // cerr \u003c\u003c j \u003c\u003c endl; while (k \u003c c[i].qu.size() \u0026\u0026 (j == c[i].c.size() || c[i].qu[k].r \u003c c[i].c[j].first)) { int l = lower_bound(c[i].c.begin(), c[i].c.end(), make_pair(c[i].qu[k].l, 0)) - c[i].c.begin() + 1; // yout \u003c\u003c l \u003c\u003c endl; ans[c[i].qu[k].id] += c2.q(j) - c2.q(l - 1); ans2[c[i].qu[k].id] += c1.q(j) - c1.q(l - 1); ++k; } ++j; } j = 1; for (auto x : c[i].c) { if (lst[x.second]) c1.add(lst[x.second], -1); lst[x.second] = 0; c2.add(j, -1); ++j; } } for (int i = 1; i \u003c= m; i++) { yout \u003c\u003c ans[i] \u003c\u003c \" \" \u003c\u003c ans2[i] \u003c\u003c endl; } return 0; } ","date":"2021-02-10","objectID":"/posts/oi/problems/p4396/:0:0","series":null,"tags":["线段树分治","树状数组"],"title":"P4396-[AHOI2013]作业","uri":"/posts/oi/problems/p4396/#"},{"categories":null,"content":"P2470-[SCOI2007]压缩 题目: 题目描述: 给一个由小写字母组成的字符串，我们可以用一种简单的方法来压缩其中的重复信息。压缩后的字符串除了小写字母外还可以（但不必）包含大写字母R与M，其中M标记重复串的开始，R重复从上一个M（如果当前位置左边没有M，则从串的开始算起）开始的解压结果（称为缓冲串）。 bcdcdcdcd可以压缩为bMcdRR，下面是解压缩的过程： 已经解压的部分 解压结果 缓冲串 b b b bM b . bMc bc c bMcd bcd cd bMcdR bcdcd cdcd bMcdRR bcdcdcdcd cdcdcdcd 输入格式: 输入仅一行，包含待压缩字符串，仅包含小写字母，长度为n。 输出格式: 输出仅一行，即压缩后字符串的最短长度。 样例: 样例输入1: aaaaaaa 样例输出1: 5 样例输入2: bcdcdcdcdxcdcdcdcd 样例输出2: 12 思路: 首先我们有一个很直接的区间dp的思想: 记fl,rf_{l, r}fl,r​表示将l→rl\\to rl→r合并的最短长度, 然后枚举k转移, 但这显然是不对的比如 xababxabab 会压缩为 Mx(MabR)R 但必须和最右边的 R 匹配. 所以我们尝试多记一维0/10/10/1表示这个区间除了开头有没有其他的MMM, 再进行转移即可 实现: // Problem: P2470 [SCOI2007]压缩 // Contest: Luogu // URL: https://www.luogu.com.cn/problem/P2470 // Memory Limit: 125 MB // Time Limit: 1000 ms // Author: Ybw051114 // // Powered by CP Editor (https://cpeditor.org) #include \"ybwhead/ios.h\" int n; string s; const int maxn = 1010; int opt[maxn][maxn][2]; int dfs(int l, int r, int d) { if (opt[l][r][d] != 0x3f3f3f3f) return opt[l][r][d]; if (l == r) return 2; int \u0026ans = opt[l][r][d]; if (d) { ans = r - l + 2; bool flg = 1; int mid = l + r \u003e\u003e 1; if (!(r - l \u0026 1)) flg = 0; for (int i = l; i \u003c= mid; i++) if (s[i - 1] != s[i - l + mid]) flg = 0; if (flg) ans = min(ans, dfs(l, mid, 1) + 1); for (int i = l; i \u003c r; i++) { ans = min(ans, dfs(l, i, 1) + r - i); } } else { for (int i = l; i \u003c r; i++) { int dx = dfs(l, i, 0), dy = dfs(i + 1, r, 0); if (i \u003e l) dx = min(dx, dfs(l, i, 1)); if (i + 1 \u003c r) dy = min(dy, dfs(i + 1, r, 1)); ans = min(ans, dx + dy); } } return ans; } int main() { yin \u003e\u003e s; n = s.size(); memset(opt, 0x3f3f3f3f, sizeof(opt)); yout \u003c\u003c min(dfs(1, n, 0), dfs(1, n, 1)) - 1 \u003c\u003c endl; return 0; } ","date":"2021-02-09","objectID":"/posts/oi/problems/p2470/:0:0","series":null,"tags":["dp","区间dp"],"title":"P2470-[SCOI2007]压缩","uri":"/posts/oi/problems/p2470/#"},{"categories":null,"content":"P2518-[HAOI2010]计数 题目: 题目描述: 你有一组非零数字（不一定唯一），你可以在其中插入任意个0，这样就可以产生无限个数。比如说给定{1, 2}, 那么可以生成数字12, 21, 102, 120, 201, 210, 1002, 1020, 等等。 现在给定一个数，问在这个数之前有多少个数。（注意这个数不会有前导0）. 输入格式: 只有1行，为1个整数n. 输出格式: 只有整数，表示N之前出现的数的个数。 样例: 样例输入1: 1020 样例输出1: 7 思路: 我们发现a_1个1, a_2个2, a_3个3\\cdots的可重集排列的答案: 记m为数的总数, n为数的总类. (ma1)+(m−a1a2)+(m−a1−a2a3)+⋯\\tbinom{m}{a_1}+\\tbinom{m-a_1}{a_2}+\\tbinom{m-a_1-a_2}{a_3}+\\cdots(a1​m​)+(a2​m−a1​​)+(a3​m−a1​−a2​​)+⋯ 实现: // Problem: P2518 [HAOI2010]计数 // Contest: Luogu // URL: https://www.luogu.com.cn/problem/P2518 // Memory Limit: 125 MB // Time Limit: 1000 ms // Author: Ybw051114 // // Powered by CP Editor (https://cpeditor.org) #include \"ybwhead/ios.h\" const int maxn = 101; int a[maxn]; long long c[maxn][maxn]; long long calc(int nw) { long long ans = 1; for (int i = 0; i \u003c= 9; i++) { ans *= c[nw][a[i]]; nw -= a[i]; } // yout \u003c\u003c ans \u003c\u003c endl; return ans; } int main() { string s; yin \u003e\u003e s; int n = s.size(); c[0][0] = 1; for (int i = 1; i \u003c= n; i++) { c[i][0] = c[i][i] = 1; for (int j = 1; j \u003c i; j++) { c[i][j] = c[i - 1][j] + c[i - 1][j - 1]; } } for (int i = 0; i \u003c s.size(); i++) a[s[i] - '0']++; long long ans = 0; for (int i = 0; i \u003c n; i++) { for (int j = 0; j \u003c s[i] - '0'; j++) { a[j]--; ans += calc(n - i - 1); a[j]++; } a[s[i] - '0']--; } yout \u003c\u003c ans \u003c\u003c endl; return 0; } ","date":"2021-02-09","objectID":"/posts/oi/problems/p2518/:0:0","series":null,"tags":["dp","数位dp","Notebooks/OI/OJ/Luogu"],"title":"P2518-[HAOI2010]计数","uri":"/posts/oi/problems/p2518/#"},{"categories":null,"content":"P4046-[JSOI2010]快递服务 题目: 题目描述: 「飞奔」快递公司成立之后，已经分别与市内许多中小企业公司签订邮件收送服务契约。由于有些公司是在同一栋大楼内，所以「飞奔」公司收件的地点（收件点）最多只有m点 (1, 2, …, m)，因此「飞奔」仅先行采购了三辆货車并聘用了三名司机，每天早上分别从收件地点 「1」, 「2」 及 「3」出发。而在与客户的服务契约中有明确订约：「飞奔」必须在客户提出邮件寄送要求的隔天派人至该公司（地点）收件。 为了能更有效率的服务客户并节省收件时间，该公司设立了收件服务登记网站，客户如有邮件需要寄送，必须在需要收件的前一天就先上网登记。为了节省油量，「飞奔」就利用晚上先行安排三位司机隔天的收件路线。每位司机至各地点收件的顺序应与各公司上网登记的顺序相符且必须能在最省油的情况下完成当天所有的收件服务。因此每位司机有可能需要在不同时间重复到同一地点收件，或不同的司机有可能需在不同的时间点前往同一地点收件。 如下面范例二(收件公司地点依序为： 4 2 4 1 5 4 3 2 1)所示，虽然司机1一开始就已经在收件地点「1」了，但是他却不能先把后面第四个登记的公司（地点「1」）邮件先收了再前往第一、第二、或第三个登记收件地点（地点「4」, 「2」, 「4」）收件。但是如果前三个登记收件的服务是由司机2或3來负责，则司机1就可以在地点「1」收了第四个登记的邮件后再前往后面所登记的地点收件。此外，在某些情况下，不一定每辆车都要收到货，也就是說，最佳收件方式也有可能是只需出动一或兩辆车去收货。请写一个程序來帮「飞奔」公司计算每天依预约顺序至各收件地点收件的最少总耗油量。 输入格式: 输入文件第一行有一个整数 m（3≤m≤2003 \\leq m \\leq 2003≤m≤200），代表「飞奔」公司收件的地点数，以1至m之间的整数代号來表示每个地点。 接下來的m行（第2到第m+1行），每行有m个整数，代表一个矩阵D。第 i +行的第 j 个整数是D(i, j)，D(i, j) 代表司机开车从收件点 i 到收件点 j 所需耗油量。最后有一行数串，数串之数字依序为前一天上网登记要求收件的公司地点代号，最多会有1000个收件请求。输入文件中任兩个相邻的整数都以一个空白隔开。 注意：油量矩阵D满足三角不等式，也就是说 D(i, j) \\leq D(i, k) + D(k, j)，1 \\leq i, j, k \\leq m。因此，每辆车前往下一个收件地点时一定是直接前往，不必先绕道至其它地点再抵达下个收件地点。 输出格式: 输出一个整数，代表收件所需最少总耗油量。 样例: 样例输入1: 4 0 5 0 6 6 0 5 6 1 6 0 6 1 1 1 0 1 1 1 1 4 4 2 2 2 3 样例输出1: 6 思路: 记fi,j,kf_{i, j, k}fi,j,k​表示签收完前iii个后另外两辆车的位置即可转移. 实现: // Problem: P4046 [JSOI2010]快递服务 // Contest: Luogu // URL: https://www.luogu.com.cn/problem/P4046 // Memory Limit: 125 MB // Time Limit: 1000 ms // Author: Ybw051114 // // Powered by CP Editor (https://cpeditor.org) #include \"ybwhead/ios.h\" const int maxn = 1010, maxm = 210; int d[maxm][maxm], f[2][maxm][maxm]; int n, m, a[maxn]; int main() { yin \u003e\u003e m; for (int i = 1; i \u003c= m; i++) for (int j = 1; j \u003c= m; j++) yin \u003e\u003e d[i][j]; a[++n] = 1; a[++n] = 2; a[++n] = 3; while (yin \u003e\u003e a[++n]) ; --n; // cerr \u003c\u003c \"!!!\" \u003c\u003c endl; memset(f, 0x3f3f3f3f, sizeof(f)); f[1][2][1] = 0; for (int i = 3; i \u003c n; i++) { int tt = !(i \u0026 1), nw = i \u0026 1; memset(f[tt], 0x3f3f3f3f, sizeof(f[tt])); for (int j = 1; j \u003c= m; j++) { for (int k = 1; k \u003c= m; k++) { // cerr \u003c\u003c m \u003c\u003c endl; f[tt][j][k] = min(f[tt][j][k], f[nw][j][k] + d[a[i]][a[i + 1]]); f[tt][a[i]][k] = min(f[tt][a[i]][k], f[nw][j][k] + d[j][a[i + 1]]); f[tt][a[i]][j] = min(f[tt][a[i]][j], f[nw][j][k] + d[k][a[i + 1]]); } } // cerr \u003c\u003c \"!!!\" \u003c\u003c endl; } // cerr \u003c\u003c \"!!!\" \u003c\u003c endl; int ans = INT_MAX; for (int i = 1; i \u003c= m; i++) for (int j = 1; j \u003c= m; j++) ans = min(ans, f[n \u0026 1][i][j]); yout \u003c\u003c ans \u003c\u003c endl; return 0; } ","date":"2021-02-09","objectID":"/posts/oi/problems/p4046/:0:0","series":null,"tags":["动态规划, 动规, dp",2010,"各省省选","江苏","枚举, 暴力","Notebooks/OI/OJ/Luogu"],"title":"P4046-[JSOI2010]快递服务","uri":"/posts/oi/problems/p4046/#"},{"categories":[],"content":"CF1480 题解 A easy problem B 考虑英雄被击杀的次数时固定的, 只有最后一次击杀不算, 所以把那次击杀放在最后 C 考虑二分, 如果 a[mid]\u003ea[mid+1] 则在mid→rmid\\to rmid→r中间必有一个点 否则在l→midl\\to midl→mid中间必有一个点 D1 很容易看出一个O(n2)\\mathcal O(n^2)O(n2)的dp 计fjf_{j}fj​表示现在两个颜色分别为 a[i] 和 j 的最长长度, 然后就可以转移了 这时我们又可以发现一个性质既如果fi\u003efjf_i\u003ef_jfi​\u003efj​则fjf_jfj​一定无用 然后就可以用set转移了 D2 只需将D1的取最大改为取最小即可 E 首先一定有解 如果l=1,r=2kl=1,r=2^kl=1,r=2k的话则构造k+2k+2k+2个点首先数归即可得到由k+1k+1k+1个点的图,然后k+1k+1k+1向k+2k+2k+2连一条为1的边,1向k+2k+2k+2连一条为1的边,i∈2,k+1i\\in {2,k+1}i∈2,k+1向k+3连一条2k−12^{k-1}2k−1的边 如果l≠1l\\neq 1l=1则做一遍(1,r−l+1)(1,r-l+1)(1,r−l+1)终止节点向终止节点+1连一条为l−1l-1l−1 的边 如果r≠2kr\\neq 2^kr=2k则记r−1=∑i=0kRi×2ir−1=\\sum_{i=0}^kR_i\\times2^ir−1=∑i=0k​Ri​×2i为r-1的二进制展开Ri∈{0,1}R_i\\in \\{0, 1\\}Ri​∈{0,1}先做一遍(1, 2^k)新建一个点k+3k+3k+3, 1向k+3k+3k+3连一条为1的边, 接着对于0≤i≤k0\\leq i\\leq k0≤i≤k的每一个i, 如果Ri=1R_i=1Ri​=1i+2向 k+3连一条 1+∑j=i+1kRj×2j1+\\sum^k_{j=i+1}R_j\\times2^j1+∑j=i+1k​Rj​×2j的边 比赛记录 一开场两分钟秒了A, B想了一个假算法, Wa了两次, 才意识到错误, 然后一直没有头绪, 突然想出了算法, 因为没有考虑边界情况Wa了3发, 然后rk升到了14 然后无意中看到uoj群中的讨论, 会了C写了一发过了, rk升到了8(结果fst了)然后E一直想不出来一步. 看来水平还是又提升的空间 ","date":"2021-02-09","objectID":"/posts/oi/contests/cf1480/:0:0","series":null,"tags":[],"title":"CF1480","uri":"/posts/oi/contests/cf1480/#"},{"categories":[],"content":"算法介绍 启发式合并，顾名思义，就是根据人类直观的感受对已有算法的优化。譬如冰茶姬的启发式就是对于两个大小不一样的集合，我们大小小的并到大的，这样就可以有效地将冰茶姬的深度控制在 log⁡n\\log nlogn 级别（或许这就是树上启发式合并中那个\"dsu\"的来历吧）。 树上启发式合并的思想也与之类似。树上启发式合并，俗称 dsu on tree，是一种解决子树问题的离线算法，不允许修改。它能在 O(nTlog⁡n)\\mathcal O(nT\\log n)O(nTlogn) 的复杂度内离线维护某个子树内的信息，其中 TTT 是加入一个节点的复杂度，一般为 O(1)\\mathcal O(1)O(1) 或 O(log⁡n)\\mathcal O(\\log n)O(logn)。 那么树上启发式合并究竟该怎样应用呢？先考虑一个问题：一棵树上每个节点有一个颜色，求每个点的子树中所有节点中不同颜色的个数。 考虑一个最暴力的做法，从根开始 dfs，再维护一个桶 cxc_xcx​ 表示颜色 xxx 出现的次数。在 dfs 某个节点 uuu 的过程中，先 dfs 它的所有儿子 vvv 求出其儿子的答案，每次 dfs 完之后清空桶。然后将 uuu 子树内所有点都加入桶中统计答案。 这样显然是错误的，一条链就可以把它卡成 n2n^2n2。但我们注意到 dfs 完某个节点 uuu 后，有且只有 uuu 的子树中的节点被加入桶中。回忆当年学树链剖分的时候对重儿子的定义，考虑以此入手对我们的算法进行一个小小的优化： dfs uuu 的所有轻儿子 vvv，统计 vvv 的答案，并清空桶。 dfs uuu 的重儿子 sonuson_usonu​，不清空桶。显然此时有且只有 sonuson_usonu​ 子树中的点被加入了桶中。 dfs 一遍 uuu 的轻儿子 vvv，将 vvv 的子树内的节点加入桶中。 计算出 uuu 的答案。 为什么这样复杂度就对了呢？考虑每个点会被 dfs 多少次。对于每个点到根节点的路径，每出现一条轻边就会导致该点被多 dfs 一次，故一个节点 dfs 的次数与其到根节点的路径上轻边的个数同阶。而在学树链剖分我们知道一个点到根节点的路径上的重链个数是 log⁡n\\log nlogn 级别的，故个点到根节点的路径上轻边的个数也是 log⁡n\\log nlogn 级别的，复杂度 nlog⁡nn\\log nnlogn。 最后解释一下为什么它被称作\"启发式合并\"。对于每个点 uuu，设其子树的集合为 T1,T2,T3,…,TkT_1, T_2, T_3, \\dots, T_kT1​,T2​,T3​,…,Tk​，那么 dsu on tree 的本质实际上是将 T1,T2,…,TkT_1, T_2, \\dots, T_kT1​,T2​,…,Tk​ 的信息合并起来，而借鉴启发式合并的思想，我们选出 ∣Ti∣|T_i|∣Ti​∣ 的 iii，并将其它集合的信息都合并到 TiT_iTi​ 中。所以说树上启发式合并本质上是用 dsu 启发式合并的思想解决多集合的合并问题。 最后给出伪代码： void calcans(int x,int f){//计算答案 for(int e=hd[x];e;e=nxt[e]){ int y=to[e];if(y==f||y==wson[x]) continue; calcans(y,x);消除y的贡献 } if(wson[x]) calcans(wson[x],x);//dfs重儿子 把x的贡献合并进去 for(int e=hd[x];e;e=nxt[e]){ int y=to[e];if(y==f||y==wson[x]) continue; 把y的子树内所有节点的贡献合并进去 } 记录答案 } 例题 CF600E @import “../../problems/CF600E.md” {line_begin=69 line_end=72} @import “../../problems/CF600E.md” {line_begin=74 } ","date":"2021-02-09","objectID":"/posts/oi/algorithm/ds/dsu_on_tree/:0:0","series":null,"tags":[],"title":"dsu_on_tree","uri":"/posts/oi/algorithm/ds/dsu_on_tree/#"},{"categories":[],"content":"大家好，从今天开始，我将开始刷网络流的题。这是一份对于每道题的解题报告。 O. 约定 SSS：源点 S\\mathbb{S}S：源点集合（在网络流跑完后与SSS连通的点集） TTT：汇点 T\\mathbb{T}T：源点集合（在网络流跑完后与TTT连通的点集） (p,q)(p, q)(p,q)：一条从ppp到qqq的有向边（包括反边） (x,y,z)(x, y, z)(x,y,z)：一条从xxx到yyy，边权为zzz的边（包括反边） (u,v,w,c)(u, v, w, c)(u,v,w,c)：一条从uuu到vvv，边权为www，单位流量费用为ccc的边（包括反边） (i,j,[k,l])(i, j, [k, l])(i,j,[k,l])：一条从iii到jjj，边权限制为闭区间[k,l][k, l][k,l]的边。 (a,b,[c,d],e)(a, b, [c, d], e)(a,b,[c,d],e)，一条从aaa到bbb，限制为[c,d][c, d][c,d]，费用为eee的边。 flowflowflow：最大流 cutcutcut：最小割（两者虽然值相同，意义却不同） costcostcost：最小/大费用 Let’s GO!!!\\color{Thistle}\\colorbox{CadetBlue}{Let's GO!!!}Let’s GO!!!​ I.最小路径覆盖问题 刚好是第200道AC的紫黑题~~~ 一眼看去不会做。但是题目好心地已经把解法写上去了。很明显，就算看了解法，我还是不理解。看了题解，就明白了。 首先，我们可以初始成每条路径只包括单一节点。然后，我们每次尝试合并两条路径。 每个节点只能有一条出边，一条入边。如果我们将每个点拆成一个入点和一个出点（即题面上的xix_ixi​和yiy_iyi​），那么： 入点只能连向出点 每个入点只能连向一个出点 每个出点只能被一个入点连 想到了什么？ 二分图匹配！ 当然，作为网络流的24题，当然要用网络流水它了 代码： #include\u003cbits/stdc++.h\u003e using namespace std; int n,m,head[350],cnt,S,T,dis[350],cur[350],res,to[350]; bool ok[350]; struct node{ int to,next,val; }edge[30100]; void ae(int u,int v,int w){ edge[cnt].next=head[u],edge[cnt].to=v,edge[cnt].val=w,head[u]=cnt++; } queue\u003cint\u003eq; bool bfs(){ memset(dis,0,sizeof(dis)),dis[S]=1,q.push(S); while(!q.empty()){ int x=q.front();q.pop(); for(int i=cur[x]=head[x];i!=-1;i=edge[i].next)if(edge[i].val\u0026\u0026!dis[edge[i].to])dis[edge[i].to]=dis[x]+1,q.push(edge[i].to); } return dis[T]!=0; } bool reach; int dfs(int x,int flow){ if(x==T){ reach=true; res+=flow; return flow; } int used=0; for(int \u0026i=cur[x];i!=-1;i=edge[i].next){ if(!edge[i].val||dis[edge[i].to]!=dis[x]+1)continue; int ff=dfs(edge[i].to,min(edge[i].val,flow-used)); if(ff){ edge[i].val-=ff; edge[i^1].val+=ff; used+=ff; if(used==flow)break; } } return used; } int main(){ scanf(\"%d%d\",\u0026n,\u0026m),memset(head,-1,sizeof(head)),S=2*n+1,T=2*n+2; for(int i=1;i\u003c=n;i++)ae(S,i,1),ae(i,S,0),ae(i+n,T,1),ae(T,i+n,0); for(int i=1,x,y;i\u003c=m;i++)scanf(\"%d%d\",\u0026x,\u0026y),ae(x,y+n,1),ae(y+n,x,0); while(bfs()){ reach=true; while(reach)reach=false,dfs(S,0x3f3f3f3f); } for(int i=1;i\u003c=n;i++)for(int j=head[i];j!=-1;j=edge[j].next)if(!edge[j].val\u0026\u0026edge[j].to\u003en\u0026\u0026edge[j].to\u003c=2*n)to[i]=edge[j].to-n,ok[edge[j].to-n]=true; for(int i=1;i\u003c=n;i++){ if(ok[i])continue; int j=i; while(j)printf(\"%d \",j),j=to[j];puts(\"\"); } printf(\"%d\\n\",n-res); return 0; } II.魔术球问题 一开始没有思路，就仿照上一题，枚举每一对球，如果它们编号和为完全平方数就连边。然后就是前一道题的路径覆盖了。 我们枚举一个nnn，表示放多少个球。之后就用前面的算法暴力验证。 代码： #include\u003cbits/stdc++.h\u003e using namespace std; int n,m,head[350],cnt,S,T,dis[350],cur[350],res,to[350]; bool ok[350]; struct node{ int to,next,val; }edge[30100]; void ae(int u,int v,int w){ edge[cnt].next=head[u],edge[cnt].to=v,edge[cnt].val=w,head[u]=cnt++; } queue\u003cint\u003eq; bool bfs(){ memset(dis,0,sizeof(dis)),dis[S]=1,q.push(S); while(!q.empty()){ int x=q.front();q.pop(); for(int i=cur[x]=head[x];i!=-1;i=edge[i].next)if(edge[i].val\u0026\u0026!dis[edge[i].to])dis[edge[i].to]=dis[x]+1,q.push(edge[i].to); } return dis[T]!=0; } bool reach; int dfs(int x,int flow){ if(x==T){ reach=true; res+=flow; return flow; } int used=0; for(int \u0026i=cur[x];i!=-1;i=edge[i].next){ if(!edge[i].val||dis[edge[i].to]!=dis[x]+1)continue; int ff=dfs(edge[i].to,min(edge[i].val,flow-used)); if(ff){ edge[i].val-=ff; edge[i^1].val+=ff; used+=ff; if(used==flow)break; } } return used; } int main(){ scanf(\"%d%d\",\u0026n,\u0026m),memset(head,-1,sizeof(head)),S=2*n+1,T=2*n+2; for(int i=1;i\u003c=n;i++)ae(S,i,1),ae(i,S,0),ae(i+n,T,1),ae(T,i+n,0); for(int i=1,x,y;i\u003c=m;i++)scanf(\"%d%d\",\u0026x,\u0026y),ae(x,y+n,1),ae(y+n,x,0); while(bfs()){ reach=true; while(reach)reach=false,dfs(S,0x3f3f3f3f); } for(int i=1;i\u003c=n;i++)for(int j=head[i];j!=-1;j=edge[j].next)if(!edge[j].val\u0026\u0026edge[j].to\u003en\u0026\u0026edge[j].to\u003c=2*n)to[i]=edge[j].to-n,ok[edge[j].to-n]=true; for(int i=1;i\u003c=n;i++){ if(ok[i])continue; int j=i; while(j)printf(\"%d \",j),j=to[j];puts(\"\"); } printf(\"%d\\n\",n-res); return 0; } 但是，这个就算吸了臭氧，还是会T三个点。 看了题解之后，发现每次我们实际上不用重新全跑，只要加入点nnn和所有与它相关的边。这个时候，剩下的图仍可以看作一个比较奇怪的残量网络。暴力++n++n++n直到n−flow\u003eNn-flow \u003e Nn−flow\u003eN。然后，此时的n−1n-1n−1即为正确答案。 代码： #pragma GCC optimize(3) #include\u003cbits/stdc++.h\u003e using name","date":"2021-02-09","objectID":"/posts/oi/algorithm/graph/flow1/:0:0","series":null,"tags":[],"title":"flow1","uri":"/posts/oi/algorithm/graph/flow1/#"},{"categories":[],"content":"里是网络流学习笔记II。上一篇笔记写够一百题了，故开个新坑。 本文中各种约定同上一篇笔记中一致。 现在开始！ CI.[国家集训队]部落战争 第一题，挑道比较板子的题罢。 首先很明显可以抽象出一张从一个位置走到另一个的有向无环图出来（因为只能从上往下打） 然后就是最小路径覆盖问题的板子。很遗憾的是，我忘记了最小路径覆盖问题的解法，于是使用了XLIII.[SDOI2010]星际竞速中的拆点+最小费用最大流的做法，一样能过，就是被卡掉一个点，不得不吸氧。 代码： #include\u003cbits\\/stdc++.h\u003e using namespace std; int n,m,a,b; char s[60][60]; namespace MCMF{ const int N=5010,M=200000; int head[N],cnt,dis[N],fr[N],id[N],S,T,cost; struct node{ int to,next,val,cost; }edge[M]; void ae(int u,int v,int w,int c){ \\/\\/ printf(\"%d %d %d %d\\n\",u,v,w,c); edge[cnt].cost=c,edge[cnt].next=head[u],edge[cnt].to=v,edge[cnt].val=w,head[u]=cnt++; edge[cnt].cost=-c,edge[cnt].next=head[v],edge[cnt].to=u,edge[cnt].val=0,head[v]=cnt++; } queue\u003cint\u003eq; bool in[N]; bool SPFA(){ memset(dis,0x3f,sizeof(dis)),dis[S]=0,q.push(S),in[S]=true; while(!q.empty()){ int x=q.front();q.pop(),in[x]=false; \\/\\/ printf(\"%d\\n\",x); for(int i=head[x];i!=-1;i=edge[i].next){ if(!edge[i].val)continue; if(dis[edge[i].to]\u003edis[x]+edge[i].cost){ dis[edge[i].to]=dis[x]+edge[i].cost,fr[edge[i].to]=x,id[edge[i].to]=i; if(!in[edge[i].to])in[edge[i].to]=true,q.push(edge[i].to); } } } if(dis[T]==dis[T+1])return false; int x=T,mn=0x3f3f3f3f; while(x!=S)mn=min(mn,edge[id[x]].val),x=fr[x]; cost+=dis[T]*mn,x=T; while(x!=S)edge[id[x]].val-=mn,edge[id[x]^1].val+=mn,x=fr[x]; return true; } } using namespace MCMF; int main(){ scanf(\"%d%d%d%d\",\u0026n,\u0026m,\u0026a,\u0026b),S=2*n*m,T=S+1,memset(head,-1,sizeof(head)); int dx[4]={a,b,b,a},dy[4]={-b,-a,a,b}; for(int i=0;i\u003cn;i++)scanf(\"%s\",s[i]); for(int i=0;i\u003cn;i++)for(int j=0;j\u003cm;j++){ if(s[i][j]=='x')continue; ae(S,i*m+j,1,0); ae(i*m+j,T,1,1); ae(n*m+i*m+j,T,1,0); for(int k=0;k\u003c4;k++){ int ii=i+dx[k],jj=j+dy[k]; if(ii\u003c0||ii\u003e=n||jj\u003c0||jj\u003e=m||s[ii][jj]=='x')continue; \\/\\/ printf(\"(%d,%d):(%d,%d)\\n\",i,j,ii,jj); ae(i*m+j,n*m+ii*m+jj,1,0); } } while(SPFA()); \\/\\/ for(int i=0;i\u003ccnt;i++)if(edge[i^1].val\u0026\u0026edge[i^1].to\u003cn*m)printf(\"%d-\u003e%d\\n\",edge[i^1].to,edge[i].to); printf(\"%d\\n\",cost); return 0; } CII.[NOI2015]小园丁与老司机 首先，老司机部分考虑DP：明显 yyy 值不同的状态间转移是有阶段性的，但是 yyy 值相同时则不然；于是为了凸显阶段性，我们设 fxf_xfx​ 表示从位置 xxx 进入某个 yyy 值的最大收益，gxg_xgx​ 表示从位置 xxx 离开某个 yyy 值的最大收益。 g→fg\\rightarrow fg→f 的转移（即为不同 yyy 间的转移）就直接从左上、上、右上三个方向转移即可，这部分是简单的；关键是 f→gf\\rightarrow gf→g，即同一 yyy 间的转移。因为保证每个 yyy 值的树不会太多，所以可以直接 n2n^2n2 地枚举所有转移对进行转移即可。 记录路径，我们就完成了老司机部分。 然后是小园丁部分。为了找到所有最优路径的并，我们需要建出图来，每个 fx,gxf_x, g_xfx​,gx​ 各独立作一个节点（因此，总节点数应为 2n+22n+22n+2 个），在可能出现的位置连边，并且从每个最优的终局节点反向推出所有合法的边。这样，我们便可以建出一张所有需要经过的边所构成的DAG。 此DAG上，每条边被经过的下限是 111，上限是 ∞\\infty∞（实际应用中取 3n3n3n 即可，因为最多只会有不超过 3n3n3n 条边）。于是我们建图跑上下界最小流即可。 代码: #include\u003cbits\\/stdc++.h\u003e using namespace std; const int N=50100; namespace MaxFlow{ const int M=2000000; int head[N],cur[N],dep[N],cnt,S,T,s,t,ans,deg[N]; struct node{ int to,next,val; }edge[M]; void ae(int u,int v,int w){ edge[cnt].next=head[u],edge[cnt].to=v,edge[cnt].val=w,head[u]=cnt++; edge[cnt].next=head[v],edge[cnt].to=u,edge[cnt].val=0,head[v]=cnt++; } void AE(int u,int v,int l,int r){ \\/\\/ printf(\"%d %d [%d,%d]\\n\",u,v,l,r); deg[v]+=l,deg[u]-=l; edge[cnt].next=head[u],edge[cnt].to=v,edge[cnt].val=r-l,head[u]=cnt++; edge[cnt].next=head[v],edge[cnt].to=u,edge[cnt].val=0,head[v]=cnt++; } queue\u003cint\u003eq; inline bool bfs(){ memset(dep,0,sizeof(dep)),q.push(S),dep[S]=1; while(!q.empty()){ register int x=q.front();q.pop(); for(register int i=cur[x]=head[x];i!=-1;i=edge[i].next)if(edge[i].val\u0026\u0026!dep[edge[i].to])dep[edge[i].to]=dep[x]+1,q.push(edge[i].to); } return dep[T]\u003e0; } bool reach; inline int dfs(int x,int flow){ if(x==T){ ans+=flow; reach=true; return flow; } int used=0; for(register int \u0026i=cur[x];i!=-1;i=edge[i].next){ if(!edge[i].val||dep[edge[i].to]!=dep[x]+1)continue; register int ff=dfs(edge[i].to,min(edge[i].val,flow-used)); if(ff){ edge[i].val-=ff; edge[i^1].val+=ff; used+=ff; if(used==flow)break; } } return used; } inline void Dinic(){ while(bfs()){ reach=true; while(reach)reach=false,dfs(S,0x3f3f3f3f); } } } using namespace MaxFlow; int n,x[N],y[N],nw[N],ne[N],f[N],g[N],F[N],G[N],res;\\/\\/f:maximal when arriving at i g:maximal when leavi","date":"2021-02-09","objectID":"/posts/oi/algorithm/graph/flow2/:0:0","series":null,"tags":[],"title":"flow2","uri":"/posts/oi/algorithm/graph/flow2/#"},{"categories":[],"content":"幂函数 定义 形如 f(x)=xaf(x)=x^af(x)=xa的关于x的函数满足a为常数, a\\in \\mathbb{R} 性质 \\begin{cases}当a\u003e0时过(0,0),(1,1)且在第一象限内单调递增\\\\\\\\当a\u003c0时过(1,1)且在第一象限内单调递减\\end{cases} 设a=\\dfrac{p}{q},p,q\\in \\mathbb{N^*} \\begin{cases}p\\equiv1\\mod 2,q\\equiv0\\mod 2时函数在第一,二象限,图像关于y轴对称\\\\\\\\p\\equiv1\\mod 2,q\\equiv1\\mod 2时函数在第一,三象限,图像关于原点轴对称\\\\\\\\p\\equiv0\\mod 2,q\\equiv1\\mod 2时函数在第一象限\\end{cases} 指数函数 定义 形如f(x)=axf(x)=a^xf(x)=ax的函数满足a\u003e0,a≠1a\u003e0, a\\neq 1a\u003e0,a=1 ","date":"2021-02-09","objectID":"/posts/math/hsd/4/4/:0:0","series":null,"tags":[],"title":"数学第4章","uri":"/posts/math/hsd/4/4/#"},{"categories":null,"content":"CF600E-Lomsat gelral 题目: 题目描述: You are given a rooted tree with root in vertex 1 1 1 . Each vertex is coloured in some colour. Let’s call colour c c c dominating in the subtree of vertex v v v if there are no other colours that appear in the subtree of vertex v v v more times than colour c c c . So it’s possible that two or more colours will be dominating in the subtree of some vertex. The subtree of vertex v v v is the vertex v v v and all other vertices that contains vertex v v v in each path to the root. For each vertex v v v find the sum of all dominating colours in the subtree of vertex v v v . 输入格式: The first line contains integer n n n ( 1\u003c=n\u003c=105 1\u003c=n\u003c=10^{5} 1\u003c=n\u003c=105 ) — the number of vertices in the tree. The second line contains n n n integers ci c_{i} ci​ ( 1\u003c=ci\u003c=n 1\u003c=c_{i}\u003c=n 1\u003c=ci​\u003c=n ), ci c_{i} ci​ — the colour of the i i i -th vertex. Each of the next n−1 n-1 n−1 lines contains two integers xj,yj x_{j},y_{j} xj​,yj​ ( 1\u003c=xj,yj\u003c=n 1\u003c=x_{j},y_{j}\u003c=n 1\u003c=xj​,yj​\u003c=n ) — the edge of the tree. The first vertex is the root of the tree. 输出格式: Print n n n integers — the sums of dominating colours for each vertex. 样例: 样例输入1: 4 1 2 3 4 1 2 2 3 2 4 样例输出1: 10 9 3 4 样例输入2: 15 1 2 3 1 2 3 3 1 1 3 2 2 1 2 3 1 2 1 3 1 4 1 14 1 15 2 5 2 6 2 7 3 8 3 9 3 10 4 11 4 12 4 13 样例输出2: 6 5 4 3 2 3 3 1 1 3 2 2 1 2 3 思路: 一道dsu on tree的简单例题 用一个通桶统计一遍答案即可 实现: // Problem: CF600E Lomsat gelral // Contest: Luogu // URL: https://www.luogu.com.cn/problem/CF600E // Memory Limit: 250 MB // Time Limit: 2000 ms // Author: Ybw051114 // // Powered by CP Editor (https://cpeditor.org) #include \"ybwhead/ios.h\" #define int long long const int maxn = 1e5 + 10; struct edge { int v, nxt; } e[maxn \u003c\u003c 1]; int head[maxn], tot, ans[maxn], siz[maxn], c[maxn], wson[maxn]; int a[maxn], n; int mx, sum; void __ADD(int u, int v) { e[++tot] = {v, head[u]}; head[u] = tot; } void add(int u, int v) { __ADD(u, v), __ADD(v, u); } void dfs(int u, int fa) { siz[u] = 1; for (int i = head[u]; i; i = e[i].nxt) { int v = e[i].v; if (v == fa) continue; dfs(v, u); siz[u] += siz[v]; if (siz[wson[u]] \u003c siz[v]) wson[u] = v; } } void add(int u, int fa, int rt) { c[a[u]]++; if (c[a[u]] == mx) sum += a[u]; if (c[a[u]] \u003e mx) sum = a[u], mx = c[a[u]]; for (int i = head[u]; i; i = e[i].nxt) { int v = e[i].v; if (v == fa) continue; add(v, u, rt); } } void del(int u, int fa) { c[a[u]]--; mx = sum = 0; for (int i = head[u]; i; i = e[i].nxt) { int v = e[i].v; if (v == fa) continue; del(v, u); } } void solve(int u, int fa) { for (int i = head[u]; i; i = e[i].nxt) { int v = e[i].v; if (v == fa || v == wson[u]) continue; solve(v, u); del(v, u); } if (wson[u]) solve(wson[u], u); // cerr \u003c\u003c mx \u003c\u003c \" \" \u003c\u003c sum \u003c\u003c endl; c[a[u]]++; if (c[a[u]] == mx) sum += a[u]; if (c[a[u]] \u003e mx) sum = a[u], mx = c[a[u]]; for (int i = head[u]; i; i = e[i].nxt) { int v = e[i].v; if (v == fa || v == wson[u]) continue; add(v, u, u); } ans[u] = sum; } signed main() { yin \u003e\u003e n; for (int i = 1; i \u003c= n; ++i) { yin \u003e\u003e a[i]; } for (int i = 1; i \u003c n; i++) { int x, y; yin \u003e\u003e x \u003e\u003e y; add(x, y); } dfs(1, 0); solve(1, 0); for (int i = 1; i \u003c= n; i++) yout \u003c\u003c ans[i] \u003c\u003c \" \"; return 0; } ","date":"2021-02-07","objectID":"/posts/oi/problems/cf600e/:0:0","series":null,"tags":["dsu_on_tree","启发式","Notebooks/OI/OJ/Luogu"],"title":"CF600E-Lomsat gelral","uri":"/posts/oi/problems/cf600e/#"},{"categories":null,"content":"P3966-[TJOI2013]单词 题目: 题目描述: 小张最近在忙毕设,所以一直在读论文。一篇论文是由许多单词组成但小张发现一个单词会在论文中出现很多次，他想知道每个单词分别在论文中出现了多少次。 输入格式: 第一行一个整数 NNN，表示有 NNN 个单词。 接下来 NNN 行每行一个单词,每个单词都由小写字母 a−za-za−z 组成。 输出格式: 输出 NNN 个整数,第 iii 行的数表示第 iii 个单词在文章中出现了多少次。 样例: 样例输入1: 3 a aa aaa 样例输出1: 6 3 1 思路: 实现: // Problem: P3966 [TJOI2013]单词 // Contest: Luogu // URL: https://www.luogu.com.cn/problem/P3966 // Memory Limit: 500 MB // Time Limit: 2000 ms // Author: Ybw051114 // // Powered by CP Editor (https://cpeditor.org) #include \"ybwhead/ios.h\" const int maxn = 1e6 + 1e5 + 10; int n, a[maxn], h[maxn], cnt, last, ch[maxn][26], sz[maxn], fail[maxn]; char s[maxn]; struct ac { void ins(int x) { yin \u003e\u003e (s + 1); int now = 0, len = strlen(s + 1); for (int i = 1; i \u003c= len; i++) { int u = s[i] - 'a'; if (!ch[now][u]) ch[now][u] = ++cnt; now = ch[now][u]; sz[now]++; } a[x] = now; } void build() { int i, head = 0, tail = 0; for (i = 0; i \u003c 26; i++) if (ch[0][i]) h[++tail] = ch[0][i]; while (head \u003c tail) { int x = h[++head], y; for (i = 0; i \u003c 26; i++) if (y = ch[x][i]) { h[++tail] = y; fail[y] = ch[fail[x]][i]; } else ch[x][i] = ch[fail[x]][i]; } } void solve() { for (int i = cnt; i \u003e= 0; i--) sz[fail[h[i]]] += sz[h[i]]; for (int i = 1; i \u003c= n; i++) yout \u003c\u003c sz[a[i]] \u003c\u003c endl; } } ac; int main() { //freopen(\"word.in\",\"r\",stdin); //freopen(\"word.out\",\"w\",stdout); yin \u003e\u003e n; for (int i = 1; i \u003c= n; i++) ac.ins(i); ac.build(); ac.solve(); return 0; } ","date":"2021-01-31","objectID":"/posts/oi/problems/p3966/:0:0","series":null,"tags":[2013,"各省省选","二分查找","概率论,统计","AC自动机","天津","Notebooks/OI/OJ/Luogu"],"title":"P3966-[TJOI2013]单词","uri":"/posts/oi/problems/p3966/#"},{"categories":null,"content":"P4036-[JSOI2008]火星人 题目: 题目描述: 火星人最近研究了一种操作：求一个字串两个后缀的公共前缀。 比方说，有这样一个字符串：madamimadam，我们将这个字符串的各个字符予以标号： 序号 1 2 3 4 5 6 7 8 9 10 11 字符 m a d a m i m a d a m 现在，火星人定义了一个函数 LCQ(x,y)LCQ(x, y)LCQ(x,y)，表示：该字符串中第 xxx 个字符开始的字串，与该字符串中第 yyy 个字符开始的字串，两个字串的公共前缀的长度。比方说，LCQ(1,7)=5,LCQ(2,10)=1,LCQ(4,7)=0LCQ(1, 7) = 5, LCQ(2, 10) = 1, LCQ(4, 7) = 0LCQ(1,7)=5,LCQ(2,10)=1,LCQ(4,7)=0 在研究 LCQLCQLCQ 函数的过程中，火星人发现了这样的一个关联：如果把该字符串的所有后缀排好序，就可以很快地求出 LCQLCQLCQ 函数的值；同样，如果求出了 LCQLCQLCQ 函数的值，也可以很快地将该字符串的后缀排好序。 尽管火星人聪明地找到了求取 LCQLCQLCQ 函数的快速算法，但不甘心认输的地球人又给火星人出了个难题：在求取 LCQLCQLCQ 函数的同时，还可以改变字符串本身。具体地说，可以更改字符串中某一个字符的值，也可以在字符串中的某一个位置插入一个字符。地球人想考验一下，在如此复杂的问题中，火星人是否还能够做到很快地求取 LCQLCQLCQ 函数的值。 输入格式: 第一行给出初始的字符串。第二行是一个非负整数 MMM ，表示操作的个数。接下来的M行，每行描述一个操作。操作有 333 种，如下所示 询问。语法：QQQ xxx yyy ，xxx ,yyy 均为正整数。功能：计算 LCQ(x,y)LCQ(x,y)LCQ(x,y) 限制：111 ≤\\leq≤ xxx , yyy ≤\\leq≤ 当前字符串长度 。 修改。语法：RRR xxx ddd，xxx 是正整数，ddd 是字符。功能：将字符串中第 xxx 个数修改为字符 ddd 。限制：xxx 不超过当前字符串长度。 插入：语法：III xxx ddd ，xxx 是非负整数，ddd 是字符。功能：在字符串第 xxx 个字符之后插入字符 ddd ，如果 x=0x=0x=0，则在字符串开头插入。限制：xxx 不超过当前字符串长度 输出格式: 对于输入文件中每一个询问操作，你都应该输出对应的答案。一个答案一行。 样例: 样例输入1: madamimadam 7 Q 1 7 Q 4 8 Q 10 11 R 3 a Q 1 7 I 10 a Q 2 11 样例输出1: 5 1 0 2 1 思路: 实现: // Problem: P4036 [JSOI2008]火星人 // Contest: Luogu // URL: https://www.luogu.com.cn/problem/P4036 // Memory Limit: 125 MB // Time Limit: 1000 ms // Author: Ybw051114 // // Powered by CP Editor (https://cpeditor.org) #include \"ybwhead/ios.h\" namespace IO { const int S = (1 \u003c\u003c 20) + 5; char buf[S], *H, *T; inline char Get() { if (H == T) T = (H = buf) + fread(buf, 1, S, stdin); if (H == T) return -1; return *H++; } inline int read() { int x = 0; char c = Get(); while (!isdigit(c)) c = Get(); while (isdigit(c)) x = x * 10 + c - '0', c = Get(); return x; } inline char readc() { char c = Get(); while ((c \u003c 'A' || c \u003e 'Z') \u0026\u0026 (c \u003c 'a' || c \u003e 'z')) c = Get(); return c; } char obuf[S], *oS = obuf, *oT = oS + S - 1, c, qu[55]; int qr; inline void flush() { fwrite(obuf, 1, oS - obuf, stdout); oS = obuf; } inline void putc(char x) { *oS++ = x; if (oS == oT) flush(); } template \u003cclass I\u003e inline void print(I x) { if (!x) putc('0'); while (x) qu[++qr] = x % 10 + '0', x /= 10; while (qr) putc(qu[qr--]); putc('\\n'); } } // namespace IO using namespace IO; typedef unsigned long long ull; const int N = 150010; const double alpha = 0.75; int lc[N], rc[N], sz[N], tot = 0, rt = 0; ull val[N], sum[N], pw[N]; vector\u003cint\u003e A; bool isbad(int o) { return sz[lc[o]] \u003e alpha * sz[o] + 5 || sz[rc[o]] \u003e alpha * sz[o] + 5; } void maintain(int o) { sum[o] = sum[rc[o]] + val[o] * pw[sz[rc[o]]] + sum[lc[o]] * pw[sz[rc[o]] + 1]; sz[o] = sz[lc[o]] + sz[rc[o]] + 1; } void flatten(int o) { if (!o) return; flatten(lc[o]); A.push_back(o); flatten(rc[o]); } void rebuild(int \u0026o, int l, int r) { int mid = (l + r) / 2; o = A[mid - 1]; lc[o] = rc[o] = 0; if (l \u003c mid) rebuild(lc[o], l, mid - 1); if (r \u003e mid) rebuild(rc[o], mid + 1, r); maintain(o); } void insert(int \u0026o, int k, int x) { if (!o) { o = ++tot; lc[o] = rc[o] = 0; val[o] = sum[o] = x; sz[o] = 1; return; } if (isbad(o)) { A.clear(); flatten(o); rebuild(o, 1, A.size()); } int szl = sz[lc[o]]; if (k \u003c= szl) insert(lc[o], k, x); else insert(rc[o], k - szl - 1, x); maintain(o); } void modify(int o, int k, int x) { int szl = sz[lc[o]]; if (k == szl + 1) val[o] = x; else if (k \u003c= szl) modify(lc[o], k, x); else modify(rc[o], k - szl - 1, x); maintain(o); } ull find(int o, int l, int r, int nl, int nr) { if (l == nl \u0026\u0026 r == nr) return sum[o]; int szl = sz[lc[o]]; ull res = 0; if (nr \u003c l + szl) return find(lc[o], l, l + szl - 1, nl, nr); if (nl \u003e l + szl) return find(rc[o], l + szl + 1, r, nl, nr); if (nl \u003c l + szl) res = find(lc[o], l, l + szl - 1, nl, l + szl - 1); if (nl \u003c= l + szl \u0026\u0026 nr \u003e= l + szl) res = res * pw[1] + val[o]; if (nr \u003e l + szl) res = res * pw[nr - l - szl] + find(rc[o], l + szl + 1, r, l + szl + 1, nr); return res; } int lcp(int x, int y) { int res = 0; for (int i = 17; i \u003e= 0; i--) { if (x + (1 \u003c\u003c i) - 1 \u003e tot) continue; if (y + (1 \u003c\u003c i) - 1 \u003e tot) continue; ul","date":"2021-01-31","objectID":"/posts/oi/problems/p4036/:0:0","series":null,"tags":["字符串",2008,"各省省选","平衡树","江苏","哈希,HASH","Notebooks/OI/OJ/Luogu"],"title":"P4036-[JSOI2008]火星人","uri":"/posts/oi/problems/p4036/#"},{"categories":null,"content":"P1001-A+B Problem 题目: 题目描述: 输入两个整数 a,ba,ba,b，输出它们的和（∣a∣,∣b∣≤109|a|,|b|\\leq 10^9∣a∣,∣b∣≤109）。 注意 Pascal 使用 integer 会爆掉哦！ 有负数哦！ C/C++ 的 main 函数必须是 int 类型，而且最后要 return 0。这不仅对洛谷其他题目有效，而且也是 NOIP/NOI/CSP 比赛的要求！ 好吧，同志们，我们就从这一题开始，向着大牛的路进发。 任何一个伟大的思想，都有一个微不足道的开始。 输入格式: 两个整数以空格分开。 输出格式: 一个整数。 样例: 样例输入1: 20 30 样例输出1: 50 思路: 实现: #include\u003cbits/stdc++.h\u003e using namespace std; int main() { int a,b;cin\u003e\u003ea\u003e\u003eb; cout\u003c\u003ca+b\u003c\u003cendl; return 0; } ","date":"2021-01-31","objectID":"/posts/oi/problems/p1001/:0:0","series":null,"tags":["模拟","Notebooks/OI/OJ/Luogu"],"title":"P1001-A+B Problem","uri":"/posts/oi/problems/p1001/#"},{"categories":null,"content":"CF30E-Tricky and Clever Password 题目: 题目描述: In his very young years the hero of our story, king Copa, decided that his private data was hidden not enough securely, what is unacceptable for the king. That’s why he invented tricky and clever password (later he learned that his password is a palindrome of odd length), and coded all his data using it. Copa is afraid to forget his password, so he decided to write it on a piece of paper. He is aware that it is insecure to keep password in such way, so he decided to cipher it the following way: he cut x x x characters from the start of his password and from the end of it ( x x x can be 0 0 0 , and 2x 2x 2x is strictly less than the password length). He obtained 3 parts of the password. Let’s call it prefix prefix prefix , middle middle middle and suffix suffix suffix correspondingly, both prefix prefix prefix and suffix suffix suffix having equal length and middle middle middle always having odd length. From these parts he made a string A+prefix+B+middle+C+suffix A+prefix+B+middle+C+suffix A+prefix+B+middle+C+suffix , where A A A , B B B and C C C are some (possibly empty) strings invented by Copa, and « + + + » means concatenation. Many years have passed, and just yesterday the king Copa found the piece of paper where his ciphered password was written. The password, as well as the strings A A A , B B B and C C C , was completely forgotten by Copa, so he asks you to find a password of maximum possible length, which could be invented, ciphered and written by Copa. 输入格式: The input contains single string of small Latin letters with length from 1 1 1 to 105 10^{5} 105 characters. 输出格式: The first line should contain integer k k k — amount of nonempty parts of the password in your answer (). In each of the following k k k lines output two integers xi x_{i} xi​ and li l_{i} li​ — start and length of the corresponding part of the password. Output pairs in order of increasing xi x_{i} xi​ . Separate the numbers in pairs by a single space. Starting position xi x_{i} xi​ should be an integer from 1 1 1 to the length of the input string. All li l_{i} li​ must be positive, because you should output only non-empty parts. The middle part must have odd length. If there are several solutions, output any. Note that your goal is to maximize the sum of li l_{i} li​ , but not to maximize k k k . 样例: 样例输入1: abacaba 样例输出1: 1 1 7 样例输入2: axbya 样例输出2: 3 1 1 2 1 5 1 样例输入3: xabyczba 样例输出3: 3 2 2 4 1 7 2 思路: 实现: // Problem: CF30E Tricky and Clever Password // Contest: Luogu // URL: https://www.luogu.com.cn/problem/CF30E // Memory Limit: 250 MB // Time Limit: 2000 ms // Author: Ybw051114 // // Powered by CP Editor (https://cpeditor.org) #include \u003cbits/stdc++.h\u003e #define fi first #define se second #define mkp make_pair using namespace std; typedef long long ll; typedef pair\u003cint, int\u003e pii; const int N = 1e5 + 10, bas[] = {29, 31}; const int mod[] = {998244353, 19260817}; int n; int f[N], g[N]; int t[2], pw[2][N], hsl[2][N], hsr[2][N]; pii ans[5]; char s[N]; void iniths() { for (int k = 0; k \u003c 2; ++k) { pw[k][0] = 1; for (int i = 1; i \u003c= n; ++i) pw[k][i] = (ll)pw[k][i - 1] * bas[k] % mod[k]; } for (int k = 0; k \u003c 2; ++k) { for (int i = 1; i \u003c= n; ++i) hsl[k][i] = ((ll)hsl[k][i - 1] * bas[k] + (s[i] - 'a' + 1)) % mod[k]; for (int i = n; i; --i) hsr[k][i] = ((ll)hsr[k][i + 1] * bas[k] + (s[i] - 'a' + 1)) % mod[k]; } } pii gethsl(int l, int r) { for (int k = 0; k \u003c 2; ++k) t[k] = (hsl[k][r] - (ll)hsl[k][l - 1] * pw[k][r - l + 1] % mod[k] + mod[k]) % mod[k]; return mkp(t[0], t[1]); } pii gethsr(int l, int r) { for (int k = 0; k \u003c 2; ++k) t[k] = (hsr[k][l] - (ll)hsr[k][r + 1] * pw[k][r - l + 1] % mod[k] + mod[k]) % mod[k]; return mkp(t[0], t[1]); } int main() { #ifndef ONLINE_JUDGE freopen(\"CF30E.in\", \"r\", stdin); freopen(\"CF30E.out\", \"w\", stdout); #endif scanf(\"%s\", s + 1); n = strlen(s + 1); iniths(); for (int i = 1; i \u003c= n; ++i) { int l = 1, r = min(i, n - i + 1); f[i] = 1; while (l \u003c= r) { int mid = (l + r) \u003e\u003e 1; if (g","date":"2021-01-31","objectID":"/posts/oi/problems/cf30e/:0:0","series":null,"tags":["Notebooks/OI/OJ/Luogu"],"title":"CF30E-Tricky and Clever Password","uri":"/posts/oi/problems/cf30e/#"},{"categories":null,"content":"P4287-[SHOI2011]双倍回文 题目: 题目描述: 记字符串www的倒置为wRw^RwR。例如(abcd)R=dcba(abcd)^R=dcba(abcd)R=dcba，(abba)R=abba(abba)^R=abba(abba)R=abba。 对字符串x，如果xxx满足xR=xx^R=xxR=x，则称之为回文；例如abba是一个回文，而abed不是。 如果x能够写成的wwRwwRww^Rww^RwwRwwR形式，则称它是一个“双倍回文”。换句话说，若要xxx是双倍回文，它的长度必须是444的倍数，而且xxx，xxx的前半部分，xxx的后半部分都要是回文。例如abbaabbaabbaabbaabbaabba是一个双倍回文，而abaabaabaabaabaaba不是，因为它的长度不是4的倍数。 xxx的子串是指在xxx中连续的一段字符所组成的字符串。例如bebebe是abedabedabed的子串，而acacac不是。 xxx的回文子串，就是指满足回文性质的xxx的子串。 xxx的双倍回文子串，就是指满足双倍回文性质的xxx的子串。 你的任务是，对于给定的字符串，计算它的最长双倍回文子串的长度。 输入格式: 输入分为两行。 第一行为一个整数，表示字符串的长度。 第二行有个连续的小写的英文字符，表示字符串的内容。 输出格式: 输出文件只有一行，即：输入数据中字符串的最长双倍回文子串的长度，如果双倍回文子串不存在，则输出000。 样例: 样例输入1: 16 ggabaabaabaaball 样例输出1: 12 思路: 实现: // Problem: P4287 [SHOI2011]双倍回文 // Contest: Luogu // URL: https://www.luogu.com.cn/problem/P4287 // Memory Limit: 125 MB // Time Limit: 1000 ms // Author: Ybw051114 // // Powered by CP Editor (https://cpeditor.org) #include \u003calgorithm\u003e #include \u003ccstdio\u003e using namespace std; const int N = 1e6 + 5; int n, f[N], ans; char a[N], s[N]; int main() { scanf(\"%d%s\", \u0026n, a + 1); s[0] = '~'; for (int i = 1; i \u003c= n; i++) s[i * 2 - 1] = '#', s[i * 2] = a[i]; s[n * 2 + 1] = '#'; for (int i = 1, r = 0, c = 0; i \u003c= n * 2; i += 2) { f[i] = i \u003c r ? min(f[c * 2 - i], r - i) : 1; if (i \u003c r \u0026\u0026 i - f[i] \u003c c) ans = max(ans, i - c \u003c\u003c 1); while (s[i - f[i]] == s[i + f[i]]) f[i]++; if (i + f[i] \u003e r) r = i + f[i], c = i; } printf(\"%d\\n\", ans); return 0; } ","date":"2021-01-31","objectID":"/posts/oi/problems/p4287/:0:0","series":null,"tags":[2011,"各省省选","上海","回文自动机PAM","Notebooks/OI/OJ/Luogu"],"title":"P4287-[SHOI2011]双倍回文","uri":"/posts/oi/problems/p4287/#"},{"categories":null,"content":"P4555-[国家集训队]最长双回文串 题目: 题目描述: 顺序和逆序读起来完全一样的串叫做回文串。比如acbca是回文串，而abc不是（abc的顺序为abc，逆序为cba，不相同）。 输入长度为nnn的串SSS，求SSS的最长双回文子串TTT,即可将TTT分为两部分XXX，YYY，（∣X∣,∣Y∣≥1|X|,|Y|≥1∣X∣,∣Y∣≥1）且XXX和YYY都是回文串。 输入格式: 一行由小写英文字母组成的字符串SSS。 输出格式: 一行一个整数，表示最长双回文子串的长度。 样例: 样例输入1: baacaabbacabb 样例输出1: 12 思路: 实现: // Problem: P4555 [国家集训队]最长双回文串 // Contest: Luogu // URL: https://www.luogu.com.cn/problem/P4555 // Memory Limit: 125 MB // Time Limit: 1000 ms // Author: Ybw051114 // // Powered by CP Editor (https://cpeditor.org) #include \"ybwhead/ios.h\" const int maxn = 2e5 + 10; char s[maxn \u003c\u003c 1], t[maxn \u003c\u003c 1]; int p[maxn], l[maxn], r[maxn]; int mx, n, id; int main() { yin \u003e\u003e (t + 1); n = strlen(t + 1); int cnt = 0; s[++cnt] = '$', s[++cnt] = '#'; for (int i = 1; i \u003c= n; i++) s[++cnt] = t[i], s[++cnt] = '#'; s[++cnt] = '\\0'; n = cnt; // puts(s + 1); // n = 2 * n + 1; for (int i = 1; i \u003c= n; i++) { if (i \u003c mx) p[i] = min(p[id * 2 - i], mx - i); else p[i] = 1; while (s[i - p[i]] == s[i + p[i]]) p[i]++; if (mx \u003c i + p[i]) id = i, mx = i + p[i]; l[i + p[i] - 1] = max(l[i + p[i] - 1], p[i] - 1); r[i - p[i] + 1] = max(r[i - p[i] + 1], p[i] - 1); } for (int i = 2; i \u003c= n; i += 2) { if (i \u003e 1) r[i] = max(r[i], r[i - 2] - 2); // cerr \u003c\u003c i \u003c\u003c \" \" \u003c\u003c r[i] \u003c\u003c endl; } for (int i = n; i \u003e= 2; i -= 2) { l[i] = max(l[i], l[i + 2] - 2); // cerr \u003c\u003c i \u003c\u003c \" \" \u003c\u003c l[i] \u003c\u003c endl; } int ans = 0; for (int i = 2; i \u003c= n; i += 2) if (r[i] \u0026\u0026 l[i]) ans = max(ans, l[i] + r[i]); yout \u003c\u003c ans \u003c\u003c endl; return 0; } ","date":"2021-01-31","objectID":"/posts/oi/problems/p4555/:0:0","series":null,"tags":["字符串","线段树","WC/CTSC/集训队","枚举,暴力","Manacher算法","Notebooks/OI/OJ/Luogu"],"title":"P4555-[国家集训队]最长双回文串","uri":"/posts/oi/problems/p4555/#"},{"categories":null,"content":"CF17E-Palisection 题目: 题目描述: In an English class Nick had nothing to do at all, and remembered about wonderful strings called palindromes. We should remind you that a string is called a palindrome if it can be read the same way both from left to right and from right to left. Here are examples of such strings: «eye», «pop», «level», «aba», «deed», «racecar», «rotor», «madam». Nick started to look carefully for all palindromes in the text that they were reading in the class. For each occurrence of each palindrome in the text he wrote a pair — the position of the beginning and the position of the ending of this occurrence in the text. Nick called each occurrence of each palindrome he found in the text subpalindrome. When he found all the subpalindromes, he decided to find out how many different pairs among these subpalindromes cross. Two subpalindromes cross if they cover common positions in the text. No palindrome can cross itself. Let’s look at the actions, performed by Nick, by the example of text «babb». At first he wrote out all subpalindromes: • «b» — 1..1 1..1 1..1 • «bab» — 1..3 1..3 1..3 • «a» — 2..2 2..2 2..2 • «b» — 3..3 3..3 3..3 • «bb» — 3..4 3..4 3..4 • «b» — 4..4 4..4 4..4 Then Nick counted the amount of different pairs among these subpalindromes that cross. These pairs were six: 1..1 1..1 1..1 cross with 1..3 1..3 1..3 2. 1..3 1..3 1..3 cross with 2..2 2..2 2..2 3. 1..3 1..3 1..3 cross with 3..3 3..3 3..3 4. 1..3 1..3 1..3 cross with 3..4 3..4 3..4 5. 3..3 3..3 3..3 cross with 3..4 3..4 3..4 6. 3..4 3..4 3..4 cross with 4..4 4..4 4..4 Since it’s very exhausting to perform all the described actions manually, Nick asked you to help him and write a program that can find out the amount of different subpalindrome pairs that cross. Two subpalindrome pairs are regarded as different if one of the pairs contains a subpalindrome that the other does not. 输入格式: The first input line contains integer n n n ( 1\u003c=n\u003c=2⋅106 1\u003c=n\u003c=2·10^{6} 1\u003c=n\u003c=2⋅106 ) — length of the text. The following line contains n n n lower-case Latin letters (from a to z). 输出格式: In the only line output the amount of different pairs of two subpalindromes that cross each other. Output the answer modulo 51123987 51123987 51123987 . 样例: 样例输入1: 4 babb 样例输出1: 6 样例输入2: 2 aa 样例输出2: 2 思路: 实现: // Problem: CF17E Palisection // Contest: Luogu // URL: https://www.luogu.com.cn/problem/CF17E // Memory Limit: 125 MB // Time Limit: 2000 ms // Author: Ybw051114 // // Powered by CP Editor (https://cpeditor.org) #include \"ybwhead/ios.h\" using namespace std; // typedef int ll; typedef long long int li; const ll maxn = 4e6 + 51, mod = 51123987, inv2 = 25561994; ll n, mxr, mid, c, res, lx, rx; ll rad[maxn], f[maxn], g[maxn]; char s[maxn], ch[maxn]; int main() { yin \u003e\u003e n \u003e\u003e (s + 1); ch[0] = '~', ch[n * 2 + 1] = '|'; for (register int i = 1; i \u003c= n; i++) { ch[i * 2 - 1] = '|', ch[i * 2] = s[i]; } for (register int i = 1; i \u003c= 2 * n + 1; i++) { rad[i] = i \u003c mxr ? min(rad[(mid \u003c\u003c 1) - i], rad[mid] + mid - i) : 1; while (ch[i + rad[i]] == ch[i - rad[i]]) { rad[i]++; } rad[i] + i \u003e mxr ? mxr = rad[i] + i, mid = i : 1; } for (register int i = 1; i \u003c= 2 * n + 1; i++) { lx = i - rad[i] + 1, rx = i + rad[i] - 1, lx += lx \u0026 1, rx -= rx \u0026 1; if (lx \u003c= rx) { lx \u003e\u003e= 1, rx \u003e\u003e= 1, f[lx]++, f[(i \u003e\u003e 1) + 1]--, g[(i + 1) \u003e\u003e 1]++, g[rx + 1]--; c = (c + (i \u003e\u003e 1) - lx + 1) % mod; } } for (register int i = 1; i \u003c= n; i++) { f[i] += f[i - 1], g[i] += g[i - 1]; } for (register int i = 1; i \u003c= n; i++) { g[i] = (g[i] + g[i - 1]) % mod, res = (res + (li)f[i] * g[i - 1] % mod) % mod; } yout \u003c\u003c ((li)c * (c - 1) % mod * inv2 % mod - res + mod) % mod \u003c\u003c endl; } ","date":"2021-01-31","objectID":"/posts/oi/problems/cf17e/:0:0","series":null,"tags":["字符串","前缀和","差分","Notebooks/OI/OJ/Luogu"],"title":"CF17E-Palisection","uri":"/posts/oi/problems/cf17e/#"},{"categories":null,"content":"P1659-[国家集训队]拉拉队排练 题目: 题目描述: 艾利斯顿商学院篮球队要参加一年一度的市篮球比赛了。拉拉队是篮球比赛的一个看点，好的拉拉队往往能帮助球队增加士气，赢得最终的比赛。所以作为拉拉队队长的楚雨荨同学知道，帮助篮球队训练好拉拉队有多么的重要。 拉拉队的选拔工作已经结束，在雨荨和校长的挑选下，n位集优秀的身材、舞技于一体的美女从众多报名的女生中脱颖而出。这些女生将随着篮球队的小伙子们一起，和对手抗衡，为艾利斯顿篮球队加油助威。 一个阳光明媚的早晨，雨荨带领拉拉队的队员们开始了排练。n个女生从左到右排成一行，每个人手中都举了一个写有26个小写字母中的某一个的牌子，在比赛的时候挥舞，为小伙子们呐喊、加油。 雨荨发现，如果连续的一段女生，有奇数个，并且他们手中的牌子所写的字母，从左到右和从右到左读起来一样，那么这一段女生就被称作和谐小群体。 现在雨荨想找出所有和谐小群体，并且按照女生的个数降序排序之后，前K个和谐小群体的女生个数的乘积是多少。由于答案可能很大，雨荨只要你告诉她，答案除以19930726的余数是多少就行了。 输入格式: 输入为标准输入。 第一行为两个正整数n和K，代表的东西在题目描述中已经叙述。 接下来一行为n个字符，代表从左到右女生拿的牌子上写的字母。 输出格式: 输出为标准输出。 输出一个整数，代表题目描述中所写的乘积除以19930726的余数，如果总的和谐小群体个数小于K，输出一个整数-1。 样例: 样例输入1: 5 3 ababa 样例输出1: 45 思路: 实现: // Problem: P1659 [国家集训队]拉拉队排练 // Contest: Luogu // URL: https://www.luogu.com.cn/problem/P1659 // Memory Limit: 125 MB // Time Limit: 1000 ms // Author: Ybw051114 // // Powered by CP Editor (https://cpeditor.org) #include \"ybwhead/ios.h\" int n; long long k; const int maxn = 1e6 + 10; char s[maxn]; // char s[N \u003c\u003c 1]; long long len, RL[maxn], mxxnum, sum, ans = 1; const long long mod = 19930726; long long MaxRight, center, tong[maxn]; long long ksm(long long x, long long y) { long long res = 1; for (; y; y \u003e\u003e= 1, x = x * x % mod) if (y \u0026 1) res = res * x % mod; return res; } int main() { yin \u003e\u003e n \u003e\u003e k; yin \u003e\u003e (s + 1); for (int i = 1; i \u003c= n; i++) { if (i \u003c= MaxRight) RL[i] = min(MaxRight - i, RL[2 * center - i]); else RL[i] = 1; while (i + RL[i] \u003c= n \u0026\u0026 i - RL[i] \u003e= 0 \u0026\u0026 s[i + RL[i]] == s[i - RL[i]]) ++RL[i]; if (i + RL[i] - 1 \u003e MaxRight) MaxRight = i + RL[i] - 1, center = i; tong[2 * RL[i] - 1]++; } if (n % 2 != 1) n--; for (int i = n; i \u003e= 1; i -= 2) { sum += tong[i]; if (sum \u003e k) { ans = ans * ksm(i, k) % mod; k = 0; break; } else { ans = ans * ksm(i, sum) % mod; k -= sum; } } if (k \u003e 0) yout \u003c\u003c -1 \u003c\u003c endl; else yout \u003c\u003c ans \u003c\u003c endl; return 0; } ","date":"2021-01-31","objectID":"/posts/oi/problems/p1659/:0:0","series":null,"tags":["字符串","WC/CTSC/集训队","前缀和","Manacher算法","Notebooks/OI/OJ/Luogu"],"title":"P1659-[国家集训队]拉拉队排练","uri":"/posts/oi/problems/p1659/#"},{"categories":null,"content":"CF383C-Propagating tree 题目: 题目描述: Iahub likes trees very much. Recently he discovered an interesting tree named propagating tree. The tree consists of n n n nodes numbered from 1 1 1 to n n n , each node i i i having an initial value ai a_{i} ai​ . The root of the tree is node 1 1 1 . This tree has a special property: when a value val val val is added to a value of node i i i , the value - val val val is added to values of all the children of node i i i . Note that when you add value - val val val to a child of node i i i , you also add -(- val val val ) to all children of the child of node i i i and so on. Look an example explanation to understand better how it works. This tree supports two types of queries: \" 1 1 1 x x x val val val \" — val val val is added to the value of node x x x ; \" 2 2 2 x x x \" — print the current value of node x x x . In order to help Iahub understand the tree better, you must answer m m m queries of the preceding type. 输入格式: The first line contains two integers n n n and m m m (1\u003c=n,m\u003c=200000) (1\u003c=n,m\u003c=200000) (1\u003c=n,m\u003c=200000) . The second line contains n n n integers a1 a_{1} a1​ , a2 a_{2} a2​ , …, an a_{n} an​ (1\u003c=ai\u003c=1000) (1\u003c=a_{i}\u003c=1000) (1\u003c=ai​\u003c=1000) . Each of the next n–1 lines contains two integers vi v_{i} vi​ and ui u_{i} ui​ (1\u003c=vi,ui\u003c=n) (1\u003c=v_{i},u_{i}\u003c=n) (1\u003c=vi​,ui​\u003c=n) , meaning that there is an edge between nodes vi v_{i} vi​ and ui u_{i} ui​ . Each of the next m m m lines contains a query in the format described above. It is guaranteed that the following constraints hold for all queries: 1\u003c=x\u003c=n,1\u003c=val\u003c=1000 1\u003c=x\u003c=n,1\u003c=val\u003c=1000 1\u003c=x\u003c=n,1\u003c=val\u003c=1000 . 输出格式: For each query of type two (print the value of node x x x ) you must print the answer to the query on a separate line. The queries must be answered in the order given in the input. 样例: 样例输入1: 5 5 1 2 1 1 2 1 2 1 3 2 4 2 5 1 2 3 1 1 2 2 1 2 2 2 4 样例输出1: 3 3 0 思路: 实现: // Problem: CF383C Propagating tree // Contest: Luogu // URL: https://www.luogu.com.cn/problem/CF383C // Memory Limit: 250 MB // Time Limit: 2000 ms // Author: Ybw051114 // // Powered by CP Editor (https://cpeditor.org) #include \"ybwhead/ios.h\" const int maxn = 2e5 + 10; struct edge { int v, nxt; } e[maxn \u003c\u003c 1]; int n, m, head[maxn], tot; void __ADD(int u, int v) { e[++tot] = {v, head[u]}; head[u] = tot; } void add(int u, int v) { __ADD(u, v), __ADD(v, u); } int num, dfn[maxn], st[maxn], ed[maxn], dep[maxn]; void dfs(int u, int fa) { dfn[u] = st[u] = ++num; dep[u] = dep[fa] + 1; for (int i = head[u]; i; i = e[i].nxt) { int v = e[i].v; if (v == fa) continue; dfs(v, u); } ed[u] = num; } int c[maxn], a[maxn]; #define lowbit(x) (x \u0026 -x) void ad(int p, int x) { for (; p \u003c= n; p += lowbit(p)) c[p] += x; } int q(int p) { long long ans = 0; for (; p; p -= lowbit(p)) ans += c[p]; return ans; } int main() { yin \u003e\u003e n \u003e\u003e m; for (int i = 1; i \u003c= n; i++) yin \u003e\u003e a[i]; for (int i = 1; i \u003c n; i++) { int u, v; yin \u003e\u003e u \u003e\u003e v; add(u, v); } dfs(1, 0); while (m--) { int opt, x, y; yin \u003e\u003e opt \u003e\u003e x; if (opt == 1) { yin \u003e\u003e y; // yout \u003c\u003c x \u003c\u003c \" \" \u003c\u003c st[x] \u003c\u003c \" \" \u003c\u003c y \u003c\u003c endl; if (dep[x] \u0026 1) ad(st[x], y), ad(ed[x] + 1, -y); else ad(st[x], -y), ad(ed[x] + 1, y); } else { long long ans = a[x]; // yout \u003c\u003c q(dfn[x]) \u003c\u003c endl; if (dep[x] \u0026 1) ans += q(dfn[x]); else ans -= q(dfn[x]); yout \u003c\u003c ans \u003c\u003c endl; } } return 0; } ","date":"2021-01-27","objectID":"/posts/oi/problems/cf383c/:0:0","series":null,"tags":["模拟","线段树","深度优先搜索,DFS","Notebooks/OI/OJ/Luogu"],"title":"CF383C-Propagating tree","uri":"/posts/oi/problems/cf383c/#"},{"categories":null,"content":"CF85D-Sum of Medians 题目: 题目描述: In one well-known algorithm of finding the k k k -th order statistics we should divide all elements into groups of five consecutive elements and find the median of each five. A median is called the middle element of a sorted array (it’s the third largest element for a group of five). To increase the algorithm’s performance speed on a modern video card, you should be able to find a sum of medians in each five of the array. A sum of medians of a sorted k k k -element set S=a1,a2,...,ak S={a_{1},a_{2},...,a_{k}} S=a1​,a2​,...,ak​ , where a_{1}\u0026lt;a_{2}\u0026lt;a_{3}\u0026lt;...\u0026lt;a_{k} , will be understood by as The operator stands for taking the remainder, that is stands for the remainder of dividing x x x by y y y . To organize exercise testing quickly calculating the sum of medians for a changing set was needed. 输入格式: The first line contains number n n n ( 1\u003c=n\u003c=105 1\u003c=n\u003c=10^{5} 1\u003c=n\u003c=105 ), the number of operations performed. Then each of n n n lines contains the description of one of the three operations: add x x x — add the element x x x to the set; del x x x — delete the element x x x from the set; sum — find the sum of medians of the set. For any add x x x operation it is true that the element x x x is not included in the set directly before the operation. For any del x x x operation it is true that the element x x x is included in the set directly before the operation. All the numbers in the input are positive integers, not exceeding 109 10^{9} 109 . 输出格式: For each operation sum print on the single line the sum of medians of the current set. If the set is empty, print 0. Please, do not use the %lld specificator to read or write 64-bit integers in C++. It is preferred to use the cin, cout streams (also you may use the %I64d specificator). 样例: 样例输入1: 6 add 4 add 5 add 1 add 2 add 3 sum 样例输出1: 3 样例输入2: 14 add 1 add 7 add 2 add 5 sum add 6 add 8 add 9 add 3 add 4 add 10 sum del 1 sum 样例输出2: 5 11 13 思路: 实现: // Problem: CF85D Sum of Medians // Contest: Luogu // URL: https://www.luogu.com.cn/problem/CF85D // Memory Limit: 250 MB // Time Limit: 3000 ms // Author: Ybw051114 // // Powered by CP Editor (https://cpeditor.org) #include \"ybwhead/ios.h\" using namespace std; #define int long long const int QU = 100000, A_I = 1000000000, LOG_A_I = 30; int qu; //操作数 struct segtree { //动态开点线段树 int sz; //点数 struct node { int l, r, lson, rson, sum[5], cnt; } nd[QU * LOG_A_I + 1]; #define l(p) nd[p].l #define r(p) nd[p].r #define lson(p) nd[p].lson #define rson(p) nd[p].rson #define sum(p) nd[p].sum #define cnt(p) nd[p].cnt int nwnd(int l = 1, int r = A_I) { return nd[++sz] = node({l, r, 0, 0, {0, 0, 0, 0, 0}, 0}), sz; } //新建节点 void init() { nd[0] = node({0, 0, 0, 0, {0, 0, 0, 0, 0}, 0}); sz = 0; nwnd(); } //线段树初始化 void sprup(int p) { //上传 cnt(p) = cnt(lson(p)) + cnt(rson(p)); for (int i = 0; i \u003c 5; i++) sum(p)[i] = sum(lson(p))[i] + sum(rson(p))[(((i - cnt(lson(p))) % 5) + 5) % 5]; } void add(int x, int p = 1) { //add操作 if (l(p) == r(p)) return sum(p)[1] = x, cnt(p) = 1 /*此数in s*/, void(); int mid = l(p) + r(p) \u003e\u003e 1; if (x \u003c= mid) add(x, lson(p) = lson(p) ? lson(p) : nwnd(l(p), mid)); else add(x, rson(p) = rson(p) ? rson(p) : nwnd(mid + 1, r(p))); sprup(p); } void del(int x, int p = 1) { //del操作 if (l(p) == r(p)) return sum(p)[1] = cnt(p) = 0 /*此数notin s*/, void(); int mid = l(p) + r(p) \u003e\u003e 1; if (x \u003c= mid) del(x, lson(p) = lson(p) ? lson(p) : nwnd(l(p), mid)); else del(x, rson(p) = rson(p) ? rson(p) : nwnd(mid + 1, r(p))); sprup(p); } int _sum() /*sum操作*/ { return sum(1)[3]; } } segt; signed main() { yin \u003e\u003e qu; segt.init(); //线段树初始化 while (qu--) { string tp; int x; yin \u003e\u003e tp; if (tp == \"add\") yin \u003e\u003e x, segt.add(x); else if (tp == \"del\") yin \u003e\u003e x, segt.del(x); else yout \u003c\u003c segt._sum() \u003c\u003c \"\\n\"; } return 0; } ","date":"2021-01-27","objectID":"/posts/oi/problems/cf85d/:0:0","series":null,"tags":["线段树","枚举,暴力","排序","Notebooks/OI/OJ/Luogu"],"title":"CF85D-Sum of Medians","uri":"/posts/oi/problems/cf85d/#"},{"categories":null,"content":"CF280C-Game on Tree 题目: 题目描述: Momiji has got a rooted tree, consisting of n n n nodes. The tree nodes are numbered by integers from 1 1 1 to n n n . The root has number 1 1 1 . Momiji decided to play a game on this tree. The game consists of several steps. On each step, Momiji chooses one of the remaining tree nodes (let’s denote it by v v v ) and removes all the subtree nodes with the root in node v v v from the tree. Node v v v gets deleted as well. The game finishes when the tree has no nodes left. In other words, the game finishes after the step that chooses the node number 1 1 1 . Each time Momiji chooses a new node uniformly among all the remaining nodes. Your task is to find the expectation of the number of steps in the described game. 输入格式: The first line contains integer n n n (1\u003c=n\u003c=105) (1\u003c=n\u003c=10^{5}) (1\u003c=n\u003c=105) — the number of nodes in the tree. The next n−1 n-1 n−1 lines contain the tree edges. The i i i -th line contains integers ai a_{i} ai​ , bi b_{i} bi​ (1\u003c=a_{i},b_{i}\u003c=n; a_{i}≠b_{i}) — the numbers of the nodes that are connected by the i i i -th edge. It is guaranteed that the given graph is a tree. 输出格式: Print a single real number — the expectation of the number of steps in the described game. The answer will be considered correct if the absolute or relative error doesn’t exceed 10−6 10^{-6} 10−6 . 样例: 样例输入1: 2 1 2 样例输出1: 1.50000000000000000000 样例输入2: 3 1 2 1 3 样例输出2: 2.00000000000000000000 思路: 实现: // Problem: CF280C Game on Tree // Contest: Luogu // URL: https://www.luogu.com.cn/problem/CF280C // Memory Limit: 250 MB // Time Limit: 1000 ms // Author: Ybw051114 // // Powered by CP Editor (https://cpeditor.org) #include \"ybwhead/ios.h\" const int maxn = 1e5 + 10; struct edge { int v, nxt; } e[maxn \u003c\u003c 1]; int head[maxn], tot; void __ADD(int u, int v) { e[++tot] = {v, head[u]}; head[u] = tot; } void add(int u, int v) { __ADD(u, v); __ADD(v, u); } double ans; int n; void dfs(int u, int fa, int dep) { ans += (double)1.0 / dep; for (int i = head[u]; i; i = e[i].nxt) { int v = e[i].v; if (v == fa) continue; dfs(v, u, dep + 1); } } int main() { yin \u003e\u003e n; for (int i = 1; i \u003c n; i++) { int u, v; yin \u003e\u003e u \u003e\u003e v; add(u, v); } dfs(1, 0, 1); yout \u003c\u003c ans \u003c\u003c endl; return 0; } ","date":"2021-01-24","objectID":"/posts/oi/problems/cf280c/:0:0","series":null,"tags":["数论,数学","期望","Notebooks/OI/OJ/Luogu"],"title":"CF280C-Game on Tree","uri":"/posts/oi/problems/cf280c/#"},{"categories":null,"content":"CF19E-Fairy 题目: 题目描述: Once upon a time there lived a good fairy A. One day a fine young man B came to her and asked to predict his future. The fairy looked into her magic ball and said that soon the fine young man will meet the most beautiful princess ever and will marry her. Then she drew on a sheet of paper n n n points and joined some of them with segments, each of the segments starts in some point and ends in some other point. Having drawn that picture, she asked the young man to erase one of the segments from the sheet. Then she tries to colour each point red or blue so, that there is no segment having points of the same colour as its ends. If she manages to do so, the prediction will come true. B wants to meet the most beautiful princess, that’s why he asks you to help him. Find all the segments that will help him to meet the princess. 输入格式: The first input line contains two integer numbers: n n n — amount of the drawn points and m m m — amount of the drawn segments ( 1\u003c=n\u003c=104,0\u003c=m\u003c=104 1\u003c=n\u003c=10^{4},0\u003c=m\u003c=10^{4} 1\u003c=n\u003c=104,0\u003c=m\u003c=104 ). The following m m m lines contain the descriptions of the segments. Each description contains two different space-separated integer numbers v v v , u u u ( 1\u003c=v\u003c=n,1\u003c=u\u003c=n 1\u003c=v\u003c=n,1\u003c=u\u003c=n 1\u003c=v\u003c=n,1\u003c=u\u003c=n ) — indexes of the points, joined by this segment. No segment is met in the description twice. 输出格式: In the first line output number k k k — amount of the segments in the answer. In the second line output k k k space-separated numbers — indexes of these segments in ascending order. Each index should be output only once. Segments are numbered from 1 in the input order. 样例: 样例输入1: 4 4 1 2 1 3 2 4 3 4 样例输出1: 4 1 2 3 4 样例输入2: 4 5 1 2 2 3 3 4 4 1 1 3 样例输出2: 1 5 思路: 实现: // Problem: CF19E Fairy // Contest: Luogu // URL: https://www.luogu.com.cn/problem/CF19E // Memory Limit: 250 MB // Time Limit: 1500 ms // Author: Ybw051114 // // Powered by CP Editor (https://cpeditor.org) #include \"ybwhead/ios.h\" const int maxn = 1e5 + 10; vector\u003cpair\u003cint, int\u003e\u003e e[maxn]; void add(int u, int v, int w) { e[u].pb(pii(v, w)); } int n, m; int vis[maxn]; int dis[maxn]; int cnt, sp, s[maxn]; int ee[maxn]; int dfs1(int u) { vis[u] = 1; for (auto v : e[u]) { if (!vis[v.first]) { dis[v.first] = dis[u] ^ 1; ee[v.second] = 1; dfs1(v.first); } else if (!ee[v.second]) { ee[v.second] = 1; if (dis[u] == dis[v.first]) { cnt++, s[u]++, s[v.first]--; sp = v.second; } else s[u]--, s[v.first]++; } } } int ans[maxn], tot; int dfs(int u) { vis[u] = 1; for (auto v : e[u]) { if (!vis[v.first]) { dfs(v.first); if (s[v.first] == cnt) ans[++tot] = v.second; s[u] += s[v.first]; } } } int main() { yin \u003e\u003e n \u003e\u003e m; for (int i = 1; i \u003c= m; i++) { int u, v; yin \u003e\u003e u \u003e\u003e v; add(u, v, i), add(v, u, i); } for (int i = 1; i \u003c= n; i++) if (!vis[i]) dfs1(i); if (!cnt) { yout \u003c\u003c m \u003c\u003c endl; for (int i = 1; i \u003c= m; i++) yout \u003c\u003c i \u003c\u003c \" \"; return 0; } memset(vis, 0, sizeof(vis)); for (int i = 1; i \u003c= n; i++) if (!vis[i]) dfs(i); // cout \u003c\u003c cnt \u003c\u003c endl; if (cnt == 1) ans[++tot] = sp; sort(ans + 1, ans + tot + 1); yout \u003c\u003c tot \u003c\u003c endl; for (int i = 1; i \u003c= tot; i++) { yout \u003c\u003c ans[i] \u003c\u003c \" \"; } return 0; } ","date":"2021-01-06","objectID":"/posts/oi/problems/cf19e/:0:0","series":null,"tags":["二分图","最近公共祖先,LCA","差分","Notebooks/OI/OJ/Luogu"],"title":"CF19E-Fairy","uri":"/posts/oi/problems/cf19e/#"},{"categories":null,"content":"CF455D-Serega and Fun 题目: 题目描述: Serega loves fun. However, everyone has fun in the unique manner. Serega has fun by solving query problems. One day Fedor came up with such a problem. You are given an array a a a consisting of n n n positive integers and queries to it. The queries can be of two types: Make a unit cyclic shift to the right on the segment from l l l to r r r (both borders inclusive). That is rearrange elements of the array in the following manner: a[l],a[l+1],...,a[r−1],a[r]→a[r],a[l],a[l+1],...,a[r−1]. a[l],a[l+1],...,a[r-1],a[r]→a[r],a[l],a[l+1],...,a[r-1]. a[l],a[l+1],...,a[r−1],a[r]→a[r],a[l],a[l+1],...,a[r−1]. Count how many numbers equal to k k k are on the segment from l l l to r r r (both borders inclusive). Fedor hurried to see Serega enjoy the problem and Serega solved it really quickly. Let’s see, can you solve it? 输入格式: The first line contains integer n n n ( 1\u003c=n\u003c=105 1\u003c=n\u003c=10^{5} 1\u003c=n\u003c=105 ) — the number of elements of the array. The second line contains n n n integers a[1],a[2],...,a[n] a[1],a[2],...,a[n] a[1],a[2],...,a[n] ( 1\u003c=a[i]\u003c=n 1\u003c=a[i]\u003c=n 1\u003c=a[i]\u003c=n ). The third line contains a single integer q q q ( 1\u003c=q\u003c=105 1\u003c=q\u003c=10^{5} 1\u003c=q\u003c=105 ) — the number of queries. The next q q q lines contain the queries. As you need to respond to the queries online, the queries will be encoded. A query of the first type will be given in format: 1 1 1 li′ l'_{i} li′​ ri′ r'_{i} ri′​ . A query of the second type will be given in format: 2 2 2 li′ l'_{i} li′​ ri′ r'_{i} ri′​ ki′ k'_{i} ki′​ . All the number in input are integer. They satisfy the constraints: 1\u003c=li′,ri′,ki′\u003c=n 1\u003c=l'_{i},r'_{i},k'_{i}\u003c=n 1\u003c=li′​,ri′​,ki′​\u003c=n . To decode the queries from the data given in input, you need to perform the following transformations: l_{i}=((l'_{i}+lastans-1) mod n)+1; r_{i}=((r'_{i}+lastans-1) mod n)+1; k_{i}=((k'_{i}+lastans-1) mod n)+1. Where lastans lastans lastans is the last reply to the query of the 2-nd type (initially, lastans=0 lastans=0 lastans=0 ). If after transformation li l_{i} li​ is greater than ri r_{i} ri​ , you must swap these values. 输出格式: For each query of the 2-nd type print the answer on a single line. 样例: 样例输入1: 7 6 6 2 7 4 2 5 7 1 3 6 2 2 4 2 2 2 4 7 2 2 2 5 1 2 6 1 1 4 2 1 7 3 样例输出1: 2 1 0 0 样例输入2: 8 8 4 2 2 7 7 8 8 8 1 8 8 2 8 1 7 1 8 1 1 7 3 2 8 8 3 1 1 4 1 2 7 1 4 5 样例输出2: 2 0 思路: 实现: // Problem: CF455D Serega and Fun // Contest: Luogu // URL: https://www.luogu.com.cn/problem/CF455D // Memory Limit: 250 MB // Time Limit: 4000 ms // Author: Ybw051114 // // Powered by CP Editor (https://cpeditor.org) #include \"ybwhead/ios.h\" int s, n, q; const int maxb = 355, maxn = 1e5 + 5; deque\u003cint\u003e a[maxb]; int ans; void di(int \u0026x) { x = (x + ans - 1) % n + 1; } int c[maxb][maxn]; int main() { yin \u003e\u003e n; s = sqrt(n); for (int i = 0; i \u003c n; i++) { int x; yin \u003e\u003e x; a[i / s].push_back(x); c[i / s][x]++; } yin \u003e\u003e q; while (q--) { int opt, x, l, r; yin \u003e\u003e opt \u003e\u003e l \u003e\u003e r; di(l), di(r); if (l \u003e r) swap(l, r); l--; int L = l / s, R = r / s; // cerr \u003c\u003c l \u003c\u003c \" \" \u003c\u003c r \u003c\u003c \" \" \u003c\u003c L \u003c\u003c \" \" \u003c\u003c R \u003c\u003c endl; if (opt == 2) { int k; yin \u003e\u003e k; di(k); ans = 0; if (L == R) for (int i = l % s; i \u003c r % s; i++) ans += a[L][i] == k; else { for (int i = L + 1; i \u003c R; i++) { ans += c[i][k]; } for (int i = l % s; i \u003c a[L].size(); i++) { ans += a[L][i] == k; } for (int i = 0; i \u003c r % s; i++) { ans += a[R][i] == k; } } yout \u003c\u003c ans \u003c\u003c endl; } else { if (L == R) { r = r % s - 1, x = a[R][r]; a[R].erase(a[R].begin() + r); a[L].insert(a[L].begin() + l % s, x); } else { for (int i = L; i \u003c R;) { x = a[i].back(), a[i].pop_back(); c[i][x]--; i++; a[i].push_front(x), c[i][x]++; } r = r % s, x = a[R][r]; a[R].erase(a[R].begin() + r); c[R][x]--; a[L].insert(a[L].begin() + l % s, x); c[L][x]++; } } } return 0; } ","date":"2021-01-05","objectID":"/posts/oi/problems/cf455d/:0:0","series":null,"tags":["Notebooks/OI/OJ/Luogu"],"title":"CF455D-Serega and Fun","uri":"/posts/oi/problems/cf455d/#"},{"categories":null,"content":"P3181-[HAOI2016]找相同字符 题目: 题目描述: 给定两个字符串，求出在两个字符串中各取出一个子串使得这两个子串相同的方案数。两个方案不同当且仅当这两个子串中有一个位置不同。 输入格式: 两行，两个字符串s1，s2，长度分别为n1，n2。1 \u003c=n1, n2\u003c= 200000，字符串中只有小写字母 输出格式: 输出一个整数表示答案 样例: 样例输入1: aabb bbaa 样例输出1: 10 思路: 实现: // Problem: P3181 [HAOI2016]找相同字符 // Contest: Luogu // URL: https://www.luogu.com.cn/problem/P3181 // Memory Limit: 125 MB // Time Limit: 1000 ms // Author: Ybw051114 // // Powered by CP Editor (https://cpeditor.org) #include \"ybwhead/SAM.h\" #include \"ybwhead/ios.h\" CPTH::SAM\u003c\u003e x; long long ans, ans1; const int maxn = 8e5; int cnt[maxn], c[maxn], a[maxn]; void solve(int d, const string \u0026s) { x.clear(); memset(cnt, 0, sizeof(cnt)); memset(c, 0, sizeof(c)); int n = s.size(); for (auto c : s) cnt[x.append(c)] = 1; // x = CPTH::SAM\u003c\u003e(s); ans1 = 0; for (int i = 1; i \u003c x.size(); i++) c[x[i].len]++; for (int i = 1; i \u003c x.size(); i++) c[i] += c[i - 1]; for (int i = 1; i \u003c x.size(); i++) a[c[x[i].len]--] = i; for (int i = x.size() - 1; i; i--) { int p = a[i]; // cerr \u003c\u003c i \u003c\u003c \" \" \u003c\u003c a[i] \u003c\u003c endl; cnt[x[p].pa] += cnt[p]; ans1 += (ll)(x[p].len - x[x[p].pa].len) * cnt[p] * (n - cnt[p]); } if (d == -1) ans -= (ll)n * (n + 1) * (n - 1) / 2 - ans1; else ans += (ll)n * (n + 1) * (n - 1) / 2 - ans1; } int main() { string s, s1, s2; yin \u003e\u003e s \u003e\u003e s1; cerr \u003c\u003c 111 \u003c\u003c endl; s2 = s + \"~\" + s1; cerr \u003c\u003c 111 \u003c\u003c endl; reverse(s.begin(), s.end()); cerr \u003c\u003c 111 \u003c\u003c endl; reverse(s1.begin(), s1.end()); cerr \u003c\u003c 111 \u003c\u003c endl; reverse(s2.begin(), s2.end()); cerr \u003c\u003c 111 \u003c\u003c endl; solve(1, s2); solve(-1, s); solve(-1, s1); yout \u003c\u003c ans / 2 \u003c\u003c endl; return 0; } ","date":"2021-01-02","objectID":"/posts/oi/problems/p3181/:0:0","series":null,"tags":["字符串",2016,"河南","后缀数组,SA","高性能","Notebooks/OI/OJ/Luogu"],"title":"P3181-[HAOI2016]找相同字符","uri":"/posts/oi/problems/p3181/#"},{"categories":null,"content":"P4248-[AHOI2013]差异 题目: 题目描述: 给定一个长度为 nnn 的字符串 SSS，令 TiT_iTi​ 表示它从第 iii 个字符开始的后缀。求 ∑1⩽i\u003cj⩽nlen(Ti)+len(Tj)−2×lcp(Ti,Tj)\\displaystyle \\sum_{1\\leqslant i\u003cj\\leqslant n}\\text{len}(T_i)+\\text{len}(T_j)-2\\times\\text{lcp}(T_i,T_j)1⩽i\u003cj⩽n∑​len(Ti​)+len(Tj​)−2×lcp(Ti​,Tj​) 其中，len(a)\\text{len}(a)len(a) 表示字符串 aaa 的长度，lcp(a,b)\\text{lcp}(a,b)lcp(a,b) 表示字符串 aaa 和字符串 bbb 的最长公共前缀。 输入格式: 一行，一个字符串 SSS。 输出格式: 一行，一个整数，表示所求值。 样例: 样例输入1: cacao 样例输出1: 54 思路: 实现: // Problem: P4248 [AHOI2013]差异 // Contest: Luogu // URL: https://www.luogu.com.cn/problem/P4248 // Memory Limit: 500 MB // Time Limit: 2000 ms // Author: Ybw051114 // // Powered by CP Editor (https://cpeditor.org) #include \"ybwhead/SAM.h\" #include \"ybwhead/ios.h\" CPTH::SAM\u003c\u003e x; long long ans = 0; const int maxn = 1e6 + 10; int cnt[maxn]; int main() { string s; yin \u003e\u003e s; int n = s.size(); reverse(s.begin(), s.end()); for (auto c : s) cnt[x.append(c)] = 1; // x = CPTH::SAM\u003c\u003e(s); x.buildTree(); function\u003cvoid(int)\u003e dfs1 = [\u0026](int u) { for (auto v : x.children(u)) { dfs1(v); cnt[u] += cnt[v]; ans += (ll)(x[v].len - x[u].len) * cnt[v] * (n - cnt[v]); // yout \u003c\u003c x[v].len \u003c\u003c \" \" \u003c\u003c x[u].len \u003c\u003c endl; } }; dfs1(0); yout \u003c\u003c ans \u003c\u003c endl; return 0; } ","date":"2021-01-02","objectID":"/posts/oi/problems/p4248/:0:0","series":null,"tags":[2013,"各省省选","安徽","后缀自动机,SAM","后缀数组,SA","后缀树","Notebooks/OI/OJ/Luogu"],"title":"P4248-[AHOI2013]差异","uri":"/posts/oi/problems/p4248/#"},{"categories":null,"content":"P3763-[TJOI2017]DNA 题目: 题目描述: 加里敦大学的生物研究所，发现了决定人喜不喜欢吃藕的基因序列 SSS,有这个序列的碱基序列就会表现出喜欢吃藕的性状，但是研究人员发现对碱基序列 SSS，任意修改其中不超过 333 个碱基，依然能够表现出吃藕的性状。现在研究人员想知道这个基因在 DNA 链 S0S_0S0​ 上的位置。所以你需要统计在一个表现出吃藕性状的人的 DNA 序列 S0S_0S0​ 上，有多少个连续子串可能是该基因，即有多少个 S0S_0S0​ 的连续子串修改小于等于三个字母能够变成 SSS。 输入格式: 第一行有一个整数 TTT，表示有几组数据。 每组数据第一行一个长度不超过 10510^5105 的碱基序列 S0S_0S0​。 每组数据第二行一个长度不超过 10510^5105 的吃藕基因序列 SSS。 输出格式: 共 TTT 行，第 iii 行表示第 iii 组数据中，在 S0S_0S0​中有多少个与 SSS 等长的连续子串可能是表现吃藕性状的碱基序列。 样例: 样例输入1: 1 ATCGCCCTA CTTCA 样例输出1: 2 思路: 实现: // Problem: P3763 [TJOI2017]DNA // Contest: Luogu // URL: https://www.luogu.com.cn/problem/P3763 // Memory Limit: 125 MB // Time Limit: 1000 ms // Author: Ybw051114 // // Powered by CP Editor (https://cpeditor.org) #include \"ybwhead/SAM.h\" #include \"ybwhead/ios.h\" CPTH::SAM\u003cchar\u003e x; string s, s1; const char xx[5] = {'A', 'C', 'G', 'T'}; long long ans; const int maxn = 2e5 + 10; int cnt[maxn]; int m; void dfs(register int u, register int len, register int pp) { // yout \u003c\u003c u \u003c\u003c \" \" \u003c\u003c len \u003c\u003c \" \" \u003c\u003c pp \u003c\u003c endl; if (len \u003e m) return (void)(ans += cnt[u]); CPTH::SAM\u003cchar\u003e::SAMNode xxx = x[u]; for (register int i = 0; i \u003c 4; ++i) { if (!xxx[xx[i]]) continue; if (s1[len - 1] == xx[i]) dfs((int)xxx[xx[i]], len + 1, pp); else if (pp \u003c 3) dfs((int)xxx[xx[i]], len + 1, pp + 1); } } int main() { int TTT; yin \u003e\u003e TTT; while (TTT--) { yin \u003e\u003e s \u003e\u003e s1; m = s1.size(); x.clear(); memset(cnt, 0, sizeof(cnt)); for (auto c : s) cnt[x.append(c)] = 1; // x = CPTH::SAM\u003c\u003e(s); x.buildTree(); function\u003cvoid(int)\u003e dfs1 = [\u0026](int u) { for (auto v : x.children(u)) { dfs1(v); cnt[u] += cnt[v]; } }; dfs1(0); ans = 0; dfs(0, 1, 0); yout \u003c\u003c ans \u003c\u003c endl; } return 0; } ","date":"2021-01-02","objectID":"/posts/oi/problems/p3763/:0:0","series":null,"tags":[2017,"各省省选","RMQ","后缀数组,SA","快速傅里叶变换,DFT,FFT","高性能","天津","Notebooks/OI/OJ/Luogu"],"title":"P3763-[TJOI2017]DNA","uri":"/posts/oi/problems/p3763/#"},{"categories":null,"content":"P3988-[SHOI2013]发牌 题目: 题目描述: 在一些扑克游戏里，如德州扑克，发牌是有讲究的。一般称呼专业的发牌手为荷官。荷官在发牌前，先要销牌（burn card）。所谓销牌，就是把当前在牌库顶的那一张牌移动到牌库底，它用来防止玩家猜牌而影响游戏。 假设一开始，荷官拿出了一副新牌，这副牌有 NNN 张不同的牌，编号依次为 111 到 NNN。由于是新牌，所以牌是按照顺序排好的，从牌库顶开始，依次为 1,2,⋯ ,N1,2,\\cdots,N1,2,⋯,N，NNN 号牌在牌库底。为了发完所有的牌，荷官会进行 NNN 次发牌操作，在第 iii 次发牌之前，他会连续进行 RiR_iRi​ 次销牌操作，RiR_iRi​ 由输入给定。请问最后玩家拿到这副牌的顺序是什么样的？ 举个例子，假设 N=4N=4N=4，则一开始的时候，牌库中牌的构成顺序为 1,2,3,41,2,3,41,2,3,4。 假设 R1=2R_1=2R1​=2，则荷官应该连销两次牌，将 111 和 222 放入牌库底，再将 333 发给玩家。目前牌库中的牌顺序为 4,1,24,1,24,1,2。 假设 R2=0R_2=0R2​=0，荷官不需要销牌，直接将 444 发给玩家，目前牌库中的牌顺序为 1,21,21,2。 假设 R3=3R_3=3R3​=3，则荷官依次销去了 1,2,11,2,11,2,1，再将 222 发给了玩家。目前牌库仅剩下一张牌 111。 假设 R4=2R_4=2R4​=2，荷官在重复销去两次 111 之后，还是将 111 发给了玩家，这是因为 111 是牌库中唯一的一张牌。 输入格式: 第一行，一个整数 NNN，表示牌的数量。 第二行到第 N+1N+1N+1 行，在第 i+1i+1i+1 行，有一个整数 RiR_iRi​。 输出格式: 共 NNN 行，第 iii 行有一个整数，表示玩家收到的第 iii 张牌的编号。 样例: 样例输入1: 4 2 0 3 2 样例输出1: 3 4 2 1 思路: 实现: // Problem: P3988 [SHOI2013]发牌 // Contest: Luogu // URL: https://www.luogu.com.cn/problem/P3988 // Memory Limit: 125 MB // Time Limit: 1000 ms // Author: Ybw051114 // // Powered by CP Editor (https://cpeditor.org) #include \"ybwhead/BIT.h\" #include \"ybwhead/ios.h\" CPTH::BIT\u003cint\u003e x; int add(const int \u0026x, const int \u0026y) { return x + y; } const int maxn = 7e5 + 10; int pre[maxn], nxt[maxn]; int n; inline int search(int l, int r, int sum) { int ret = 0; while (l \u003c= r) { int mid = l + r \u003e\u003e 1; if (x.query(mid) \u003e= sum) ret = mid, r = mid - 1; else l = mid + 1; } return ret; } int main() { yin \u003e\u003e n; for (int i = 1; i \u003c= n; ++i) pre[i] = i - 1, nxt[i] = i + 1; x.init(n, add, 0); pre[1] = n, nxt[n] = 1; for (int i = 1; i \u003c= n; i++) x.add(i, 1); int p = 1; for (int i = n; i \u003e= 1; i--) { int xx; yin \u003e\u003e xx; xx %= i; ++xx; int sum = x.query(n) - x.query(p - 1); if (xx \u003e sum) yout \u003c\u003c (p = search(1, p - 1, xx - sum)) \u003c\u003c endl; else yout \u003c\u003c (p = search(p, n, xx + x.query(p - 1))) \u003c\u003c endl; pre[nxt[p]] = pre[p]; nxt[pre[p]] = nxt[p]; x.add(p, -1); p = nxt[p]; } return 0; } ","date":"2021-01-02","objectID":"/posts/oi/problems/p3988/:0:0","series":null,"tags":["模拟",2013,"线段树","各省省选","平衡树","树状数组","上海","主席树","高性能","Notebooks/OI/OJ/Luogu"],"title":"P3988-[SHOI2013]发牌","uri":"/posts/oi/problems/p3988/#"},{"categories":null,"content":"SP8222-NSUBSTR - Substrings 题目: 题目描述: You are given a string S which consists of 250000 lowercase latin letters at most. We define F(x) as the maximal number of times that some string with length x appears in S. For example for string ‘ababa’ F(3) will be 2 because there is a string ‘aba’ that occurs twice. Your task is to output F(i) for every i so that 1\u003c=i\u003c=|S|. 输入格式: String S consists of at most 250000 lowercase latin letters. 输出格式: Output |S| lines. On the i-th line output F(i). 样例: 样例输入1: ababa 样例输出1: 3 2 2 1 1 思路: 实现: // Problem: SP8222 NSUBSTR - Substrings // Contest: Luogu // URL: https://www.luogu.com.cn/problem/SP8222 // Memory Limit: 1.46 MB // Time Limit: 149 ms // Author: Ybw051114 // // Powered by CP Editor (https://cpeditor.org) #include \"ybwhead/ios.h\" int n, nl; const int maxn = 3 * 1e6 + 100; char s[maxn]; int ans[maxn]; struct sam { int mp[maxn][26]; struct edge { int nxt, v; } e[maxn]; int tot, cnt, las, len[maxn], head[maxn], siz[maxn], fa[maxn]; void add(int u, int v) { e[++tot].v = v; e[tot].nxt = head[u]; head[u] = tot; } void ins(int c) { int p = las; siz[las = ++cnt] = 1; len[las] = nl; for (; p \u0026\u0026 mp[p][c] == 0; p = fa[p]) { mp[p][c] = las; } if (p == 0) { fa[las] = 1; return; } int q = mp[p][c]; if (len[p] + 1 == len[q]) { fa[las] = q; return; } len[++cnt] = len[p] + 1; for (int i = 0; i \u003c 26; i++) { mp[cnt][i] = mp[q][i]; } fa[cnt] = fa[q]; fa[q] = cnt; fa[las] = cnt; for (int i = p; mp[i][c] == q; i = fa[i]) { mp[i][c] = cnt; } } inline void jt() { for (int i = 2; i \u003c= cnt; i++) { add(fa[i], i); } } void dfs(int u) { for (int i = head[u]; i; i = e[i].nxt) { dfs(e[i].v); siz[u] += siz[e[i].v]; } // if (siz[u] != 1) { ans[len[u]] = max(ans[len[u]], siz[u]); } } } sam; int main() { cerr \u003c\u003c \"!!!\" \u003c\u003c endl; scanf(\"%s\", s + 1); n = strlen(s + 1); sam.cnt = sam.las = 1; for (nl = 1; nl \u003c= n; nl++) sam.ins(s[nl] - 'a'); sam.jt(); sam.dfs(1); for (int i = 1; i \u003c= n; i++) yout \u003c\u003c ans[i] \u003c\u003c endl; return 0; } ","date":"2021-01-01","objectID":"/posts/oi/problems/sp8222/:0:0","series":null,"tags":["Notebooks/OI/OJ/Luogu"],"title":"SP8222-NSUBSTR - Substrings","uri":"/posts/oi/problems/sp8222/#"},{"categories":null,"content":"SP705-SUBST1 - New Distinct Substrings 题目: 题目描述: Given a string, we need to find the total number of its distinct substrings. 输入格式: T- number of test cases. T\u003c=20; Each test case consists of one string, whose length is \u003c= 50000 输出格式: For each test case output one number saying the number of distinct substrings. 样例: 样例输入1: 2 CCCCC ABABA 样例输出1: 5 9 思路: 实现: // Problem: SP705 SUBST1 - New Distinct Substrings // Contest: Luogu // URL: https://www.luogu.com.cn/problem/SP705 // Memory Limit: 1.46 MB // Time Limit: 280 ms // Author: Ybw051114 // // Powered by CP Editor (https://cpeditor.org) #include \"ybwhead/ios.h\" const int maxn = 5e4 + 10; char s[maxn]; int sa[maxn], rnk[maxn], tp[maxn]; int n, m; int h[maxn]; int height[maxn]; void Tsort() { for (int i = 0; i \u003c= m; i++) h[i] = 0; for (int i = 1; i \u003c= n; i++) h[rnk[i]]++; for (int i = 1; i \u003c= m; i++) h[i] += h[i - 1]; for (int i = n; i; i--) sa[h[rnk[tp[i]]]--] = tp[i]; } void Ssort() { m = 256; for (int i = 1; i \u003c= n; i++) rnk[i] = s[i], tp[i] = i; Tsort(); for (int w = 1, p = 0; p \u003c n; w \u003c\u003c= 1, m = p) { p = 0; for (int i = 1; i \u003c= w; i++) tp[++p] = n - w + i; for (int i = 1; i \u003c= n; i++) if (sa[i] \u003e w) tp[++p] = sa[i] - w; Tsort(); for (int i = 1; i \u003c= n; i++) tp[i] = rnk[i]; rnk[sa[1]] = p = 1; for (int i = 2; i \u003c= n; i++) rnk[sa[i]] = (tp[sa[i]] == tp[sa[i - 1]] \u0026\u0026 tp[sa[i] + w] == tp[sa[i - 1] + w]) ? p : ++p; } } void Gh() { int j, k; j = k = 0; for (int i = 1; i \u003c= n; height[rnk[i++]] = k) for (k = k ? k - 1 : k, j = sa[rnk[i] - 1]; s[i + k] == s[j + k]; k++) ; } void solve() { memset(h, 0, sizeof(h)); memset(tp, 0, sizeof(h)); memset(rnk, 0, sizeof(h)); memset(height, 0, sizeof(h)); Ssort(); Gh(); long long ans = (long long)(n + 1) * n / 2; for (int i = 1; i \u003c= n; i++) ans -= height[i]; yout \u003c\u003c ans \u003c\u003c endl; } int main() { int TTT; yin \u003e\u003e TTT; while (TTT--) { cin \u003e\u003e (s + 1); n = strlen(s + 1); solve(); } return 0; } ","date":"2020-12-30","objectID":"/posts/oi/problems/sp705/:0:0","series":null,"tags":["后缀数组,SA","构造","Notebooks/OI/OJ/Luogu"],"title":"SP705-SUBST1 - New Distinct Substrings","uri":"/posts/oi/problems/sp705/#"},{"categories":null,"content":"SP694-DISUBSTR - Distinct Substrings 题目: 题目描述: Given a string, we need to find the total number of its distinct substrings. 输入格式: T- number of test cases. T\u003c=20; Each test case consists of one string, whose length is \u003c= 1000 输出格式: For each test case output one number saying the number of distinct substrings. 样例: 样例输入1: 2 CCCCC ABABA 样例输出1: 5 9 思路: 实现: // Problem: SP694 DISUBSTR - Distinct Substrings // Contest: Luogu // URL: https://www.luogu.com.cn/problem/SP694 // Memory Limit: 1.46 MB // Time Limit: 500 ms // Author: Ybw051114 // // Powered by CP Editor (https://cpeditor.org) #include \"ybwhead/ios.h\" const int maxn = 5e4 + 10; char s[maxn]; int sa[maxn], rnk[maxn], tp[maxn]; int n, m; int h[maxn]; int height[maxn]; void Tsort() { for (int i = 0; i \u003c= m; i++) h[i] = 0; for (int i = 1; i \u003c= n; i++) h[rnk[i]]++; for (int i = 1; i \u003c= m; i++) h[i] += h[i - 1]; for (int i = n; i; i--) sa[h[rnk[tp[i]]]--] = tp[i]; } void Ssort() { m = 256; for (int i = 1; i \u003c= n; i++) rnk[i] = s[i], tp[i] = i; Tsort(); for (int w = 1, p = 0; p \u003c n; w \u003c\u003c= 1, m = p) { p = 0; for (int i = 1; i \u003c= w; i++) tp[++p] = n - w + i; for (int i = 1; i \u003c= n; i++) if (sa[i] \u003e w) tp[++p] = sa[i] - w; Tsort(); for (int i = 1; i \u003c= n; i++) tp[i] = rnk[i]; rnk[sa[1]] = p = 1; for (int i = 2; i \u003c= n; i++) rnk[sa[i]] = (tp[sa[i]] == tp[sa[i - 1]] \u0026\u0026 tp[sa[i] + w] == tp[sa[i - 1] + w]) ? p : ++p; } } void Gh() { int j, k; j = k = 0; for (int i = 1; i \u003c= n; height[rnk[i++]] = k) for (k = k ? k - 1 : k, j = sa[rnk[i] - 1]; s[i + k] == s[j + k]; k++) ; } void solve() { memset(h, 0, sizeof(h)); memset(tp, 0, sizeof(h)); memset(rnk, 0, sizeof(h)); memset(height, 0, sizeof(h)); Ssort(); Gh(); long long ans = (long long)(n + 1) * n / 2; for (int i = 1; i \u003c= n; i++) ans -= height[i]; yout \u003c\u003c ans \u003c\u003c endl; } int main() { int TTT; yin \u003e\u003e TTT; while (TTT--) { cin \u003e\u003e (s + 1); n = strlen(s + 1); solve(); } return 0; } ","date":"2020-12-30","objectID":"/posts/oi/problems/sp694/:0:0","series":null,"tags":["容斥","后缀数组,SA","Notebooks/OI/OJ/Luogu"],"title":"SP694-DISUBSTR - Distinct Substrings","uri":"/posts/oi/problems/sp694/#"},{"categories":null,"content":"CF1458E-Nim Shortcuts 题目: 题目描述: After your debut mobile game “Nim” blew up, you decided to make a sequel called “Nim 2”. This game will expand on the trusted Nim game formula, adding the much awaited second heap! In the game, there are two heaps, each containing a non-negative number of stones. Two players make moves in turn. On their turn, a player can take any positive number of stones from either one of the heaps. A player who is unable to move loses the game. To make the game easier to playtest, you’ve introduced developer shortcuts. There are n n n shortcut positions (x1,y1),…,(xn,yn) (x_1, y_1), \\ldots, (x_n, y_n) (x1​,y1​),…,(xn​,yn​) . These change the game as follows: suppose that before a player’s turn the first and second heap contain x x x and y y y stones respectively. If the pair (x,y) (x, y) (x,y) is equal to one of the pairs (xi,yi) (x_i, y_i) (xi​,yi​) , then the player about to move loses instantly, otherwise they are able to make moves as normal. Note that in the above explanation the two heaps and all pairs are ordered, that is, x x x must refer to the size of the first heap, and y y y must refer to the size of the second heap. The game release was followed by too much celebration, and next thing you know is developer shortcuts made their way to the next official update of the game! Players now complain that the AI opponent has become unbeatable at certain stages of the game. You now have to write a program to figure out which of the given initial positions can be won by the starting player, assuming both players act optimally. 输入格式: The first line contains two integers n n n and m m m ( 1≤n,m≤105 1 \\leq n, m \\leq 10^5 1≤n,m≤105 ) — the number of shortcut positions, and the number of initial positions that need to be evaluated. The following n n n lines describe shortcut positions. The i i i -th of these lines contains two integers xi,yi x_i, y_i xi​,yi​ ( 0≤xi,yi≤109 0 \\leq x_i, y_i \\leq 10^9 0≤xi​,yi​≤109 ). It is guaranteed that all shortcut positions are distinct. The following m m m lines describe initial positions. The i i i -th of these lines contains two integers ai,bi a_i, b_i ai​,bi​ ( 0≤ai,bi≤109 0 \\leq a_i, b_i \\leq 10^9 0≤ai​,bi​≤109 ) — the number of stones in the first and second heap respectively. It is guaranteed that all initial positions are distinct. However, initial positions are not necessarily distinct from shortcut positions. 输出格式: For each initial position, on a separate line print “WIN” if the starting player is able to win from this position, and “LOSE” otherwise. 样例: 样例输入1: 3 5 3 0 0 1 2 2 0 0 1 1 2 2 3 3 5 4 样例输出1: LOSE WIN LOSE WIN LOSE 思路: 实现: // Problem: CF1458E Nim Shortcuts // Contest: Luogu // URL: https://www.luogu.com.cn/problem/CF1458E // Memory Limit: 500 MB // Time Limit: 2000 ms // Author: Ybw051114 // // Powered by CP Editor (https://cpeditor.org) #include \"ybwhead/ios.h\" const int N = 1e5 + 3; struct node { int x, y, i; bool operator\u003c(node a) const { return x \u003c a.x || (x == a.x \u0026\u0026 (y \u003c a.y || (y == a.y \u0026\u0026 i \u003c a.i))); } } p[N * 2]; bool ans[N]; int a[N], t, s[N]; bool f[N]; void add(int x) { for (; x \u003c= t; x += x \u0026 -x) ++s[x]; } int sum(int x) { int r = 0; for (; x; x -= x \u0026 -x) r += s[x]; return r; } int main() { int n, m, o, i, u = 0, d, h = -1, y, z; yin \u003e\u003e n \u003e\u003e m; o = n + m; for (i = 1; i \u003c= n; ++i) yin \u003e\u003e p[i].x \u003e\u003e p[i].y, a[i] = p[i].y; for (i = 1; i \u003c= m; ++i) yin \u003e\u003e p[i + n].x \u003e\u003e p[i + n].y, p[i + n].i = i; sort(p + 1, p + o + 1), sort(a + 1, a + n + 1), t = unique(a + 1, a + n + 1) - a - 1; for (i = 1; i \u003c= o; ++i) if (p[i].i) { //询问 if (!p[i - 1].i \u0026\u0026 p[i - 1].x == p[i].x \u0026\u0026 p[i - 1].y == p[i].y) ans[p[i].i] = 1; else if (p[i].x != h) { y = upper_bound(a + 1, a + t + 1, p[i].y) - a - 1; if ((p[i].y != a[y] || !f[y]) \u0026\u0026 p[i].y + u - sum(y) == p[i].x) ans[p[i].i] = 1; } } else { //shortcut y = lower_bound(a + 1, a + t + 1, p[i].y) - a, d = u - sum(y), z = p[i].x - p[i].y; if (z \u003c d) { if (!f[y]) f[y] = 1, add(y); } else if (z \u003e d \u0026\u0026 h != p[i].x) h = p[i].x, ","date":"2020-12-30","objectID":"/posts/oi/problems/cf1458e/:0:0","series":null,"tags":["Notebooks/OI/OJ/Luogu"],"title":"CF1458E-Nim Shortcuts","uri":"/posts/oi/problems/cf1458e/#"},{"categories":null,"content":"CF1458D-Flip and Reverse 题目: 题目描述: You are given a string s s s of 0’s and 1’s. You are allowed to perform the following operation: choose a non-empty contiguous substring of s s s that contains an equal number of 0’s and 1’s; flip all characters in the substring, that is, replace all 0’s with 1’s, and vice versa; reverse the substring. For example, consider s s s = 00111011, and the following operation: Choose the first six characters as the substring to act upon: 00111011. Note that the number of 0’s and 1’s are equal, so this is a legal choice. Choosing substrings 0, 110, or the entire string would not be possible. Flip all characters in the substring: 11000111. Reverse the substring: 10001111. Find the lexicographically smallest string that can be obtained from s s s after zero or more operations. 输入格式: The first line contains a single integer T T T ( 1≤T≤5⋅105 1 \\leq T \\leq 5 \\cdot 10^5 1≤T≤5⋅105 ) — the number of test cases. Each of the following T T T lines contains a single non-empty string — the input string s s s for the respective test case. All strings consist of characters 0 and 1, and their total length does not exceed 5⋅105 5 \\cdot 10^5 5⋅105 . 输出格式: For each test case, on a separate line print the lexicographically smallest string that can be obtained from s s s after zero or more operations. 样例: 样例输入1: 3 100101 1100011 10101010 样例输出1: 010110 0110110 10101010 思路: 考虑记 000 为 −1-1−1，111 为 +1+1+1，这样可以得到一个长度为 ∣s∣|s|∣s∣ 的由 +1+1+1 和 −1-1−1 组成的序列。 然后对这个序列做一遍前缀和，并连一条 si→si+1s_i\\to s_{i+1}si​→si+1​ 的有向边，这样可以得到一张图，一个欧拉回路就对应着一个字符串。 考虑题目中那个奇怪的操作的本质。假设我们对区间 [l,r][l,r][l,r] 进行操作。既然 [l,r][l,r][l,r] 要求 01 个数相等，那么肯定有 sl−1=srs_{l-1}=s_rsl−1​=sr​，而翻转+反转实际上等于将这些边反向。所以实际上该操作等价于选择一个环然后将环上所有边反向。 这里需要观察出一个性质：就是操作前后，原图所包含的边集 EEE 是不变的。因为每次操作是将边反向，所以如果把有向边改为无向边，那么边集显然是不变的。又由于我们操作的是一个环，所以对于一条边 (x,y)(x,y)(x,y)，x→yx\\to yx→y 和 y→xy\\to xy→x 的次数是一样的，所以 x→yx\\to yx→y 和 y→xy\\to xy→x 在操作前后出现次数都是相同的。 有了这个性质，我们还需观察出另一个性质：原图任意一条欧拉回路（起点和终点必须与初始相同）代表的都可以由原字符串进行一系列操作得到。这里楼下的题解没有给出证明，这里给出简略的证明：首先我们假设原路径与当前路径在 xxx 位置出现了分歧，一个走了 x→x+1x \\to x+1x→x+1 的边，一个走了 x→x−1x\\to x-1x→x−1 的边。而这两个路径终究还是要走 x→x−1x\\to x-1x→x−1 和 x→x+1x\\to x+1x→x+1 的边的，所以肯定有一条边 x+1→xx+1 \\to xx+1→x，也有一条边 x−1→xx-1\\to xx−1→x，此时我们选择 x→x−1→x→x+1→xx\\to x-1\\to x\\to x+1\\to xx→x−1→x→x+1→x，并将其翻转，看看会发生什么。此时我们惊奇地发现 ，原来先走 x→x−1x\\to x-1x→x−1 的路径改走 x→x+1x\\to x+1x→x+1 了！以此类推，最后两个路径一定会重合。 于是此题就变为：求字典序最小的欧拉序。直接贪心就可以了。能填 000 就填 000，不能就填 111。 实现: // Problem: CF1458D Flip and Reverse // Contest: Luogu // URL: https://www.luogu.com.cn/problem/CF1458D // Memory Limit: 500 MB // Time Limit: 2000 ms // Author: Ybw051114 // // Powered by CP Editor (https://cpeditor.org) #include \"ybwhead/ios.h\" map\u003cint, int\u003e cnt; int main() { int TTT; yin \u003e\u003e TTT; while (TTT--) { string s; yin \u003e\u003e s; int n = s.size(), p = 0; cnt.clear(); for (int i = 0; i \u003c n; i++) { if (s[i] == '1') { ++cnt[p++]; } else { ++cnt[--p]; } } p = 0; for (int i = 0; i \u003c n; i++) { if (cnt[p - 1] \u003e 0 \u0026\u0026 (!cnt[p] || cnt[p - 1] \u003e 1)) --p, cnt[p]--, putchar('0'); else cnt[p]--, p++, putchar('1'); } yout \u003c\u003c endl; } return 0; } ","date":"2020-12-29","objectID":"/posts/oi/problems/cf1458d/:0:0","series":null,"tags":["Notebooks/OI/OJ/Luogu","欧拉回路","思维","建图"],"title":"CF1458D-Flip and Reverse","uri":"/posts/oi/problems/cf1458d/#"},{"categories":null,"content":"CF1458C-Latin Square 题目: 题目描述: You are given a square matrix of size n n n . Every row and every column of this matrix is a permutation of 1 1 1 , 2 2 2 , … \\ldots … , n n n . Let ai,j a_{i, j} ai,j​ be the element at the intersection of i i i -th row and j j j -th column for every 1≤i,j≤n 1 \\leq i, j \\leq n 1≤i,j≤n . Rows are numbered 1,…,n 1, \\ldots, n 1,…,n top to bottom, and columns are numbered 1,…,n 1, \\ldots, n 1,…,n left to right. There are six types of operations: R: cyclically shift all columns to the right, formally, set the value of each ai,j a_{i, j} ai,j​ to ai,((j−2) mod n)+1 a_{i, ((j - 2)\\bmod n) + 1} ai,((j−2)modn)+1​ ; L: cyclically shift all columns to the left, formally, set the value of each ai,j a_{i, j} ai,j​ to ai,(j mod n)+1 a_{i, (j\\bmod n) + 1} ai,(jmodn)+1​ ; D: cyclically shift all rows down, formally, set the value of each ai,j a_{i, j} ai,j​ to a((i−2) mod n)+1,j a_{((i - 2)\\bmod n) + 1, j} a((i−2)modn)+1,j​ ; U: cyclically shift all rows up, formally, set the value of each ai,j a_{i, j} ai,j​ to a(i mod n)+1,j a_{(i\\bmod n) + 1, j} a(imodn)+1,j​ ; I: replace the permutation read left to right in each row with its inverse. C: replace the permutation read top to bottom in each column with its inverse. Inverse of a permutation p1 p_1 p1​ , p2 p_2 p2​ , … \\ldots … , pn p_n pn​ is a permutation q1 q_1 q1​ , q2 q_2 q2​ , … \\ldots … , qn q_n qn​ , such that pqi=i p_{q_i} = i pqi​​=i for every 1≤i≤n 1 \\leq i \\leq n 1≤i≤n .One can see that after any sequence of operations every row and every column of the matrix will still be a permutation of 1,2,…,n 1, 2, \\ldots, n 1,2,…,n . Given the initial matrix description, you should process m m m operations and output the final matrix. 输入格式: The first line contains a single integer t t t ( 1≤t≤1000 1 \\leq t \\leq 1000 1≤t≤1000 ) — number of test cases. t t t test case descriptions follow. The first line of each test case description contains two integers n n n and m m m ( 1≤n≤1000,1≤m≤105 1 \\leq n \\leq 1000, 1 \\leq m \\leq 10^5 1≤n≤1000,1≤m≤105 ) — size of the matrix and number of operations. Each of the next n n n lines contains n n n integers separated by single spaces — description of the matrix a a a ( 1≤ai,j≤n 1 \\leq a_{i, j} \\leq n 1≤ai,j​≤n ). The last line of the description contains a string of m m m characters describing the operations in order, according to the format above. The sum of n n n does not exceed 1000 1000 1000 , and the sum of m m m does not exceed 105 10^5 105 . 输出格式: For each test case, print n n n lines with n n n integers each — the final matrix after m m m operations. 样例: 样例输入1: 5 3 2 1 2 3 2 3 1 3 1 2 DR 3 2 1 2 3 2 3 1 3 1 2 LU 3 1 1 2 3 2 3 1 3 1 2 I 3 1 1 2 3 2 3 1 3 1 2 C 3 16 1 2 3 2 3 1 3 1 2 LDICRUCILDICRUCI 样例输出1: 2 3 1 3 1 2 1 2 3 3 1 2 1 2 3 2 3 1 1 2 3 3 1 2 2 3 1 1 3 2 2 1 3 3 2 1 2 3 1 3 1 2 1 2 3 思路: 将一个点用(x,y,ax,y)(x,y,a_{x,y})(x,y,ax,y​)来表示，则U相当于y−1y-1y−1,D相当于y+1y+1y+1,L相当于x−1x-1x−1,R相当于x+1x+1x+1,I相当于交换x,ax,yx,a_{x,y}x,ax,y​,C相当于交换y,ax,yy,a_{x,y}y,ax,y​。 实现: // Problem: CF1458C Latin Square // Contest: Luogu // URL: https://www.luogu.com.cn/problem/CF1458C // Memory Limit: 500 MB // Time Limit: 2000 ms // Author: Ybw051114 // // Powered by CP Editor (https://cpeditor.org) #include \"ybwhead/ios.h\" int n, m; inline int ct(int x, int y) { return (x - 1) * (n) + y; } const int maxn = 5e3 + 10; int a[maxn * maxn][3], p[10], x[10]; int b[maxn][maxn]; int main() { int TTT; yin \u003e\u003e TTT; while (TTT--) { yin \u003e\u003e n \u003e\u003e m; for (int i = 1; i \u003c= n; i++) { for (int j = 1; j \u003c= n; j++) { yin \u003e\u003e a[ct(i, j)][2]; a[ct(i, j)][0] = i; a[ct(i, j)][1] = j; } } string s; yin \u003e\u003e s; for (int i = 0; i \u003c 3; i++) p[i] = i, x[i] = 0; for (int i = 0; i \u003c m; i++) { if (s[i] == 'L') --x[p[1]]; if (s[i] == 'R') ++x[p[1]]; if (s[i] == 'U') --x[p[0]]; if (s[i] == 'D') ++x[p[0]]; if (s[i] == 'I') swap(p[1], p[2]); if (s[i] == 'C') swap(p[0], p[2]); } for (int i = 1; i \u003c= n * n; i++) { for (int j = 0; j \u003c 3; j++) a[i][j] = (a[i][j] - 1 + x[j] % n + n) % n + 1;","date":"2020-12-29","objectID":"/posts/oi/problems/cf1458c/:0:0","series":null,"tags":["Notebooks/OI/OJ/Luogu","数学","思维"],"title":"CF1458C-Latin Square","uri":"/posts/oi/problems/cf1458c/#"},{"categories":null,"content":"CF1458B-Glass Half Spilled 题目: 题目描述: There are n n n glasses on the table numbered 1,…,n 1, \\ldots, n 1,…,n . The glass i i i can hold up to ai a_i ai​ units of water, and currently contains bi b_i bi​ units of water. You would like to choose k k k glasses and collect as much water in them as possible. To that effect you can pour water from one glass to another as many times as you like. However, because of the glasses’ awkward shape (and totally unrelated to your natural clumsiness), each time you try to transfer any amount of water, half of the amount is spilled on the floor. Formally, suppose a glass i i i currently contains ci c_i ci​ units of water, and a glass j j j contains cj c_j cj​ units of water. Suppose you try to transfer x x x units from glass i i i to glass j j j (naturally, x x x can not exceed ci c_i ci​ ). Then, x/2 x / 2 x/2 units is spilled on the floor. After the transfer is done, the glass i i i will contain ci−x c_i - x ci​−x units, and the glass j j j will contain min⁡(aj,cj+x/2) \\min(a_j, c_j + x / 2) min(aj​,cj​+x/2) units (excess water that doesn’t fit in the glass is also spilled). Each time you transfer water, you can arbitrarlly choose from which glass i i i to which glass j j j to pour, and also the amount x x x transferred can be any positive real number. For each k=1,…,n k = 1, \\ldots, n k=1,…,n , determine the largest possible total amount of water that can be collected in arbitrarily chosen k k k glasses after transferring water between glasses zero or more times. 输入格式: The first line contains a single integer n n n ( 1≤n≤100 1 \\leq n \\leq 100 1≤n≤100 ) — the number of glasses. The following n n n lines describe the glasses. The i i i -th of these lines contains two integers ai a_i ai​ and bi b_i bi​ ( 0≤bi≤ai≤100 0 \\leq b_i \\leq a_i \\leq 100 0≤bi​≤ai​≤100 , ai\u003e0 a_i \u003e 0 ai​\u003e0 ) — capacity, and water amount currently contained for the glass i i i , respectively. 输出格式: Print n n n real numbers — the largest amount of water that can be collected in 1,…,n 1, \\ldots, n 1,…,n glasses respectively. Your answer will be accepted if each number is within 10−9 10^{-9} 10−9 absolute or relative tolerance of the precise answer. 样例: 样例输入1: 3 6 5 6 5 10 2 样例输出1: 7.0000000000 11.0000000000 12.0000000000 思路: 实现: // Problem: CF1458B Glass Half Spilled // Contest: Luogu // URL: https://www.luogu.com.cn/problem/CF1458B // Memory Limit: 500 MB // Time Limit: 2000 ms // Author: Ybw051114 // // Powered by CP Editor (https://cpeditor.org) #include \"ybwhead/ios.h\" const int maxn = 100; int n, a[maxn + 5], b[maxn + 5], dp[maxn + 5][maxn + 5][maxn * maxn + 5]; void chkmax(int \u0026a, int b) { a = max(a, b); } signed main() { yin \u003e\u003e n; for (int i = 1; i \u003c= n; i++) yin \u003e\u003e a[i] \u003e\u003e b[i]; memset(dp, 128, sizeof(dp)); dp[0][0][0] = 0; for (int i = 0; i \u003c n; i++) for (int j = 0; j \u003c= i; j++) for (int k = 0; k \u003c= 10000; k++) { if (k + a[i] \u003c= 10000) chkmax(dp[i + 1][j + 1][k + a[i + 1]], dp[i][j][k] + b[i + 1] * 2); chkmax(dp[i + 1][j][k], dp[i][j][k] + b[i + 1]); } for (int i = 1; i \u003c= n; i++) { double ans = 0; for (int k = 0; k \u003c= 10000; k++) { ans = max(ans, min(1.0 * k, dp[n][i][k] / 2.0)); } yout \u003c\u003c ans \u003c\u003c \" \"; } return 0; } ","date":"2020-12-29","objectID":"/posts/oi/problems/cf1458b/:0:0","series":null,"tags":["Notebooks/OI/OJ/Luogu"],"title":"CF1458B-Glass Half Spilled","uri":"/posts/oi/problems/cf1458b/#"},{"categories":null,"content":"CF1458A-Row GCD 题目: 题目描述: You are given two positive integer sequences a1,…,an a_1, \\ldots, a_n a1​,…,an​ and b1,…,bm b_1, \\ldots, b_m b1​,…,bm​ . For each j=1,…,m j = 1, \\ldots, m j=1,…,m find the greatest common divisor of a1+bj,…,an+bj a_1 + b_j, \\ldots, a_n + b_j a1​+bj​,…,an​+bj​ . 输入格式: The first line contains two integers n n n and m m m ( 1≤n,m≤2⋅105 1 \\leq n, m \\leq 2 \\cdot 10^5 1≤n,m≤2⋅105 ). The second line contains n n n integers a1,…,an a_1, \\ldots, a_n a1​,…,an​ ( 1≤ai≤1018) 1 \\leq a_i \\leq 10^{18}) 1≤ai​≤1018) . The third line contains m m m integers b1,…,bm b_1, \\ldots, b_m b1​,…,bm​ ( 1≤bj≤1018) 1 \\leq b_j \\leq 10^{18}) 1≤bj​≤1018) . 输出格式: Print m m m integers. The j j j -th of them should be equal to GCD (a1+bj,…,an+bj) (a_1 + b_j, \\ldots, a_n + b_j) (a1​+bj​,…,an​+bj​) . 样例: 样例输入1: 4 4 1 25 121 169 1 2 7 23 样例输出1: 2 3 8 24 思路: 实现: // Problem: CF1458A Row GCD // Contest: Luogu // URL: https://www.luogu.com.cn/problem/CF1458A // Memory Limit: 500 MB // Time Limit: 2000 ms // Author: Ybw051114 // // Powered by CP Editor (https://cpeditor.org) #include \"ybwhead/ios.h\" long long n, m; const int maxn = 2e5 + 10; long long a[maxn]; long long gcd(long long a, long long b) { if (b == 0) return a; return gcd(b, a % b); } int main() { yin \u003e\u003e n \u003e\u003e m; for (int i = 1; i \u003c= n; i++) yin \u003e\u003e a[i]; long long gc = 0; for (int i = 2; i \u003c= n; i++) { gc = gcd(gc, abs(a[i] - a[i - 1])); } for (int i = 1; i \u003c= m; i++) { long long x; yin \u003e\u003e x; yout \u003c\u003c gcd(gc, x + a[1]) \u003c\u003c \" \"; } return 0; } ","date":"2020-12-29","objectID":"/posts/oi/problems/cf1458a/:0:0","series":null,"tags":["Notebooks/OI/OJ/Luogu"],"title":"CF1458A-Row GCD","uri":"/posts/oi/problems/cf1458a/#"},{"categories":null,"content":"SP6286-SUMMUL - Sum of products 题目: 题目描述: One boy Petya decided to practice in addition and multiplication of numbers. For this he chose some positive integer n, and ordered all the ways to decompose it into two or more terms of positive integers, and the ways in different order terms are considered to be different (for example, for n = 3 there are three ways: 1 + 2, 2 + 1 and 1 + 1 + 1). Then he replaced all the plus signs with multiplication, and added the results (for n = 3: 1 × 2 + 2 × 1 + 1 × 1 × 1 = 5). After practicing for the day he decided to check the correctness of his calculations. Help Petya find the right answers. 输入格式: The first line contains T (1 \u003c= T \u003c= 1000) - the number of tests. Following T lines contain n (1 \u003c= n \u003c= 10 ^ 9). 输出格式: For each n from the input print the result Petya should get modulo 1000000007. 样例: 样例输入1: 3 1 2 3 样例输出1: 0 1 5 思路: 实现: // Problem: SP6286 SUMMUL - Sum of products // Contest: Luogu // URL: https://www.luogu.com.cn/problem/SP6286 // Memory Limit: 1.46 MB // Time Limit: 170 ms // Author: Ybw051114 // // Powered by CP Editor (https://cpeditor.org) #include \"ybwhead/ios.h\" #define il inline #define mem(p) memset(\u0026p, 0, sizeof(p)) const ll mod = 1000000007; ll n, m; struct mat { ll a[3][3], r, c; }; il mat mul(mat x, mat y) { mat p; mem(p); for (int i = 0; i \u003c x.r; i++) for (int j = 0; j \u003c y.c; j++) for (int k = 0; k \u003c x.c; k++) p.a[i][j] = (p.a[i][j] + x.a[i][k] * y.a[k][j]) % mod; p.r = x.r, p.c = y.c; return p; } il void fast(ll k) { mat p, ans; mem(p), mem(ans); p.r = p.c = 2; p.a[0][0] = p.a[0][1] = p.a[1][0] = 1; p.a[1][1] = 2; ans.r = 2, ans.c = 2; ans.a[0][0] = ans.a[1][1] = 1; while (k) { if (k \u0026 1) ans = mul(ans, p); p = mul(p, p); k \u003e\u003e= 1; } p.r = 2; p.c = 1; p.a[0][0] = 0; p.a[1][0] = 1; ans = mul(ans, p); yout \u003c\u003c (ans.a[0][0] - n + mod) % mod \u003c\u003c endl; } il ll gcd(ll a, ll b) { return b ? gcd(b, a % b) : a; } int main() { int TTT; yin \u003e\u003e TTT; while (TTT--) { yin \u003e\u003e n; fast(n); } return 0; } ","date":"2020-12-28","objectID":"/posts/oi/problems/sp6286/:0:0","series":null,"tags":["Notebooks/OI/OJ/Luogu"],"title":"SP6286-SUMMUL - Sum of products","uri":"/posts/oi/problems/sp6286/#"},{"categories":null,"content":"CF1463F-Max Correct Set 题目: 题目描述: Let’s call the set of positive integers S S S correct if the following two conditions are met: S⊆{1,2,…,n} S \\subseteq \\{1, 2, \\dots, n\\} S⊆{1,2,…,n} ; if a∈S a \\in S a∈S and b∈S b \\in S b∈S , then ∣a−b∣≠x |a-b| \\neq x ∣a−b∣=x and ∣a−b∣≠y |a-b| \\neq y ∣a−b∣=y . For the given values n n n , x x x , and y y y , you have to find the maximum size of the correct set. 输入格式: A single line contains three integers n n n , x x x and y y y ( 1≤n≤109 1 \\le n \\le 10^9 1≤n≤109 ; 1≤x,y≤22 1 \\le x, y \\le 22 1≤x,y≤22 ). 输出格式: Print one integer — the maximum size of the correct set. 样例: 样例输入1: 10 2 5 样例输出1: 5 样例输入2: 21 4 6 样例输出2: 9 样例输入3: 1337 7 7 样例输出3: 672 样例输入4: 455678451 22 17 样例输出4: 221997195 思路: 实现: // Problem: CF1463F Max Correct Set // Contest: Luogu // URL: https://www.luogu.com.cn/problem/CF1463F // Memory Limit: 250 MB // Time Limit: 4000 ms // Author: Ybw051114 // // Powered by CP Editor (https://cpeditor.org) #include \"ybwhead/ios.h\" const int ImaxnF = 1e9; const int maxn = 22; int dp[2][1 \u003c\u003c maxn]; int val[2 * maxn]; int main() { int n, x, y; yin \u003e\u003e n \u003e\u003e x \u003e\u003e y; int k = x + y; int m = max(x, y); int FULL = (1 \u003c\u003c m) - 1; for (int i = 0; i \u003c k; ++i) val[i] = n / k + (i \u003c n % k); for (int mask = 0; mask \u003c (1 \u003c\u003c m); ++mask) dp[0][mask] = -ImaxnF; dp[0][0] = 0; for (int i = 0; i \u003c k; ++i) { for (int mask = 0; mask \u003c (1 \u003c\u003c m); ++mask) dp[1][mask] = -ImaxnF; for (int mask = 0; mask \u003c (1 \u003c\u003c m); ++mask) { if (dp[0][mask] == -ImaxnF) continue; int nmask = (mask \u003c\u003c 1) \u0026 FULL; dp[1][nmask] = max(dp[1][nmask], dp[0][mask]); if (((mask \u003e\u003e (x - 1)) \u0026 1) | ((mask \u003e\u003e (y - 1)) \u0026 1)) continue; nmask |= 1; dp[1][nmask] = max(dp[1][nmask], dp[0][mask] + val[i]); } swap(dp[0], dp[1]); } int ans = 0; for (int mask = 0; mask \u003c (1 \u003c\u003c m); ++mask) ans = max(ans, dp[0][mask]); yout \u003c\u003c ans \u003c\u003c endl; } ","date":"2020-12-26","objectID":"/posts/oi/problems/cf1463f/:0:0","series":null,"tags":["Notebooks/OI/OJ/Luogu"],"title":"CF1463F-Max Correct Set","uri":"/posts/oi/problems/cf1463f/#"},{"categories":null,"content":"CF1463E-Plan of Lectures 题目: 题目描述: Ivan is a programming teacher. During the academic year, he plans to give n n n lectures on n n n different topics. Each topic should be used in exactly one lecture. Ivan wants to choose which topic will he explain during the 1 1 1 -st, 2 2 2 -nd, …, n n n -th lecture — formally, he wants to choose some permutation of integers from 1 1 1 to n n n (let’s call this permutation q q q ). qi q_i qi​ is the index of the topic Ivan will explain during the i i i -th lecture. For each topic (except exactly one), there exists a prerequisite topic (for the topic i i i , the prerequisite topic is pi p_i pi​ ). Ivan cannot give a lecture on a topic before giving a lecture on its prerequisite topic. There exists at least one valid ordering of topics according to these prerequisite constraints. Ordering the topics correctly can help students understand the lectures better. Ivan has k k k special pairs of topics (xi,yi) (x_i, y_i) (xi​,yi​) such that he knows that the students will understand the yi y_i yi​ -th topic better if the lecture on it is conducted right after the lecture on the xi x_i xi​ -th topic. Ivan wants to satisfy the constraints on every such pair, that is, for every i∈[1,k] i \\in [1, k] i∈[1,k] , there should exist some j∈[1,n−1] j \\in [1, n - 1] j∈[1,n−1] such that qj=xi q_j = x_i qj​=xi​ and qj+1=yi q_{j + 1} = y_i qj+1​=yi​ . Now Ivan wants to know if there exists an ordering of topics that satisfies all these constraints, and if at least one exists, find any of them. 输入格式: The first line contains two integers n n n and k k k ( 2≤n≤3⋅105 2 \\le n \\le 3 \\cdot 10^5 2≤n≤3⋅105 , 1≤k≤n−1 1 \\le k \\le n - 1 1≤k≤n−1 ) — the number of topics and the number of special pairs of topics, respectively. The second line contains n n n integers p1 p_1 p1​ , p2 p_2 p2​ , …, pn p_n pn​ ( 0≤pi≤n 0 \\le p_i \\le n 0≤pi​≤n ), where pi p_i pi​ is the prerequisite topic for the topic i i i (or pi=0 p_i = 0 pi​=0 if the i i i -th topic has no prerequisite topics). Exactly one of these integers is 0 0 0 . At least one ordering of topics such that for every i i i the pi p_i pi​ -th topic is placed before the i i i -th topic exists. Then k k k lines follow, the i i i -th line contains two integers xi x_i xi​ and yi y_i yi​ ( 1≤xi,yi≤n 1 \\le x_i, y_i \\le n 1≤xi​,yi​≤n ; xi≠yi x_i \\ne y_i xi​=yi​ ) — the topics from the i i i -th special pair. All values of xi x_i xi​ are pairwise distinct; similarly, all valus of yi y_i yi​ are pairwise distinct. 输出格式: If there is no ordering of topics meeting all the constraints, print 0 0 0 . Otherwise, print n n n pairwise distinct integers q1 q_1 q1​ , q2 q_2 q2​ , …, qn q_n qn​ ( 1≤qi≤n 1 \\le q_i \\le n 1≤qi​≤n ) — the ordering of topics meeting all of the constraints. If there are multiple answers, print any of them. 样例: 样例输入1: 5 2 2 3 0 5 3 1 5 5 4 样例输出1: 3 2 1 5 4 样例输入2: 5 2 2 3 0 5 3 1 5 5 1 样例输出2: 0 样例输入3: 5 1 2 3 0 5 3 4 5 样例输出3: 0 样例输入4: 5 4 2 3 0 5 3 2 1 3 5 5 2 1 4 样例输出4: 3 5 2 1 4 思路: 实现: #include \"ybwhead/ios.h\" const int maxn = 300005; int p[maxn]; int find(int x) { return p[x] == x ? x : p[x] = find(p[x]); } int a[maxn], b[maxn], c[maxn], in[maxn], ans[maxn]; vector\u003cint\u003e G[maxn], H[maxn]; bool vis[maxn]; int main() { int n, m; yin \u003e\u003e n \u003e\u003e m; int root; for (int i = 1; i \u003c= n; i++) { int fa; yin \u003e\u003e fa; p[i] = i; if (fa == 0) root = i; else H[fa].push_back(i); } while (m--) { int x, y; yin \u003e\u003e x \u003e\u003e y; a[x] = y; b[y] = x; x = find(x), y = find(y); if (x == y) return puts(\"0\"), 0; p[x] = y; } for (int i = 1; i \u003c= n; i++) { if (b[i] == 0) c[find(i)] = i; // 起点 for (auto v : H[i]) { if (find(i) != find(v)) { G[find(i)].push_back(find(v)); in[find(v)]++; } } } queue\u003cint\u003e q; q.push(find(root)); int ct = 0; while (q.size()) { int u = q.front(); q.pop(); int t = c[u]; while (t) { ans[++ct] = t; t = a[t]; } for (auto v : G[u]) { in[v]--; if (in[v] == 0) { q.push(v); } } } if (ct != n) return puts(\"0\"), 0; vis[root] = 1; for (int i = 1; i \u003c= n; i++) { if (vis[ans[i]] == 0) return ","date":"2020-12-23","objectID":"/posts/oi/problems/cf1463e/:0:0","series":null,"tags":["Notebooks/OI/OJ/Luogu"],"title":"CF1463E-Plan of Lectures","uri":"/posts/oi/problems/cf1463e/#"},{"categories":null,"content":"CF1463D-Pairs 题目: 题目描述: You have 2n 2n 2n integers 1,2,…,2n 1, 2, \\dots, 2n 1,2,…,2n . You have to redistribute these 2n 2n 2n elements into n n n pairs. After that, you choose x x x pairs and take minimum elements from them, and from the other n−x n - x n−x pairs, you take maximum elements. Your goal is to obtain the set of numbers {b1,b2,…,bn} \\{b_1, b_2, \\dots, b_n\\} {b1​,b2​,…,bn​} as the result of taking elements from the pairs. What is the number of different x x x -s ( 0≤x≤n 0 \\le x \\le n 0≤x≤n ) such that it’s possible to obtain the set b b b if for each x x x you can choose how to distribute numbers into pairs and from which x x x pairs choose minimum elements? 输入格式: The first line contains a single integer t t t ( 1≤t≤1000 1 \\le t \\le 1000 1≤t≤1000 ) — the number of test cases. The first line of each test case contains the integer n n n ( 1≤n≤2⋅105 1 \\le n \\le 2 \\cdot 10^5 1≤n≤2⋅105 ). The second line of each test case contains n n n integers b1,b2,…,bn b_1, b_2, \\dots, b_n b1​,b2​,…,bn​ ( 1≤b1\u003cb2\u003c⋯\u003cbn≤2n 1 \\le b_1 \u003c b_2 \u003c \\dots \u003c b_n \\le 2n 1≤b1​\u003cb2​\u003c⋯\u003cbn​≤2n ) — the set you’d like to get. It’s guaranteed that the sum of n n n over test cases doesn’t exceed 2⋅105 2 \\cdot 10^5 2⋅105 . 输出格式: For each test case, print one number — the number of different x x x -s such that it’s possible to obtain the set b b b . 样例: 样例输入1: 3 1 1 5 1 4 5 9 10 2 3 4 样例输出1: 1 3 1 思路: 实现: // Problem: CF1463D Pairs // Contest: Luogu // URL: https://www.luogu.com.cn/problem/CF1463D // Memory Limit: 250 MB // Time Limit: 2000 ms // Author: Ybw051114 // // Powered by CP Editor (https://cpeditor.org) #include \"ybwhead/ios.h\" int n; int vis[1000001]; int main() { int TTT; yin \u003e\u003e TTT; while (TTT--) { yin \u003e\u003e n; for (int i = 1; i \u003c= 2 * n; i++) vis[i] = 0; for (int i = 1; i \u003c= n; i++) { int x; yin \u003e\u003e x; vis[x] = 1; } int siz = 0, as = 0, is = 0; for (int i = 1; i \u003c= n * 2; i++) { if (vis[i]) ++siz; else --siz; as = max(as, siz); is = min(is, siz); } yout \u003c\u003c n - (as - is) + 1 \u003c\u003c endl; } return 0; } ","date":"2020-12-23","objectID":"/posts/oi/problems/cf1463d/:0:0","series":null,"tags":["Notebooks/OI/OJ/Luogu"],"title":"CF1463D-Pairs","uri":"/posts/oi/problems/cf1463d/#"},{"categories":null,"content":"CF1463B-Find The Array 题目: 题目描述: You are given an array [a1,a2,…,an] [a_1, a_2, \\dots, a_n] [a1​,a2​,…,an​] such that 1≤ai≤109 1 \\le a_i \\le 10^9 1≤ai​≤109 . Let S S S be the sum of all elements of the array a a a . Let’s call an array b b b of n n n integers beautiful if: 1≤bi≤109 1 \\le b_i \\le 10^9 1≤bi​≤109 for each i i i from 1 1 1 to n n n ; for every pair of adjacent integers from the array (bi,bi+1) (b_i, b_{i + 1}) (bi​,bi+1​) , either bi b_i bi​ divides bi+1 b_{i + 1} bi+1​ , or bi+1 b_{i + 1} bi+1​ divides bi b_i bi​ (or both); 2∑i=1n∣ai−bi∣≤S 2 \\sum \\limits_{i = 1}^{n} |a_i - b_i| \\le S 2i=1∑n​∣ai​−bi​∣≤S . Your task is to find any beautiful array. It can be shown that at least one beautiful array always exists. 输入格式: The first line contains one integer t t t ( 1≤t≤1000 1 \\le t \\le 1000 1≤t≤1000 ) — the number of test cases. Each test case consists of two lines. The first line contains one integer n n n ( 2≤n≤50 2 \\le n \\le 50 2≤n≤50 ). The second line contains n n n integers a1,a2,…,an a_1, a_2, \\dots, a_n a1​,a2​,…,an​ ( 1≤ai≤109 1 \\le a_i \\le 10^9 1≤ai​≤109 ). 输出格式: For each test case, print the beautiful array b1,b2,…,bn b_1, b_2, \\dots, b_n b1​,b2​,…,bn​ ( 1≤bi≤109 1 \\le b_i \\le 10^9 1≤bi​≤109 ) on a separate line. It can be shown that at least one beautiful array exists under these circumstances. If there are multiple answers, print any of them. 样例: 样例输入1: 4 5 1 2 3 4 5 2 4 6 2 1 1000000000 6 3 4 8 1 2 3 样例输出1: 3 3 3 3 3 3 6 1 1000000000 4 4 8 1 3 3 思路: 实现: // Problem: CF1463B Find The Array // Contest: Luogu // URL: https://www.luogu.com.cn/problem/CF1463B // Memory Limit: 250 MB // Time Limit: 2000 ms // Author: Ybw051114 // // Powered by CP Editor (https://cpeditor.org) #include \"ybwhead/ios.h\" int a[100001], n; int main() { int TTT; yin \u003e\u003e TTT; while (TTT--) { yin \u003e\u003e n; long long sum1 = 0, sum2 = 0; for (int i = 1; i \u003c= n; i++) { yin \u003e\u003e a[i]; if (i \u0026 1) sum1 += a[i] - 1; else sum2 += a[i] - 1; } if (sum1 \u003c sum2) { for (int i = 1; i \u003c= n; i++) { if (i \u0026 1) yout \u003c\u003c 1 \u003c\u003c \" \"; else yout \u003c\u003c a[i] \u003c\u003c \" \"; } yout \u003c\u003c endl; } else { for (int i = 1; i \u003c= n; i++) { if (i \u0026 1) yout \u003c\u003c a[i] \u003c\u003c \" \"; else yout \u003c\u003c 1 \u003c\u003c \" \"; } yout \u003c\u003c endl; } } return 0; } ","date":"2020-12-23","objectID":"/posts/oi/problems/cf1463b/:0:0","series":null,"tags":["Notebooks/OI/OJ/Luogu"],"title":"CF1463B-Find The Array","uri":"/posts/oi/problems/cf1463b/#"},{"categories":null,"content":"CF1463A-Dungeon 题目: 题目描述: You are playing a new computer game in which you have to fight monsters. In a dungeon you are trying to clear, you met three monsters; the first of them has a a a health points, the second has b b b health points, and the third has c c c . To kill the monsters, you can use a cannon that, when fired, deals 1 1 1 damage to the selected monster. Every 7 7 7 -th (i. e. shots with numbers 7 7 7 , 14 14 14 , 21 21 21 etc.) cannon shot is enhanced and deals 1 1 1 damage to all monsters, not just one of them. If some monster’s current amount of health points is 0 0 0 , it can’t be targeted by a regular shot and does not receive damage from an enhanced shot. You want to pass the dungeon beautifully, i. e., kill all the monsters with the same enhanced shot (i. e. after some enhanced shot, the health points of each of the monsters should become equal to 0 0 0 for the first time). Each shot must hit a monster, i. e. each shot deals damage to at least one monster. 输入格式: The first line contains a single integer t t t ( 1≤t≤104 1 \\le t \\le 10^4 1≤t≤104 ) — the number of test cases. Each test case consists of a single line that contains three integers a a a , b b b and c c c ( 1≤a,b,c≤108 1 \\le a, b, c \\le 10^8 1≤a,b,c≤108 ) — the number of health points each monster has. 输出格式: For each test case, print YES if you can kill all the monsters with the same enhanced shot. Otherwise, print NO. You may print each letter in any case (for example, YES, Yes, yes, yEs will all be recognized as positive answer). 样例: 样例输入1: 3 3 2 4 1 1 1 10 1 7 样例输出1: YES NO NO 思路: 实现: // Problem: CF1463A Dungeon // Contest: Luogu // URL: https://www.luogu.com.cn/problem/CF1463A // Memory Limit: 250 MB // Time Limit: 2000 ms // Author: Ybw051114 // // Powered by CP Editor (https://cpeditor.org) #include \"ybwhead/ios.h\" int main() { int TTT; yin \u003e\u003e TTT; while (TTT--) { int a, b, c; yin \u003e\u003e a \u003e\u003e b \u003e\u003e c; if ((a + b + c) % 9) puts(\"No\"); else if ((a + b + c) / 9 \u003c= min(a, min(b, c))) puts(\"Yes\"); else puts(\"No\"); } return 0; } ","date":"2020-12-23","objectID":"/posts/oi/problems/cf1463a/:0:0","series":null,"tags":["Notebooks/OI/OJ/Luogu"],"title":"CF1463A-Dungeon","uri":"/posts/oi/problems/cf1463a/#"},{"categories":null,"content":"CF1455D-Sequence and Swaps 题目: 题目描述: You are given a sequence a a a consisting of n n n integers a1,a2,…,an a_1, a_2, \\dots, a_n a1​,a2​,…,an​ , and an integer x x x . Your task is to make the sequence a a a sorted (it is considered sorted if the condition a1≤a2≤a3≤⋯≤an a_1 \\le a_2 \\le a_3 \\le \\dots \\le a_n a1​≤a2​≤a3​≤⋯≤an​ holds). To make the sequence sorted, you may perform the following operation any number of times you want (possibly zero): choose an integer i i i such that 1≤i≤n 1 \\le i \\le n 1≤i≤n and ai\u003ex a_i \u003e x ai​\u003ex , and swap the values of ai a_i ai​ and x x x . For example, if a=[0,2,3,5,4] a = [0, 2, 3, 5, 4] a=[0,2,3,5,4] , x=1 x = 1 x=1 , the following sequence of operations is possible: choose i=2 i = 2 i=2 (it is possible since a2\u003ex a_2 \u003e x a2​\u003ex ), then a=[0,1,3,5,4] a = [0, 1, 3, 5, 4] a=[0,1,3,5,4] , x=2 x = 2 x=2 ; choose i=3 i = 3 i=3 (it is possible since a3\u003ex a_3 \u003e x a3​\u003ex ), then a=[0,1,2,5,4] a = [0, 1, 2, 5, 4] a=[0,1,2,5,4] , x=3 x = 3 x=3 ; choose i=4 i = 4 i=4 (it is possible since a4\u003ex a_4 \u003e x a4​\u003ex ), then a=[0,1,2,3,4] a = [0, 1, 2, 3, 4] a=[0,1,2,3,4] , x=5 x = 5 x=5 . Calculate the minimum number of operations you have to perform so that a a a becomes sorted, or report that it is impossible. 输入格式: The first line contains one integer t t t ( 1≤t≤500 1 \\le t \\le 500 1≤t≤500 ) — the number of test cases. Each test case consists of two lines. The first line contains two integers n n n and x x x ( 1≤n≤500 1 \\le n \\le 500 1≤n≤500 , 0≤x≤500 0 \\le x \\le 500 0≤x≤500 ) — the number of elements in the sequence and the initial value of x x x . The second line contains n n n integers a1 a_1 a1​ , a2 a_2 a2​ , …, an a_n an​ ( 0≤ai≤500 0 \\le a_i \\le 500 0≤ai​≤500 ). The sum of values of n n n over all test cases in the input does not exceed 500 500 500 . 输出格式: For each test case, print one integer — the minimum number of operations you have to perform to make a a a sorted, or −1 -1 −1 , if it is impossible. 样例: 样例输入1: 6 4 1 2 3 5 4 5 6 1 1 3 4 4 1 10 2 2 10 11 9 2 10 12 11 5 18 81 324 218 413 324 样例输出1: 3 0 0 -1 1 3 思路: 实现: // Problem: CF1455D Sequence and Swaps // Contest: Luogu // URL: https://www.luogu.com.cn/problem/CF1455D // Memory Limit: 500 MB // Time Limit: 1500 ms // // Powered by CP Editor (https://cpeditor.org) #include \"ybwhead/ios.h\" int n, x; int a[1001]; int main() { int TTT; yin \u003e\u003e TTT; while (TTT--) { yin \u003e\u003e n \u003e\u003e x; for (int i = 1; i \u003c= n; i++) yin \u003e\u003e a[i]; while (n \u003e 0 \u0026\u0026 a[n] \u003e= a[n - 1]) n--; // n++; // cerr \u003c\u003c n \u003c\u003c \" \" \u003c\u003c a[n] \u003c\u003c \" \" \u003c\u003c a[n - 1] \u003c\u003c endl; int ans = 0; for (int i = 1; i \u003c= n; i++) { if (a[i] \u003e x) swap(a[i], x), ++ans; // cerr \u003c\u003c x \u003c\u003c endl; } for (int i = 1; i \u003c n; i++) { if (a[i] \u003e a[i + 1]) { ans = -1; break; } } yout \u003c\u003c ans \u003c\u003c endl; } return 0; } ","date":"2020-12-15","objectID":"/posts/oi/problems/cf1455d/:0:0","series":null,"tags":["Notebooks/OI/OJ/Luogu"],"title":"CF1455D-Sequence and Swaps","uri":"/posts/oi/problems/cf1455d/#"},{"categories":null,"content":"CF1455C-Ping-pong 题目: 题目描述: Alice and Bob play ping-pong with simplified rules. During the game, the player serving the ball commences a play. The server strikes the ball then the receiver makes a return by hitting the ball back. Thereafter, the server and receiver must alternately make a return until one of them doesn’t make a return. The one who doesn’t make a return loses this play. The winner of the play commences the next play. Alice starts the first play. Alice has x x x stamina and Bob has y y y . To hit the ball (while serving or returning) each player spends 1 1 1 stamina, so if they don’t have any stamina, they can’t return the ball (and lose the play) or can’t serve the ball (in this case, the other player serves the ball instead). If both players run out of stamina, the game is over. Sometimes, it’s strategically optimal not to return the ball, lose the current play, but save the stamina. On the contrary, when the server commences a play, they have to hit the ball, if they have some stamina left. Both Alice and Bob play optimally and want to, firstly, maximize their number of wins and, secondly, minimize the number of wins of their opponent. Calculate the resulting number of Alice’s and Bob’s wins. 输入格式: The first line contains a single integer t t t ( 1≤t≤104 1 \\le t \\le 10^4 1≤t≤104 ) — the number of test cases. The first and only line of each test case contains two integers x x x and y y y ( 1≤x,y≤106 1 \\le x, y \\le 10^6 1≤x,y≤106 ) — Alice’s and Bob’s initial stamina. 输出格式: For each test case, print two integers — the resulting number of Alice’s and Bob’s wins, if both of them play optimally. 样例: 样例输入1: 3 1 1 2 1 1 7 样例输出1: 0 1 1 1 0 7 思路: 实现: // Problem: CF1455C Ping-pong // Contest: Luogu // URL: https://www.luogu.com.cn/problem/CF1455C // Memory Limit: 250 MB // Time Limit: 1000 ms // // Powered by CP Editor (https://cpeditor.org) #include \"ybwhead/ios.h\" int main() { int TTT; yin \u003e\u003e TTT; while (TTT--) { int a, b; yin \u003e\u003e a \u003e\u003e b; yout \u003c\u003c a - 1 \u003c\u003c \" \" \u003c\u003c b \u003c\u003c endl; } return 0; } ","date":"2020-12-15","objectID":"/posts/oi/problems/cf1455c/:0:0","series":null,"tags":["Notebooks/OI/OJ/Luogu"],"title":"CF1455C-Ping-pong","uri":"/posts/oi/problems/cf1455c/#"},{"categories":null,"content":"CF1455B-Jumps 题目: 题目描述: You are standing on the OX \\mathit{OX} OX -axis at point 0 0 0 and you want to move to an integer point x\u003e0 x \u003e 0 x\u003e0 . You can make several jumps. Suppose you’re currently at point y y y ( y y y may be negative) and jump for the k k k -th time. You can: either jump to the point y+k y + k y+k or jump to the point y−1 y - 1 y−1 . What is the minimum number of jumps you need to reach the point x x x ? 输入格式: The first line contains a single integer t t t ( 1≤t≤1000 1 \\le t \\le 1000 1≤t≤1000 ) — the number of test cases. The first and only line of each test case contains the single integer x x x ( 1≤x≤106 1 \\le x \\le 10^6 1≤x≤106 ) — the destination point. 输出格式: For each test case, print the single integer — the minimum number of jumps to reach x x x . It can be proved that we can reach any integer point x x x . 样例: 样例输入1: 5 1 2 3 4 5 样例输出1: 1 3 2 3 4 思路: 实现: // Problem: CF1455B Jumps // Contest: Luogu // URL: https://www.luogu.com.cn/problem/CF1455B // Memory Limit: 250 MB // Time Limit: 1000 ms // // Powered by CP Editor (https://cpeditor.org) #include \"ybwhead/ios.h\" typedef long long ll; const int maxn = 1000005; int TTT; int x, k, ans; int s[10005]; int main() { yin \u003e\u003e TTT; for (int i = 1; i \u003c 10005 \u0026\u0026 (1 + k) * k / 2 \u003c maxn; i++) s[i] = s[i - 1] + i; while (TTT--) { ans = 999999999; yin \u003e\u003e x; int a = lower_bound(s + 1, s + 1 + 10005, x) - s; int b = s[a] - x; if (b == 0) ans = a; if (b != 0) { int k = b - 1; if (k != 0) ans = min(ans, a); else if (k == 0) ans = min(ans, a + 1); } yout \u003c\u003c ans \u003c\u003c endl; } return 0; } ","date":"2020-12-15","objectID":"/posts/oi/problems/cf1455b/:0:0","series":null,"tags":["Notebooks/OI/OJ/Luogu"],"title":"CF1455B-Jumps","uri":"/posts/oi/problems/cf1455b/#"},{"categories":null,"content":"CF1455A-Strange Functions 题目: 题目描述: Let’s define a function f(x) f(x) f(x) ( x x x is a positive integer) as follows: write all digits of the decimal representation of x x x backwards, then get rid of the leading zeroes. For example, f(321)=123 f(321) = 123 f(321)=123 , f(120)=21 f(120) = 21 f(120)=21 , f(1000000)=1 f(1000000) = 1 f(1000000)=1 , f(111)=111 f(111) = 111 f(111)=111 . Let’s define another function g(x)=xf(f(x)) g(x) = \\dfrac{x}{f(f(x))} g(x)=f(f(x))x​ ( x x x is a positive integer as well). Your task is the following: for the given positive integer n n n , calculate the number of different values of g(x) g(x) g(x) among all numbers x x x such that 1≤x≤n 1 \\le x \\le n 1≤x≤n . 输入格式: The first line contains one integer t t t ( 1≤t≤100 1 \\le t \\le 100 1≤t≤100 ) — the number of test cases. Each test case consists of one line containing one integer n n n ( 1≤n\u003c10100 1 \\le n \u003c 10^{100} 1≤n\u003c10100 ). This integer is given without leading zeroes. 输出格式: For each test case, print one integer — the number of different values of the function g(x) g(x) g(x) , if x x x can be any integer from [1,n] [1, n] [1,n] . 样例: 样例输入1: 5 4 37 998244353 1000000007 12345678901337426966631415 样例输出1: 1 2 9 10 26 思路: 实现: // Problem: CF1455A Strange Functions // Contest: Luogu // URL: https://www.luogu.com.cn/problem/CF1455A // Memory Limit: 250 MB // Time Limit: 2000 ms // // Powered by CP Editor (https://cpeditor.org) #include \"ybwhead/ios.h\" int main() { int TTT; yin \u003e\u003e TTT; while (TTT--) { string s; yin \u003e\u003e s; cout \u003c\u003c s.size() \u003c\u003c endl; } return 0; } ","date":"2020-12-15","objectID":"/posts/oi/problems/cf1455a/:0:0","series":null,"tags":["Notebooks/OI/OJ/Luogu"],"title":"CF1455A-Strange Functions","uri":"/posts/oi/problems/cf1455a/#"},{"categories":null,"content":"CF757F-Team Rocket Rises Again 题目: 题目描述: It’s the turn of the year, so Bash wants to send presents to his friends. There are n n n cities in the Himalayan region and they are connected by m m m bidirectional roads. Bash is living in city s s s . Bash has exactly one friend in each of the other cities. Since Bash wants to surprise his friends, he decides to send a Pikachu to each of them. Since there may be some cities which are not reachable from Bash’s city, he only sends a Pikachu to those friends who live in a city reachable from his own city. He also wants to send it to them as soon as possible. He finds out the minimum time for each of his Pikachus to reach its destination city. Since he is a perfectionist, he informs all his friends with the time their gift will reach them. A Pikachu travels at a speed of 1 1 1 meters per second. His friends were excited to hear this and would be unhappy if their presents got delayed. Unfortunately Team Rocket is on the loose and they came to know of Bash’s plan. They want to maximize the number of friends who are unhappy with Bash. They do this by destroying exactly one of the other n−1 n-1 n−1 cities. This implies that the friend residing in that city dies, so he is unhappy as well. Note that if a city is destroyed, all the roads directly connected to the city are also destroyed and the Pikachu may be forced to take a longer alternate route. Please also note that only friends that are waiting for a gift count as unhappy, even if they die. Since Bash is already a legend, can you help Team Rocket this time and find out the maximum number of Bash’s friends who can be made unhappy by destroying exactly one city. 输入格式: The first line contains three space separated integers n n n , m m m and s s s ( 2\u003c=n\u003c=2⋅105 2\u003c=n\u003c=2·10^{5} 2\u003c=n\u003c=2⋅105 , , 1\u003c=s\u003c=n 1\u003c=s\u003c=n 1\u003c=s\u003c=n ) — the number of cities and the number of roads in the Himalayan region and the city Bash lives in. Each of the next m m m lines contain three space-separated integers u u u , v v v and w w w ( 1\u003c=u,v\u003c=n 1\u003c=u,v\u003c=n 1\u003c=u,v\u003c=n , u≠v u≠v u=v , 1\u003c=w\u003c=109 1\u003c=w\u003c=10^{9} 1\u003c=w\u003c=109 ) denoting that there exists a road between city u u u and city v v v of length w w w meters. It is guaranteed that no road connects a city to itself and there are no two roads that connect the same pair of cities. 输出格式: Print a single integer, the answer to the problem. 样例: 样例输入1: 4 4 3 1 2 1 2 3 1 2 4 1 3 1 1 样例输出1: 2 样例输入2: 7 11 2 1 2 5 1 3 5 2 4 2 2 5 2 3 6 3 3 7 3 4 6 2 3 4 2 6 7 3 4 5 7 4 7 7 样例输出2: 4 思路: 实现: // Problem: CF757F Team Rocket Rises Again // Contest: Luogu // URL: https://www.luogu.com.cn/problem/CF757F // Memory Limit: 500 MB // Time Limit: 2500 ms // // Powered by CP Editor (https://cpeditor.org) #include \"ybwhead/ios.h\" typedef long long ll; const ll N = 200005, INF = 0x3f3f3f3f3f3f3f3f; //支配树 ll d[N], sz[N], f[N][20]; ll dis[N]; bool vst[N]; vector\u003cll\u003e es[N], tree[N]; void add(ll u, ll v) { tree[u].push_back(v); d[v] = d[u] + 1, f[v][0] = u; for (ll i = 1; i \u003c 20; i++) f[v][i] = f[f[v][i - 1]][i - 1]; } ll LCA(ll x, ll y) { if (d[x] \u003c d[y]) swap(x, y); for (ll i = 19; i \u003e= 0; i--) if (d[f[x][i]] \u003e= d[y]) x = f[x][i]; if (x == y) return x; for (ll i = 19; i \u003e= 0; i--) if (f[x][i] != f[y][i]) x = f[x][i], y = f[y][i]; return f[x][0]; } void build(ll u) { if (vst[u]) return; vst[u] = 1; ll fa = 0; for (auto x : es[u]) build(x); for (auto x : es[u]) if (!fa) fa = x; else fa = LCA(fa, x); add(fa, u); } void dfs(ll u) { sz[u] = (dis[u] != INF); for (auto v : tree[u]) if (v != f[u][0]) dfs(v), sz[u] += sz[v]; } //建图 ll n, m, s; struct edge { ll t, w; edge(ll t_, ll w_) { t = t_, w = w_; } }; vector\u003cedge\u003e G[N]; struct node { ll id, d; bool operator\u003c(const node \u0026x) const { return d \u003e x.d; } }; void dijkstra(ll s) { priority_queue\u003cnode\u003e q; memset(dis, 0x3f, sizeof(dis)); dis[s] = 0; q.push((node){s, 0}); for (node cur; !q.empty();) { cur = q.top(); q.pop(); ll u = cur.id; if (cur.d \u003e dis[u]) continue; for (auto x : G[u]) if (dis[x.t] \u003e dis[u] + x.w","date":"2020-11-28","objectID":"/posts/oi/problems/cf757f/:0:0","series":null,"tags":["最短路","Notebooks/OI/OJ/Luogu"],"title":"CF757F-Team Rocket Rises Again","uri":"/posts/oi/problems/cf757f/#"},{"categories":null,"content":"P2252-[SHOI2002]取石子游戏|【模板】威佐夫博弈 题目: 题目描述: 有两堆石子，数量任意，可以不同。游戏开始由两个人轮流取石子。游戏规定，每次有两种不同的取法，一是可以在任意的一堆中取走任意多的石子；二是可以在两堆中同时取走相同数量的石子。最后把石子全部取完者为胜者。现在给出初始的两堆石子的数目，你先取，假设双方都采取最好的策略，问最后你是胜者还是败者。 输入格式: 输入共一行。 第一行共两个数a, b，表示石子的初始情况。 输出格式: 输出共一行。 第一行为一个数字1、0或-1，如果最后你是胜利者则为1；若失败则为0；若结果无法确定则为-1。 样例: 样例输入1: 8 4 样例输出1: 1 思路: 实现: // Problem: P2252 [SHOI2002]取石子游戏|【模板】威佐夫博弈 // Contest: Luogu // URL: https://www.luogu.com.cn/problem/P2252 // Memory Limit: 125 MB // Time Limit: 1000 ms // // Powered by CP Editor (https://cpeditor.org) #include \"ybwhead/ios.h\" const double gold = (sqrt(5.0) + 1.0) / 2.0; int main() { long long n, m; yin \u003e\u003e n \u003e\u003e m; if (n \u003c m) swap(n, m); if (m == (long long)(gold * (n - m))) puts(\"0\"); else puts(\"1\"); return 0; } ","date":"2020-11-28","objectID":"/posts/oi/problems/p2252/:0:0","series":null,"tags":["数论,数学",2002,"各省省选","上海","Notebooks/OI/OJ/Luogu"],"title":"P2252-[SHOI2002]取石子游戏|【模板】威佐夫博弈","uri":"/posts/oi/problems/p2252/#"},{"categories":null,"content":"P2197-【模板】nim游戏 题目: 题目描述: 甲，乙两个人玩 Nim 取石子游戏。 Nim 游戏的规则是这样的：地上有 nnn 堆石子（每堆石子数量小于 10410^4104），每人每次可从任意一堆石子里取出任意多枚石子扔掉，可以取完，不能不取。每次只能从一堆里取。最后没石子可取的人就输了。假如甲是先手，且告诉你这 nnn 堆石子的数量，他想知道是否存在先手必胜的策略。 输入格式: 本题有多组测试数据。 第一行一个整数 T(T≤10)T(T\\le10)T(T≤10)，表示有 TTT 组数据 接下来每两行是一组数据，第一行一个整数 nnn，表示有 nnn 堆石子，n≤10000n\\le10000n≤10000。 第二行有 nnn 个数，表示每一堆石子的数量. 输出格式: 共 TTT 行，如果对于这组数据存在先手必胜策略则输出 Yes，否则输出 No，每个单词一行。 样例: 样例输入1: 2 2 1 1 2 1 0 样例输出1: No Yes 思路: 实现: // Problem: P2197 【模板】nim游戏 // Contest: Luogu // URL: https://www.luogu.com.cn/problem/P2197 // Memory Limit: 125 MB // Time Limit: 1000 ms // // Powered by CP Editor (https://cpeditor.org) #include \"ybwhead/ios.h\" int main() { int TTT; yin \u003e\u003e TTT; while (TTT--) { int n; yin \u003e\u003e n; long long ans = 0; for (int i = 1; i \u003c= n; i++) { long long x; yin \u003e\u003e x; ans ^= x; } if (ans == 0) yout \u003c\u003c \"No\" \u003c\u003c endl; else yout \u003c\u003c \"Yes\" \u003c\u003c endl; } return 0; } ","date":"2020-11-28","objectID":"/posts/oi/problems/p2197/:0:0","series":null,"tags":["博弈论","Notebooks/OI/OJ/Luogu"],"title":"P2197-【模板】nim游戏","uri":"/posts/oi/problems/p2197/#"},{"categories":null,"content":"CF1451E2-Bitwise Queries (Hard Version) 题目: 题目描述: The only difference between the easy and hard versions is the constraints on the number of queries. This is an interactive problem. Ridbit has a hidden array a a a of n n n integers which he wants Ashish to guess. Note that n n n is a power of two. Ashish is allowed to ask three different types of queries. They are of the form AND i i i j j j : ask for the bitwise AND of elements ai a_i ai​ and aj a_j aj​ (1≤i,j≤n (1 \\leq i, j \\le n (1≤i,j≤n , i≠j) i \\neq j) i=j) OR i i i j j j : ask for the bitwise OR of elements ai a_i ai​ and aj a_j aj​ (1≤i,j≤n (1 \\leq i, j \\le n (1≤i,j≤n , i≠j) i \\neq j) i=j) XOR i i i j j j : ask for the bitwise XOR of elements ai a_i ai​ and aj a_j aj​ (1≤i,j≤n (1 \\leq i, j \\le n (1≤i,j≤n , i≠j) i \\neq j) i=j) Can you help Ashish guess the elements of the array? In this version, each element takes a value in the range [0,n−1] [0, n-1] [0,n−1] (inclusive) and Ashish can ask no more than n+1 n+1 n+1 queries. 输入格式: The first line of input contains one integer n n n (4≤n≤216) (4 \\le n \\le 2^{16}) (4≤n≤216) — the length of the array. It is guaranteed that n n n is a power of two. 输出格式: To ask a query print a single line containing one of the following (without quotes) “AND i j” “OR i j” “XOR i j” where i i i and j j j (1≤i,j≤n (1 \\leq i, j \\le n (1≤i,j≤n , i≠j) i \\neq j) i=j) denote the indices being queried.For each query, you will receive an integer x x x whose value depends on the type of query. If the indices queried are invalid or you exceed the number of queries however, you will get x=−1 x = -1 x=−1 . In this case, you should terminate the program immediately. When you have guessed the elements of the array, print a single line “! \" (without quotes), followed by n n n space-separated integers — the elements of the array. Guessing the array does not count towards the number of queries asked. The interactor is not adaptive. The array a a a does not change with queries. After printing a query do not forget to output the end of the line and flush the output. Otherwise, you will get Idleness limit exceeded. To do this, use: fflush(stdout) or cout.flush() in C++; System.out.flush() in Java; flush(output) in Pascal; stdout.flush() in Python; see the documentation for other languages. Hacks To hack the solution, use the following test format: On the first line print a single integer n n n (4≤n≤216) (4 \\le n \\le 2^{16}) (4≤n≤216) — the length of the array. It must be a power of 2. The next line should contain n n n space-separated integers in the range [0,n−1] [0, n-1] [0,n−1] — the array a a a . 样例: 样例输入1: 4 0 2 3 样例输出1: OR 1 2 OR 2 3 XOR 2 4 ! 0 0 2 3 思路: 实现: #include \"ybwhead/ios.h\" int n; const int maxn=5e5+10; int x[maxn]; int tt=-1,tt1=-1; map\u003cint,int\u003e y; int a[maxn]; int main() { cin\u003e\u003en; for(int i=2;i\u003c=n;i++) { cout\u003c\u003c\"XOR \"\u003c\u003c1\u003c\u003c' '\u003c\u003ci\u003c\u003cendl; cin\u003e\u003ex[i]; if(y[x[i]])tt=i,tt1=y[x[i]]; y[x[i]]=i; fflush(stdout); } if(tt\u003e=0) { cout\u003c\u003c\"AND \"\u003c\u003ctt\u003c\u003c' '\u003c\u003ctt1\u003c\u003cendl; int xx; cin\u003e\u003exx; fflush(stdout); // a[tt]=xx;a[tt1]=xx; a[1]=x[tt]^xx; for(int i=2;i\u003c=n;i++) { a[i]=a[1]^x[i]; } } else { int ttt=1,ttt1=2; for(int i=2;i\u003c=3;i++) for(int j=i+1;j\u003c=n;j++) if((x[i]^x[j])==n-1) ttt=i,ttt1=j; cout\u003c\u003c\"AND \"\u003c\u003c1\u003c\u003c' '\u003c\u003cttt\u003c\u003cendl; int xx,yy,zz=0; cin\u003e\u003exx; fflush(stdout); cout\u003c\u003c\"AND \"\u003c\u003c1\u003c\u003c' '\u003c\u003cttt1\u003c\u003cendl; cin\u003e\u003eyy; fflush(stdout); int x1=xx*2+x[ttt],x2=yy*2+x[ttt1],x3=zz*2+(x[ttt]^x[ttt1]); a[1]=x1+x2-x3; a[1]\u003e\u003e=1; for(int i=2;i\u003c=n;i++)a[i]=a[1]^x[i]; } cout\u003c\u003c\"! \"; for(int i=1;i\u003c=n;i++)cout\u003c\u003ca[i]\u003c\u003c\" \"; fflush(stdout); return 0; } ","date":"2020-11-28","objectID":"/posts/oi/problems/cf1451e2/:0:0","series":null,"tags":["Notebooks/OI/OJ/Luogu"],"title":"CF1451E2-Bitwise Queries (Hard Version)","uri":"/posts/oi/problems/cf1451e2/#"},{"categories":null,"content":"CF1451E1-Bitwise Queries (Easy Version) 题目: 题目描述: The only difference between the easy and hard versions is the constraints on the number of queries. This is an interactive problem. Ridbit has a hidden array a a a of n n n integers which he wants Ashish to guess. Note that n n n is a power of two. Ashish is allowed to ask three different types of queries. They are of the form AND i i i j j j : ask for the bitwise AND of elements ai a_i ai​ and aj a_j aj​ (1≤i,j≤n (1 \\leq i, j \\le n (1≤i,j≤n , i≠j) i \\neq j) i=j) OR i i i j j j : ask for the bitwise OR of elements ai a_i ai​ and aj a_j aj​ (1≤i,j≤n (1 \\leq i, j \\le n (1≤i,j≤n , i≠j) i \\neq j) i=j) XOR i i i j j j : ask for the bitwise XOR of elements ai a_i ai​ and aj a_j aj​ (1≤i,j≤n (1 \\leq i, j \\le n (1≤i,j≤n , i≠j) i \\neq j) i=j) Can you help Ashish guess the elements of the array? In this version, each element takes a value in the range [0,n−1] [0, n-1] [0,n−1] (inclusive) and Ashish can ask no more than n+2 n+2 n+2 queries. 输入格式: The first line of input contains one integer n n n (4≤n≤216) (4 \\le n \\le 2^{16}) (4≤n≤216) — the length of the array. It is guaranteed that n n n is a power of two. 输出格式: To ask a query print a single line containing one of the following (without quotes) “AND i j” “OR i j” “XOR i j” where i i i and j j j (1≤i,j≤n (1 \\leq i, j \\le n (1≤i,j≤n , i≠j) i \\neq j) i=j) denote the indices being queried.For each query, you will receive an integer x x x whose value depends on the type of query. If the indices queried are invalid or you exceed the number of queries however, you will get x=−1 x = -1 x=−1 . In this case, you should terminate the program immediately. When you have guessed the elements of the array, print a single line “! \" (without quotes), followed by n n n space-separated integers — the elements of the array. Guessing the array does not count towards the number of queries asked. The interactor is not adaptive. The array a a a does not change with queries. After printing a query do not forget to output the end of the line and flush the output. Otherwise, you will get Idleness limit exceeded. To do this, use: fflush(stdout) or cout.flush() in C++; System.out.flush() in Java; flush(output) in Pascal; stdout.flush() in Python; see the documentation for other languages. Hacks To hack the solution, use the following test format: On the first line print a single integer n n n (4≤n≤216) (4 \\le n \\le 2^{16}) (4≤n≤216) — the length of the array. It must be a power of 2. The next line should contain n n n space-separated integers in the range [0,n−1] [0, n-1] [0,n−1] — the array a a a . 样例: 样例输入1: 4 0 2 3 样例输出1: OR 1 2 OR 2 3 XOR 2 4 ! 0 0 2 3 思路: 实现: #include \"ybwhead/ios.h\" int n; const int maxn=5e5+10; int x[maxn]; int tt=-1,tt1=-1; map\u003cint,int\u003e y; int a[maxn]; int main() { cin\u003e\u003en; for(int i=2;i\u003c=n;i++) { cout\u003c\u003c\"XOR \"\u003c\u003c1\u003c\u003c' '\u003c\u003ci\u003c\u003cendl; cin\u003e\u003ex[i]; if(y[x[i]])tt=i,tt1=y[x[i]]; y[x[i]]=i; fflush(stdout); } if(tt\u003e=0) { cout\u003c\u003c\"AND \"\u003c\u003ctt\u003c\u003c' '\u003c\u003ctt1\u003c\u003cendl; int xx; cin\u003e\u003exx; fflush(stdout); // a[tt]=xx;a[tt1]=xx; a[1]=x[tt]^xx; for(int i=2;i\u003c=n;i++) { a[i]=a[1]^x[i]; } } else { int ttt=1,ttt1=2; for(int i=2;i\u003c=3;i++) for(int j=i+1;j\u003c=n;j++) if((x[i]^x[j])==n-1) ttt=i,ttt1=j; cout\u003c\u003c\"AND \"\u003c\u003c1\u003c\u003c' '\u003c\u003cttt\u003c\u003cendl; int xx,yy,zz=0; cin\u003e\u003exx; fflush(stdout); cout\u003c\u003c\"AND \"\u003c\u003c1\u003c\u003c' '\u003c\u003cttt1\u003c\u003cendl; cin\u003e\u003eyy; fflush(stdout); int x1=xx*2+x[ttt],x2=yy*2+x[ttt1],x3=zz*2+(x[ttt]^x[ttt1]); a[1]=x1+x2-x3; a[1]\u003e\u003e=1; for(int i=2;i\u003c=n;i++)a[i]=a[1]^x[i]; } cout\u003c\u003c\"! \"; for(int i=1;i\u003c=n;i++)cout\u003c\u003ca[i]\u003c\u003c\" \"; fflush(stdout); return 0; } ","date":"2020-11-28","objectID":"/posts/oi/problems/cf1451e1/:0:0","series":null,"tags":["Notebooks/OI/OJ/Luogu"],"title":"CF1451E1-Bitwise Queries (Easy Version)","uri":"/posts/oi/problems/cf1451e1/#"},{"categories":null,"content":"CF1451D-Circle Game 题目: 题目描述: Utkarsh is forced to play yet another one of Ashish’s games. The game progresses turn by turn and as usual, Ashish moves first. Consider the 2D plane. There is a token which is initially at (0,0) (0,0) (0,0) . In one move a player must increase either the x x x coordinate or the y y y coordinate of the token by exactly k k k . In doing so, the player must ensure that the token stays within a (Euclidean) distance d d d from (0,0) (0,0) (0,0) . In other words, if after a move the coordinates of the token are (p,q) (p,q) (p,q) , then p2+q2≤d2 p^2 + q^2 \\leq d^2 p2+q2≤d2 must hold. The game ends when a player is unable to make a move. It can be shown that the game will end in a finite number of moves. If both players play optimally, determine who will win. 输入格式: The first line contains a single integer t t t ( 1≤t≤100 1 \\leq t \\leq 100 1≤t≤100 ) — the number of test cases. The only line of each test case contains two space separated integers d d d ( 1≤d≤105 1 \\leq d \\leq 10^5 1≤d≤105 ) and k k k ( 1≤k≤d 1 \\leq k \\leq d 1≤k≤d ). 输出格式: For each test case, if Ashish wins the game, print “Ashish”, otherwise print “Utkarsh” (without the quotes). 样例: 样例输入1: 5 2 1 5 2 10 3 25 4 15441 33 样例输出1: Utkarsh Ashish Utkarsh Utkarsh Ashish 思路: 实现: #include \"ybwhead/ios.h\" int main() { int TTT; yin\u003e\u003eTTT; while(TTT--) { long long d,k; yin\u003e\u003ed\u003e\u003ek; long long x=0,y=0; while(1) { if(x\u003c=y\u0026\u0026(x+k)*(x+k)+y*y\u003c=d*d) x+=k; else if(x\u003ey\u0026\u0026x*x+(y+k)*(y+k)\u003c=d*d) y+=k; else break; } if(x==y) { puts(\"Utkarsh\"); } else { puts(\"Ashish\"); } } return 0; } ","date":"2020-11-27","objectID":"/posts/oi/problems/cf1451d/:0:0","series":null,"tags":["Notebooks/OI/OJ/Luogu"],"title":"CF1451D-Circle Game","uri":"/posts/oi/problems/cf1451d/#"},{"categories":null,"content":"CF1451C-String Equality 题目: 题目描述: Ashish has two strings a a a and b b b , each of length n n n , and an integer k k k . The strings only contain lowercase English letters. He wants to convert string a a a into string b b b by performing some (possibly zero) operations on a a a . In one move, he can either choose an index i i i ( 1≤i≤n−1 1 \\leq i\\leq n-1 1≤i≤n−1 ) and swap ai a_i ai​ and ai+1 a_{i+1} ai+1​ , or choose an index i i i ( 1≤i≤n−k+1 1 \\leq i \\leq n-k+1 1≤i≤n−k+1 ) and if ai,ai+1,…,ai+k−1 a_i, a_{i+1}, \\ldots, a_{i+k-1} ai​,ai+1​,…,ai+k−1​ are all equal to some character c c c ( c≠ c \\neq c= ‘z’), replace each one with the next character (c+1) (c+1) (c+1) , that is, ‘a’ is replaced by ‘b’, ‘b’ is replaced by ‘c’ and so on. Note that he can perform any number of operations, and the operations can only be performed on string a a a . Help Ashish determine if it is possible to convert string a a a into b b b after performing some (possibly zero) operations on it. 输入格式: The first line contains a single integer t t t ( 1≤t≤105 1 \\leq t \\leq 10^5 1≤t≤105 ) — the number of test cases. The description of each test case is as follows. The first line of each test case contains two integers n n n ( 2≤n≤106 2 \\leq n \\leq 10^6 2≤n≤106 ) and k k k ( 1≤k≤n 1 \\leq k \\leq n 1≤k≤n ). The second line of each test case contains the string a a a of length n n n consisting of lowercase English letters. The third line of each test case contains the string b b b of length n n n consisting of lowercase English letters. It is guaranteed that the sum of values n n n among all test cases does not exceed 106 10^6 106 . 输出格式: For each test case, print “Yes” if Ashish can convert a a a into b b b after some moves, else print “No”. You may print the letters of the answer in any case (upper or lower). 样例: 样例输入1: 4 3 3 abc bcd 4 2 abba azza 2 1 zz aa 6 2 aaabba ddddcc 样例输出1: No Yes No Yes 思路: 实现: #include \"ybwhead/ios.h\" string a,b; int c[30],d[30]; int main() { int TTT; yin\u003e\u003eTTT; while(TTT--) { int n,k; memset(c,0,sizeof(c)); memset(d,0,sizeof(d)); yin\u003e\u003en\u003e\u003ek; yin\u003e\u003ea\u003e\u003eb; for(int i=0;i\u003ca.size();i++)c[a[i]-'a']++; for(int i=0;i\u003cb.size();i++)d[b[i]-'a']++; bool flg=1; for(int i=0;i\u003c=26;i++) { if(c[i]\u003cd[i]) { flg=0;break; } else { if((c[i]-d[i])%k!=0) { flg=0;break; } else { c[i+1]+=c[i]-d[i]; } } } if(flg) { puts(\"YES\"); }else puts(\"NO\"); } return 0; } ","date":"2020-11-27","objectID":"/posts/oi/problems/cf1451c/:0:0","series":null,"tags":["Notebooks/OI/OJ/Luogu"],"title":"CF1451C-String Equality","uri":"/posts/oi/problems/cf1451c/#"},{"categories":null,"content":"CF1451B-Non-Substring Subsequence 题目: 题目描述: Hr0d1y has q q q queries on a binary string s s s of length n n n . A binary string is a string containing only characters ‘0’ and ‘1’. A query is described by a pair of integers li l_i li​ , ri r_i ri​ (1≤li\u003cri≤n) (1 \\leq l_i \\lt r_i \\leq n) (1≤li​\u003cri​≤n) . For each query, he has to determine whether there exists a good subsequence in s s s that is equal to the substring s[li…ri] s[l_i\\ldots r_i] s[li​…ri​] . A substring s[i…j] s[i\\ldots j] s[i…j] of a string s s s is the string formed by characters sisi+1…sj s_i s_{i+1} \\ldots s_j si​si+1​…sj​ . String a a a is said to be a subsequence of string b b b if a a a can be obtained from b b b by deleting some characters without changing the order of the remaining characters. A subsequence is said to be good if it is not contiguous and has length ≥2 \\ge 2 ≥2 . For example, if s s s is “1100110”, then the subsequences s1s2s4 s_1s_2s_4 s1​s2​s4​ (“1100110”) and s1s5s7 s_1s_5s_7 s1​s5​s7​ (“1100110”) are good, while s1s2s3 s_1s_2s_3 s1​s2​s3​ (“1100110”) is not good. Can you help Hr0d1y answer each query? 输入格式: The first line of the input contains a single integer t t t ( 1≤t≤100 1\\leq t \\leq 100 1≤t≤100 ) — the number of test cases. The description of each test case is as follows. The first line contains two integers n n n ( 2≤n≤100 2 \\leq n \\leq 100 2≤n≤100 ) and q q q ( 1≤q≤100 1\\leq q \\leq 100 1≤q≤100 ) — the length of the string and the number of queries. The second line contains the string s s s . The i i i -th of the next q q q lines contains two integers li l_i li​ and ri r_i ri​ ( 1≤li\u003cri≤n 1 \\leq l_i \\lt r_i \\leq n 1≤li​\u003cri​≤n ). 输出格式: For each test case, output q q q lines. The i i i -th line of the output of each test case should contain “YES” if there exists a good subsequence equal to the substring s[li...ri] s[l_i...r_i] s[li​...ri​] , and “NO” otherwise. You may print each letter in any case (upper or lower). 样例: 样例输入1: 2 6 3 001000 2 4 1 3 3 5 4 2 1111 1 4 2 3 样例输出1: YES NO YES NO YES 思路: 实现: #include \"ybwhead/ios.h\" string s; int n,q; int main() { int TTT; yin\u003e\u003eTTT; while(TTT--) { yin\u003e\u003en\u003e\u003eq; yin\u003e\u003es; for(int i=1;i\u003c=q;i++) { int l,r; yin\u003e\u003el\u003e\u003er;--l;--r; bool flg=0; for(int j=0;j\u003cl;j++) { if(s[j]==s[l]) { flg=1;break; } } for(int j=r+1;j\u003cn;j++) { if(s[j]==s[r]) { flg=1;break; } } if(flg)puts(\"YES\"); else puts(\"NO\"); } } return 0; } ","date":"2020-11-27","objectID":"/posts/oi/problems/cf1451b/:0:0","series":null,"tags":["Notebooks/OI/OJ/Luogu"],"title":"CF1451B-Non-Substring Subsequence","uri":"/posts/oi/problems/cf1451b/#"},{"categories":null,"content":"CF1451A-Subtract or Divide 题目: 题目描述: Ridbit starts with an integer n n n . In one move, he can perform one of the following operations: divide n n n by one of its proper divisors, or subtract 1 1 1 from n n n if n n n is greater than 1 1 1 . A proper divisor is a divisor of a number, excluding itself. For example, 1 1 1 , 2 2 2 , 4 4 4 , 5 5 5 , and 10 10 10 are proper divisors of 20 20 20 , but 20 20 20 itself is not. What is the minimum number of moves Ridbit is required to make to reduce n n n to 1 1 1 ? 输入格式: The first line contains a single integer t t t ( 1≤t≤1000 1 \\leq t \\leq 1000 1≤t≤1000 ) — the number of test cases. The only line of each test case contains a single integer n n n ( 1≤n≤109 1 \\leq n \\leq 10^9 1≤n≤109 ). 输出格式: For each test case, output the minimum number of moves required to reduce n n n to 1 1 1 . 样例: 样例输入1: 6 1 2 3 4 6 9 样例输出1: 0 1 2 2 2 3 思路: 实现: #include \"ybwhead/ios.h\" int main() { int TTT; yin\u003e\u003eTTT; while(TTT--) { int n; yin\u003e\u003en; if(n==1){puts(\"0\");continue;} if(n==3) { puts(\"2\"); continue; } if(n==2) { puts(\"1\"); continue; } if(n\u00261) { puts(\"3\"); continue; } else { puts(\"2\"); } } return 0; } ","date":"2020-11-27","objectID":"/posts/oi/problems/cf1451a/:0:0","series":null,"tags":["Notebooks/OI/OJ/Luogu"],"title":"CF1451A-Subtract or Divide","uri":"/posts/oi/problems/cf1451a/#"},{"categories":null,"content":"P5338-[TJOI2019]甲苯先生的滚榜 题目: 题目描述: 甲苯先生在制作一个 Online Judge，他发现做比赛的人们很关心自己的排名（显而易见）。 在 ACM 赛制的比赛中，如果通过题目数量不相等，则通过题目数量多的人排名更靠前； 如果通过题目数量相等，则罚时更少的人排名更高。 甲苯先生想让大家帮忙设计一个程序，每次有人通过之后，就告诉他排名在他的前面有多少人。 （不包括和他罚时题数都相同的同学） 输入格式: 第一行输入一个整数 TTT 表示测试样例的个数。 对于每一个样例，输入三个整数 m,n,seedm, n, \\text{seed}m,n,seed。 mmm 表示参赛总人数（编号 1∼m1 \\sim m1∼m），nnn 表示一共有 nnn 次 AC（假设 AC 已经去重，即不存在相同人的相同题目提交）。 seed\\text{seed}seed 表示生成数据的种子。 接下来要求同学们使用之下的函数生成数据： typedef unsigned int ui ; ui randNum( ui\u0026 seed , ui last , const ui m){ seed = seed * 17 + last ; return seed % m + 1; } （last\\texttt{last}last 为上一次输出的结果，在没有输出结果时 last=7\\texttt{last} = 7last=7，多组数据时 last\\texttt{last}last 不需要重新赋值） 要求每次生成两个数据 Ria,Rib\\texttt{Ria}, \\texttt{Rib}Ria,Rib，表示第 Ria\\texttt{Ria}Ria 个人 AC 了一道题目，他的罚时为 Rib\\texttt{Rib}Rib。 （也就是说 Ria\\texttt{Ria}Ria 的题目数量 +1+1+1，罚时长度 +Rib+\\texttt{Rib}+Rib）。 要求一共生成 nnn 组数据，代表一共有 nnn 次提交。 对于所有数据，保证罚时总和不超过 1.5×1061.5\\times 10^61.5×106。 输出格式: 每次提交输出一行整数，表示在第 Ria\\texttt{Ria}Ria 个人 AC 后，比 Ria\\texttt{Ria}Ria 成绩高的有多少个选手。 样例: 样例输入1: 1 7 3 1 样例输出1: 0 1 0 思路: 实现: // Problem: P5338 [TJOI2019]甲苯先生的滚榜 // Contest: Luogu // URL: https://www.luogu.com.cn/problem/P5338 // Memory Limit: 1 MB // Time Limit: 10000 ms // // Powered by CP Editor (https://cpeditor.org) #include \"ybwhead/ios.h\" template \u003ctypename Tp\u003e void read(Tp \u0026x) { x = 0; char ch = 1; int fh; while (ch != '-' \u0026\u0026 (ch \u003c '0' || ch \u003e '9')) ch = getchar(); if (ch == '-') fh = -1, ch = getchar(); else fh = 1; while (ch \u003e= '0' \u0026\u0026 ch \u003c= '9') { x = (x \u003c\u003c 1) + (x \u003c\u003c 3) + ch - '0'; ch = getchar(); } x *= fh; } const int INF = 0x3f3f3f3f; const int maxm = 1000000 + 7; int n, T, root; unsigned seed, las = 7, m; typedef unsigned int ui; ui randNum(ui \u0026seed, ui last, ui m) { seed = seed * 17 + last; return seed % m + 1; } int dat[maxm], size[maxm], cnt[maxm], ac[maxm], tim[maxm]; int ch[maxm][2], tot; int nowac[maxm * 10], nowtim[maxm * 10]; void pushup(int x) { size[x] = size[ch[x][0]] + size[ch[x][1]] + cnt[x]; } int New(int a, int b) { dat[++tot] = rand(), size[tot] = cnt[tot] = 1, ac[tot] = a, tim[tot] = b; return tot; } void build() { tot = 0; root = New(INF, -INF); ch[root][1] = New(-INF, INF); pushup(root); } void rotate(int \u0026id, int dir) { int tmp = ch[id][dir xor 1]; ch[id][dir xor 1] = ch[tmp][dir]; ch[tmp][dir] = id; id = tmp; pushup(ch[id][dir]); pushup(id); } void insert(int \u0026id, int a, int b) { if (!id) { id = New(a, b); return; } if (a == ac[id] \u0026\u0026 b == tim[id]) cnt[id]++; else { int d; if (a \u003e ac[id]) d = 0; else if (a == ac[id]) { if (b \u003c tim[id]) d = 0; else d = 1; } else d = 1; insert(ch[id][d], a, b); if (dat[id] \u003c dat[ch[id][d]]) rotate(id, d xor 1); } pushup(id); } void remove(int \u0026id, int a, int b) { if (!id) return; if (ac[id] == a \u0026\u0026 tim[id] == b) { if (cnt[id] \u003e 1) { cnt[id]--; pushup(id); return; } if (ch[id][0] || ch[id][1]) { if (!ch[id][1] || dat[ch[id][0]] \u003e dat[ch[id][1]]) { rotate(id, 1); remove(ch[id][1], a, b); } else { rotate(id, 0); remove(ch[id][0], a, b); } pushup(id); } else id = 0; return; } if (a \u003e ac[id]) { remove(ch[id][0], a, b); } else if (a == ac[id]) { if (b \u003c tim[id]) remove(ch[id][0], a, b); else remove(ch[id][1], a, b); } else remove(ch[id][1], a, b); pushup(id); } int get_rank(int id, int a, int b) { if (!id) return 0; if (a == ac[id] \u0026\u0026 b == tim[id]) return size[ch[id][0]] + 1; if (a \u003e ac[id]) return get_rank(ch[id][0], a, b); else if (a == ac[id] \u0026\u0026 b \u003c tim[id]) return get_rank(ch[id][0], a, b); return size[ch[id][0]] + cnt[id] + get_rank(ch[id][1], a, b); } int TTTT; int main() { srand(28910); read(TTTT); while (TTTT--) { build(); memset(ch, 0, sizeof(ch)); memset(nowac, 0, sizeof(nowac)); memset(nowtim, 0, sizeof(nowtim)); read(m); read(n); read(seed); for (int i = 1; i \u003c= n; i++) { int x, y; x = randNum(seed, las, m), y = randNum(seed, las, m); remove(root, nowac[x], nowtim[x]); nowac[x]++, nowtim[x] += y; // insert(root,nowac[x],nowtim[y]); insert(root, nowac[x], nowtim[x]); //错误笔记：弄错x,y // las=get_rank(root,nowac[x],nowtim[y])-2; las = get_rank(root, nowac[x], nowtim[x]) - 2; ","date":"2020-11-01","objectID":"/posts/oi/problems/p5338/:0:0","series":null,"tags":[2019,"各省省选","天津","Notebooks/OI/OJ/Luogu"],"title":"P5338-[TJOI2019]甲苯先生的滚榜","uri":"/posts/oi/problems/p5338/#"},{"categories":null,"content":"P4559-[JSOI2018]列队 题目: 题目描述: 作为一名大学生，九条可怜在去年参加了她人生中的最后一次军训。 军训中的一个重要项目是练习列队，为了训练学生，教官给每一个学生分配了一个休息位置。每次训练开始前，所有学生都在各自的休息位置休息，但是当教官发出集合命令后，被点到的学生必须要到指定位置集合。 为了简化问题，我们把休息位置和集合位置抽象成一根数轴。一共有 nnn 个学生，第 iii 个学生的休息位置是 aia_iai​​。每一次命令，教官会指定一个区间 [l,r][l,r][l,r] 和集合点 KKK ，所有编号在 [l,r][l,r][l,r] 内的学生都必须赶到集合点列队。在列队时，每一个学生需要选择 [K,K+r−l][K,K+r-l][K,K+r−l] 中的一个整数坐标站定且不能有任何两个学生选择的坐标相同。学生从坐标 xxx 跑到坐标 yyy 需要耗费体力 ∣y−x∣\\vert y-x \\vert∣y−x∣ 。 在一天的训练中，教官一共发布了 mmm 条命令 (l,r,K)(l,r,K)(l,r,K) ，现在你需要计算对于每一条命令，在所有可能的列队方案中，消耗的体力值总和最小是多少。 以下是对题意的一些补充： 任何两条命令是无关的，即在一条集合命令结束后，所有学生都会回到自己的休息位置，然后教官才会发出下一条命令。 在集合的时候，可能有编号不在 [l,r][l,r][l,r] 内的学生处在区间 [K,K+r−l][K,K+r-l][K,K+r−l] 中，这时他会自己跑开，且跑动的距离不记在消耗的体力值总和中。 输入格式: 第一行输入两个整数 n,mn,mn,m。 第二行 nnn 个整数 aia_iai​ 表示学生的休息位置。保证学生休息的位置两两不同。 接下来 mmm 行每行三个整数 l,r,Kl,r,Kl,r,K 表示一条命令。 输出格式: 对于每一条命令输出一行一个整数表示最小的体力值总和。 样例: 样例输入1: 5 5 1 5 7 6 2 1 5 2 1 5 3 1 3 9 2 4 2 3 5 5 样例输出1: 5 4 17 9 3 思路: 实现: // Problem: P4559 [JSOI2018]列队 // Contest: Luogu // URL: https://www.luogu.com.cn/problem/P4559 // Memory Limit: 500 MB // Time Limit: 3000 ms // // Powered by CP Editor (https://cpeditor.org) #include \"ybwhead/ios.h\" typedef long long LL; const int MN = 500005; const int MS = 11000005; int n, m, s = 1000000; int rt[MN]; int ls[MS], rs[MS], mx[MS], mn[MS], sz[MS], cnt; LL sum[MS]; void Add(int \u0026rt, int l, int r, int p) { ls[++cnt] = ls[rt], rs[cnt] = rs[rt], sz[cnt] = sz[rt] + 1, sum[cnt] = sum[rt] + p, rt = cnt; if (l == r) return; int mid = l + r \u003e\u003e 1; if (p \u003c= mid) Add(ls[rt], l, mid, p); else Add(rs[rt], mid + 1, r, p); } LL Qur(int rt1, int rt2, int l, int r, int f, int k) { if (!(sz[rt1] - sz[rt2])) return 0; LL Sz = sz[rt1] - sz[rt2], Sum = sum[rt1] - sum[rt2]; if (l \u003e= k + f) return Sum - (2 * k + 2 * f + Sz - 1) * Sz / 2; if (r \u003c= k + f + Sz - 1) return (2 * k + 2 * f + Sz - 1) * Sz / 2 - Sum; int mid = l + r \u003e\u003e 1, lsz = sz[ls[rt1]] - sz[ls[rt2]]; return Qur(ls[rt1], ls[rt2], l, mid, f, k) + Qur(rs[rt1], rs[rt2], mid + 1, r, f + lsz, k); } int main() { scanf(\"%d%d\", \u0026n, \u0026m); for (int i = 1, x; i \u003c= n; ++i) { scanf(\"%d\", \u0026x); Add(rt[i] = rt[i - 1], 1, s, x); } for (int i = 1, l, r, k; i \u003c= m; ++i) { scanf(\"%d%d%d\", \u0026l, \u0026r, \u0026k); printf(\"%lld\\n\", Qur(rt[r], rt[l - 1], 1, s, 0, k)); } return 0; } ","date":"2020-11-01","objectID":"/posts/oi/problems/p4559/:0:0","series":null,"tags":[2018,"线段树","各省省选","递归","江苏","主席树","高性能","Notebooks/OI/OJ/Luogu"],"title":"P4559-[JSOI2018]列队","uri":"/posts/oi/problems/p4559/#"},{"categories":null,"content":"AT4831-[ABC155F] Perils in Parallel 题目: 题目描述: AlDebaran 王国の侵攻によって、AtCoder 王国の各地に爆弾が仕掛けられてしまいました。 幸いにも AtCoder 王国 ABC 隊の健闘により制御装置の一部が手に入ったので、あなたはこれを使って解除を試みることにしました。 仕掛けられた爆弾は N N N 個あり、 1 1 1 から N N N の番号がついています。爆弾 i i i は座標 Ai A_i Ai​ にあり、電源は Bi=1 B_i=1 Bi​=1 のときオンに、 Bi=0 B_i=0 Bi​=0 のときオフになっています。 制御装置には M M M 本のコードがあり、 1 1 1 から M M M の番号がついています。コード j j j を切ると、座標が Lj L_j Lj​ 以上 Rj R_j Rj​ 以下の全ての爆弾の電源のオン・オフが切り替わります。 切るコードをうまく選ぶことで全ての爆弾の電源をオフにできるか判定し、できるならばそのようなコードの組合せを 1 1 1 つ出力してください。 After being invaded by the Kingdom of AlDebaran, bombs are planted throughout our country, AtCoder Kingdom. Fortunately, our military team called ABC has managed to obtain a device that is a part of the system controlling the bombs. There are N N N bombs, numbered 1 1 1 to N N N , planted in our country. Bomb i i i is planted at the coordinate Ai A_i Ai​ . It is currently activated if Bi=1 B_i=1 Bi​=1 , and deactivated if Bi=0 B_i=0 Bi​=0 . The device has M M M cords numbered 1 1 1 to M M M . If we cut Cord j j j , the states of all the bombs planted between the coordinates Lj L_j Lj​ and Rj R_j Rj​ (inclusive) will be switched - from activated to deactivated, and vice versa. Determine whether it is possible to deactivate all the bombs at the same time. If the answer is yes, output a set of cords that should be cut. 输入格式: Input is given from Standard Input in the following format: $ N $ $ M $ $ A_1 $ $ B_1 $ $ : $ $ A_N $ $ B_N $ $ L_1 $ $ R_1 $ $ : $ $ L_M $ $ R_M $ 输出格式: If it is impossible to deactivate all the bombs at the same time, print -1. If it is possible to do so, print a set of cords that should be cut, as follows: $ k $ $ c_1 $ $ c_2 $ $ \\dots $ $ c_k $ Here, k k k is the number of cords (possibly 0 0 0 ), and c1, c2, …, ck c_1,\\ c_2,\\ \\dots,\\ c_k c1​, c2​, …, ck​ represent the cords that should be cut. 1 ≤ c1 \u003c c2 \u003c … \u003c ck ≤ M 1\\ \\leq\\ c_1\\ \u003c\\ c_2\\ \u003c\\ \\dots\\ \u003c\\ c_k\\ \\leq\\ M 1 ≤ c1​ \u003c c2​ \u003c … \u003c ck​ ≤ M must hold. 样例: 样例输入1: 3 4 5 1 10 1 8 0 1 10 4 5 6 7 8 9 样例输出1: 2 1 4 样例输入2: 4 2 2 0 3 1 5 1 7 0 1 4 4 7 样例输出2: -1 样例输入3: 3 2 5 0 10 0 8 0 6 9 66 99 样例输出3: 0 样例输入4: 12 20 536130100 1 150049660 1 79245447 1 132551741 0 89484841 1 328129089 0 623467741 0 248785745 0 421631475 0 498966877 0 43768791 1 112237273 0 21499042 142460201 58176487 384985131 88563042 144788076 120198276 497115965 134867387 563350571 211946499 458996604 233934566 297258009 335674184 555985828 414601661 520203502 101135608 501051309 90972258 300372385 255474956 630621190 436210625 517850028 145652401 192476406 377607297 520655694 244404406 304034433 112237273 359737255 392593015 463983307 150586788 504362212 54772353 83124235 样例输出4: 5 1 7 8 9 11 样例输入5: 3 4 5 1 10 1 8 0 1 10 4 5 6 7 8 9 样例输出5: 2 1 4 样例输入6: 4 2 2 0 3 1 5 1 7 0 1 4 4 7 样例输出6: -1 样例输入7: 3 2 5 0 10 0 8 0 6 9 66 99 样例输出7: 0 样例输入8: 12 20 536130100 1 150049660 1 79245447 1 132551741 0 89484841 1 328129089 0 623467741 0 248785745 0 421631475 0 498966877 0 43768791 1 112237273 0 21499042 142460201 58176487 384985131 88563042 144788076 120198276 497115965 134867387 563350571 211946499 458996604 233934566 297258009 335674184 555985828 414601661 520203502 101135608 501051309 90972258 300372385 255474956 630621190 436210625 517850028 145652401 192476406 377607297 520655694 244404406 304034433 112237273 359737255 392593015 463983307 150586788 504362212 54772353 83124235 样例输出8: 5 1 7 8 9 11 思路: 实现: // Problem: AT4831 [ABC155F] Perils in Parallel // Contest: Luogu // URL: https://www.luogu.com.cn/problem/AT4831 // Memory Limit: 1000 MB // Time Limit: 2000 ms // // Powered by CP Editor (https://cpeditor.org) #include \"ybwhead/ios.h\" typedef int ll; const ll MAXN = 2e5 + 51; struct Node { ll x, y; inline bool operator\u003c(const Node \u0026rhs) const { return this-\u003ex \u003c rhs.x; } }; struct Segment { ll l, r, id; }; struct Edge { ll to, prev, id; }; Node nd[MAXN]; Segment seg[MAXN]; Edge ed[MAXN \u003c\u003c 1]; ll n, m, tot, cnt, l, r, lx, rx, flg, rr; ll last[MAXN], res[MAXN], w[MAXN], c[MAXN], diff[MAXN], vis[MAXN]; inline void addEdge","date":"2020-10-27","objectID":"/posts/oi/problems/at4831/:0:0","series":null,"tags":["Notebooks/OI/OJ/Luogu"],"title":"AT4831-[ABC155F] Perils in Parallel","uri":"/posts/oi/problems/at4831/#"},{"categories":null,"content":"CF915F-Imbalance Value of a Tree 题目: 题目描述: You are given a tree T T T consisting of n n n vertices. A number is written on each vertex; the number written on vertex i i i is ai a_{i} ai​ . Let’s denote the function I(x,y) I(x,y) I(x,y) as the difference between maximum and minimum value of ai a_{i} ai​ on a simple path connecting vertices x x x and y y y . Your task is to calculate . 输入格式: The first line contains one integer number n n n ( 1\u003c=n\u003c=106 1\u003c=n\u003c=10^{6} 1\u003c=n\u003c=106 ) — the number of vertices in the tree. The second line contains n n n integer numbers a1 a_{1} a1​ , a2 a_{2} a2​ , …, an a_{n} an​ ( 1\u003c=ai\u003c=106 1\u003c=a_{i}\u003c=10^{6} 1\u003c=ai​\u003c=106 ) — the numbers written on the vertices. Then n−1 n-1 n−1 lines follow. Each line contains two integers x x x and y y y denoting an edge connecting vertex x x x and vertex y y y ( 1\u003c=x,y\u003c=n 1\u003c=x,y\u003c=n 1\u003c=x,y\u003c=n , x≠y x≠y x=y ). It is guaranteed that these edges denote a tree. 输出格式: Print one number equal to . 样例: 样例输入1: 4 2 2 3 1 1 2 1 3 1 4 样例输出1: 6 思路: 实现: // Problem: CF915F Imbalance Value of a Tree // Contest: Luogu // URL: https://www.luogu.com.cn/problem/CF915F // Memory Limit: 250 MB // Time Limit: 4000 ms // Author: Ybw051114 // // Powered by CP Editor (https://cpeditor.org) #include \"ybwhead/ios.h\" typedef int ll; typedef long long int li; const ll MAXN = 1e6 + 51; struct Edge { ll from, to, mn, mx; inline bool operator\u003c(const Edge \u0026rhs) const { return mn \u003e rhs.mn; } inline bool operator\u003e(const Edge \u0026rhs) const { return mx \u003c rhs.mx; } }; Edge ed[MAXN]; ll n, from, to; li mx, mn; ll x[MAXN], ffa[MAXN], sz[MAXN]; inline ll find(ll x) { return x == ffa[x] ? x : ffa[x] = find(ffa[x]); } inline void merge(ll x, ll y) { ll fx = find(x), fy = find(y); fx != fy ? ffa[fy] = fx, sz[fx] += sz[fy], sz[fy] = 0 : 1; } int main() { yin \u003e\u003e n; for (register int i = 1; i \u003c= n; i++) { yin \u003e\u003e x[i]; ffa[i] = i, sz[i] = 1; } for (register int i = 1; i \u003c n; i++) { yin \u003e\u003e from \u003e\u003e to; ed[i] = (Edge){from, to, min(x[from], x[to]), max(x[from], x[to])}; } sort(ed + 1, ed + n); for (register int i = 1; i \u003c n; i++) { mn += (li)sz[find(ed[i].from)] * sz[find(ed[i].to)] * ed[i].mn; merge(ed[i].from, ed[i].to); } sort(ed + 1, ed + n, greater\u003cEdge\u003e()); for (register int i = 1; i \u003c= n; i++) { ffa[i] = i, sz[i] = 1; } for (register int i = 1; i \u003c n; i++) { mx += (li)sz[find(ed[i].from)] * sz[find(ed[i].to)] * ed[i].mx; merge(ed[i].from, ed[i].to); } yout \u003c\u003c mx - mn \u003c\u003c endl; } ","date":"2020-10-23","objectID":"/posts/oi/problems/cf915f/:0:0","series":null,"tags":["并查集","枚举,暴力","概率论,统计","Notebooks/OI/OJ/Luogu"],"title":"CF915F-Imbalance Value of a Tree","uri":"/posts/oi/problems/cf915f/#"},{"categories":null,"content":"P5495-Dirichlet 前缀和 题目: 题目描述: 给定一个长度为 nnn 的数列 a1,a2,a3,…,ana_1,a_2,a_3,\\dots,a_na1​,a2​,a3​,…,an​。 现在你要求出一个长度为 nnn 的数列 b1,b2,b3,…,bnb_1,b_2,b_3,\\dots,b_nb1​,b2​,b3​,…,bn​，满足 bk=∑i∣kaib_k=\\sum_{i|k}a_ibk​=i∣k∑​ai​由于某些神秘原因，这里的 bkb_kbk​ 要对 2322^{32}232 取模。 输入格式: 为了避免过大的输入，本题的输入使用随机数生成器。 输入中只有一行两个整数 n,seedn,seedn,seed。其中 seedseedseed 为 323232 位无符号整数，用来生成数据。 接下来，你要调用 nnn 次随机数生成器，分别生成 a1∼ana_1\\sim a_na1​∼an​。 对于C/C++选手，生成器模板如下： #define uint unsigned int uint seed; inline uint getnext(){ seed^=seed\u003c\u003c13; seed^=seed\u003e\u003e17; seed^=seed\u003c\u003c5; return seed; } 对于Pascal选手，生成器模板如下： var seed:dword; function getnext:dword; begin seed:=seed xor(seed shl 13); seed:=seed xor(seed shr 17); seed:=seed xor(seed shl 5); getnext:=seed; end; 注意：所有 nnn 个数均为 323232 位无符号整数。 输出格式: 为了避免过大的输出，你只需输出一个 323232 位无符号整数，表示所有 bib_ibi​ 的异或和。 样例: 样例输入1: 5 1477 样例输出1: 2608816472 思路: 类似于埃氏筛和FMT 实现: // Problem: P5495 Dirichlet 前缀和 // Contest: Luogu // URL: https://www.luogu.com.cn/problem/P5495 // Memory Limit: 256 MB // Time Limit: 2000 ms // Author: Ybw051114 // // Powered by CP Editor (https://cpeditor.org) #include \"ybwhead/ios.h\" #define uint unsigned int uint seed; inline uint getnext() { seed ^= seed \u003c\u003c 13; seed ^= seed \u003e\u003e 17; seed ^= seed \u003c\u003c 5; return seed; } uint t[30000000], pri[3000000], cnt, ans; bool prim[30000000]; int main() { uint n; yin \u003e\u003e n \u003e\u003e seed; for (uint i = 2; i \u003c= n; i++) if (!prim[i]) for (uint j = 2 * i; j \u003c= n; j += i) prim[j] = 1; for (uint i = 2; i \u003c= n; i++) if (!prim[i]) pri[++cnt] = i; for (uint i = 1; i \u003c= n; i++) t[i] = getnext(); for (uint i = 1; i \u003c= cnt; i++) { for (uint j = 1; pri[i] * j \u003c= n; j++) { t[j * pri[i]] += t[j]; } } for (uint i = 1; i \u003c= n; i++) { ans ^= t[i]; } yout \u003c\u003c ans; } ","date":"2020-10-17","objectID":"/posts/oi/problems/p5495/:0:0","series":null,"tags":["数论,数学","O2优化","Notebooks/OI/OJ/Luogu"],"title":"P5495-Dirichlet 前缀和","uri":"/posts/oi/problems/p5495/#"},{"categories":null,"content":"P4550-收集邮票 题目: 题目描述: 有n种不同的邮票，皮皮想收集所有种类的邮票。唯一的收集方法是到同学凡凡那里购买，每次只能买一张，并且买到的邮票究竟是n种邮票中的哪一种是等概率的，概率均为1/n。但是由于凡凡也很喜欢邮票，所以皮皮购买第k张邮票需要支付k元钱。 现在皮皮手中没有邮票，皮皮想知道自己得到所有种类的邮票需要花费的钱数目的期望。 输入格式: 一行,一个数字N N\u003c=10000 输出格式: 要付出多少钱. 保留二位小数 样例: 样例输入1: 3 样例输出1: 21.25 思路: 概率题是真的仙 用f[i]f[i]f[i]表示现在取到iii张邮票,要取完剩下邮票的期望次数 显然f[n]=0f[n]=0f[n]=0 现在已经取得iii张邮票,所以下一次取邮票有in\\frac{i}{n}ni​的概率取到已经有的,期望为in∗f[i]\\frac{i}{n}*f[i]ni​∗f[i] 有n−in\\frac{n-i}{n}nn−i​的概率取到没有的,期望为n−in∗f[i+1]\\frac{n-i}{n}*f[i+1]nn−i​∗f[i+1],这次取邮票的期望为1,所以总期望为: f[i]=in∗f[i]+n−in∗f[i+1]+1f[i]=\\frac{i}{n}*f[i]+\\frac{n-i}{n}*f[i+1]+1f[i]=ni​∗f[i]+nn−i​∗f[i+1]+1 化简可得:f[i]=f[i+1]+nn−if[i]=f[i+1]+\\frac{n}{n-i}f[i]=f[i+1]+n−in​ 用g[i]g[i]g[i]表示现在取到iii张邮票,要取完剩下邮票的期望价格 显然g[n]=0g[n]=0g[n]=0 现在已经取得iii张邮票,所以下一次取邮票有in\\frac{i}{n}ni​的概率取到已经有的,期望为in∗(g[i]+f[i]+1)\\frac{i}{n}*(g[i]+f[i]+1)ni​∗(g[i]+f[i]+1),有n−in\\frac{n-i}{n}nn−i​的概率取到没有的,期望为n−in∗(g[i+1]+f[i+1]+1)\\frac{n-i}{n}*(g[i+1]+f[i+1]+1)nn−i​∗(g[i+1]+f[i+1]+1)所以总期望为: g[i]=in∗(g[i]+f[i]+1)+n−in∗(g[i+1]+f[i+1]+1)g[i]=\\frac{i}{n}*(g[i]+f[i]+1)+\\frac{n-i}{n}*(g[i+1]+f[i+1]+1)g[i]=ni​∗(g[i]+f[i]+1)+nn−i​∗(g[i+1]+f[i+1]+1) 化简可得:g[i]=in−i∗f[i]+g[i+1]+f[i+1]+nn−ig[i]=\\frac{i}{n-i}*f[i]+g[i+1]+f[i+1]+\\frac{n}{n-i}g[i]=n−ii​∗f[i]+g[i+1]+f[i+1]+n−in​ 前面的推导貌似很自然的样子,但是为啥g[i]g[i]g[i]的推导式看着就那么奇怪呢? 那是因为式子的结构表示的是每次都将后面取到的邮票费用+1(总费用+f[i]),再加上自己的费用(+1) 这样就很好理解了 为啥不是f[0]∗(f[0]+1)\\/2∗nf[0]*(f[0]+1)\\/2*nf[0]∗(f[0]+1)\\/2∗n我也想了很久 因为推导过来每次的贡献是不相同的 比如说所有情况中有1次需要取2张,1次需要取3张,那么总贡献为(3+6)\\/2=4.5(3+6)\\/2=4.5(3+6)\\/2=4.5,而期望次数为2.5,显然是不对的… 代码比思考简单多了 实现: // Problem: P4550 收集邮票 // Contest: Luogu // URL: https://www.luogu.com.cn/problem/P4550 // Memory Limit: 161.66 MB // Time Limit: 1000 ms // Author: Ybw051114 // // Powered by CP Editor (https://cpeditor.org) #include \"ybwhead/ios.h\" int n; double f[10005], g[10005]; int main() { yin \u003e\u003e n; for (int i = n - 1; ~i; --i) { f[i] = f[i + 1] + (1.0 * n) / (1.0 * (n - i)); g[i] = (1.0 * i) / (1.0 * (n - i)) * (f[i] + 1) + g[i + 1] + f[i + 1] + 1; } printf(\"%.2lf\", g[0]); return 0; } ","date":"2020-10-17","objectID":"/posts/oi/problems/p4550/:0:0","series":null,"tags":["递推","期望","Notebooks/OI/OJ/Luogu"],"title":"P4550-收集邮票","uri":"/posts/oi/problems/p4550/#"},{"categories":null,"content":"CF985F-Isomorphic Strings 题目: 题目描述: You are given a string s s s of length n n n consisting of lowercase English letters. For two given strings s s s and t t t , say S S S is the set of distinct characters of s s s and T T T is the set of distinct characters of t t t . The strings s s s and t t t are isomorphic if their lengths are equal and there is a one-to-one mapping (bijection) f f f between S S S and T T T for which f(si)=ti f(s_{i})=t_{i} f(si​)=ti​ . Formally: f(si)=ti f(s_{i})=t_{i} f(si​)=ti​ for any index i i i , for any character there is exactly one character that f(x)=y f(x)=y f(x)=y , for any character there is exactly one character that f(x)=y f(x)=y f(x)=y . For example, the strings “aababc” and “bbcbcz” are isomorphic. Also the strings “aaaww” and “wwwaa” are isomorphic. The following pairs of strings are not isomorphic: “aab” and “bbb”, “test” and “best”. You have to handle m m m queries characterized by three integers x,y,len x,y,len x,y,len ( 1\u003c=x,y\u003c=n−len+1 1\u003c=x,y\u003c=n-len+1 1\u003c=x,y\u003c=n−len+1 ). For each query check if two substrings s[x... x+len−1] s[x...\\ x+len-1] s[x... x+len−1] and s[y... y+len−1] s[y...\\ y+len-1] s[y... y+len−1] are isomorphic. 输入格式: The first line contains two space-separated integers n n n and m m m ( 1\u003c=n\u003c=2⋅105 1\u003c=n\u003c=2·10^{5} 1\u003c=n\u003c=2⋅105 , 1\u003c=m\u003c=2⋅105 1\u003c=m\u003c=2·10^{5} 1\u003c=m\u003c=2⋅105 ) — the length of the string s s s and the number of queries. The second line contains string s s s consisting of n n n lowercase English letters. The following m m m lines contain a single query on each line: xi x_{i} xi​ , yi y_{i} yi​ and leni len_{i} leni​ ( 1\u003c=xi,yi\u003c=n 1\u003c=x_{i},y_{i}\u003c=n 1\u003c=xi​,yi​\u003c=n , 1\u003c=leni\u003c=n−max(xi,yi)+1 1\u003c=len_{i}\u003c=n-max(x_{i},y_{i})+1 1\u003c=leni​\u003c=n−max(xi​,yi​)+1 ) — the description of the pair of the substrings to check. 输出格式: For each query in a separate line print “YES” if substrings s[xi... xi+leni−1] s[x_{i}...\\ x_{i}+len_{i}-1] s[xi​... xi​+leni​−1] and s[yi... yi+leni−1] s[y_{i}...\\ y_{i}+len_{i}-1] s[yi​... yi​+leni​−1] are isomorphic and “NO” otherwise. 样例: 样例输入1: 7 4 abacaba 1 1 1 1 4 2 2 1 3 2 4 3 样例输出1: YES YES NO YES 思路: 实现: // Problem: CF985F Isomorphic Strings // Contest: Luogu // URL: https://www.luogu.com.cn/problem/CF985F // Memory Limit: 250 MB // Time Limit: 3000 ms // Author: Ybw051114 // // Powered by CP Editor (https://cpeditor.org) #include \"ybwhead/ios.h\" const int MOD1 = 1e9 + 7; const int MOD2 = 1e9 + 9; const int N = 5e5 + 10; #define fi first #define se second typedef pair\u003cint, int\u003e pii; typedef long long ll; const int b1 = 103; const int b2 = 107; pii H[30][N]; int pw1[N], pw2[N]; int n, m; string s; pii Get(pii H[], int l, int r) { pii ans = H[r]; l--; if (l \u003e= 0) { ans.fi = (ans.fi - ll(H[l].fi) * pw1[r - l] % MOD1 + MOD1) % MOD1; ans.se = (ans.se - ll(H[l].se) * pw2[r - l] % MOD2 + MOD2) % MOD2; } return ans; } signed main() { pw1[0] = pw2[0] = 1; yin \u003e\u003e n \u003e\u003e m; yin \u003e\u003e s; for (int i = 1; i \u003c= n; i++) { pw1[i] = 1ll * pw1[i - 1] * b1 % MOD1; pw2[i] = 1ll * pw2[i - 1] * b2 % MOD2; } for (int i = 1; i \u003c= n; i++) for (int j = 0; j \u003c 26; j++) { H[j][i].fi = (ll(H[j][i - 1].fi) * b1 + ll(1 + ('a' + j == s[i - 1]))) % MOD1; H[j][i].se = (ll(H[j][i - 1].se) * b2 + ll(1 + ('a' + j == s[i - 1]))) % MOD2; } while (m--) { int x, y, len; yin \u003e\u003e x \u003e\u003e y \u003e\u003e len; multiset\u003cpii\u003e A, B; for (int i = 0; i \u003c 26; i++) { A.insert(Get(H[i], x, x + len - 1)); B.insert(Get(H[i], y, y + len - 1)); } yout \u003c\u003c (A == B ? \"YES\" : \"NO\") \u003c\u003c endl; } } ","date":"2020-10-15","objectID":"/posts/oi/problems/cf985f/:0:0","series":null,"tags":["Notebooks/OI/OJ/Luogu"],"title":"CF985F-Isomorphic Strings","uri":"/posts/oi/problems/cf985f/#"},{"categories":null,"content":"P6246-[IOI2000] 邮局 加强版 题目: 题目描述: 高速公路旁边有 nnn 个村庄。高速公路表示为整数轴，每个村庄的位置用单个整数坐标标识。两个位置之间的距离是其整数坐标差的绝对值。 现在要建立 mmm 个邮局，邮局将建在一些，但不一定是所有的村庄中。为了建立邮局，应选择他们建造的位置，使每个村庄与其最近的邮局之间的距离总和最小。 你要编写一个程序，已知村庄的位置和邮局的数量，计算每个村庄和最近的邮局之间所有距离的最小可能的总和。 输入格式: 第一行包含两个整数，分别表示村庄的数量 nnn 和邮局的数量 mmm。 第二行共 nnn 个整数，表示每个村庄的坐标，第 iii 个整数表示第 iii 个村庄的坐标 aia_iai​。 输出格式: 输出一行一个整数表示答案。 样例: 样例输入1: 5 2 0 1 2 3 4 样例输出1: 3 思路: 实现: // Problem: P6246 [IOI2000] 邮局 加强版 // Contest: Luogu // URL: https://www.luogu.com.cn/problem/P6246 // Memory Limit: 250 MB // Time Limit: 2000 ms // Author: Ybw051114 // // Powered by CP Editor (https://cpeditor.org) #include \"ybwhead/ios.h\" #define int long long #define reg register const int N = 5e5; const int M = 5e5; using namespace std; struct que { int p, l, r; } q[N + 5]; int n, m, a[N + 5], s[N + 5], f[N + 5], pre[N + 5], ans; inline int dist(int l, int r) { int mid = l + r \u003e\u003e 1; return s[r] - s[mid] - a[mid] * (r - mid) + a[mid] * (mid - l) - (s[mid - 1] - s[l - 1]); } inline int check(int k) { int R = 0; q[++R] = (que){0, 1, n}; for (reg int i = 1; i \u003c= n; i++) { int l = 1, r = R, p, mid; while (l \u003c= r) { mid = l + r \u003e\u003e 1; if (q[mid].l \u003c= i) l = mid + 1, p = mid; else r = mid - 1; } f[i] = f[q[p].p] + dist(q[p].p + 1, i) + k; pre[i] = pre[q[p].p] + 1; p = 0; while (R \u0026\u0026 f[i] + dist(i + 1, q[R].l) + k \u003c= f[q[R].p] + dist(q[R].p + 1, q[R].l) + k) p = q[R--].l; if (R \u0026\u0026 f[i] + dist(i + 1, n) + k \u003c= f[q[R].p] + dist(q[R].p + 1, n) + k) { l = q[R].l, r = n; while (l \u003c= r) { mid = l + r \u003e\u003e 1; if (f[i] + dist(i + 1, mid) + k \u003c= f[q[R].p] + dist(q[R].p + 1, mid) + k) r = mid - 1, p = mid; else l = mid + 1; q[R].r = p - 1; } } if (p) q[++R] = (que){i, p, n}; } return pre[n]; } signed main() { yin \u003e\u003e n \u003e\u003e m; for (reg int i = 1; i \u003c= n; i++) yin \u003e\u003e a[i], s[i] = s[i - 1] + a[i]; int l = 0, r = 3e7, mid; while (l \u003c= r) { mid = l + r \u003e\u003e 1; if (check(mid) \u003e= m) l = mid + 1, ans = f[n] - m * mid; else r = mid - 1; } yout \u003c\u003c ans \u003c\u003c endl; return 0; } ","date":"2020-10-15","objectID":"/posts/oi/problems/p6246/:0:0","series":null,"tags":[2e3,"IOI","O2优化","二分查找","凸完全单调性,凸单调","栈","Notebooks/OI/OJ/Luogu"],"title":"P6246-[IOI2000] 邮局 加强版","uri":"/posts/oi/problems/p6246/#"},{"categories":null,"content":"P4767-[IOI2000]邮局 题目: 题目描述: 高速公路旁边有一些村庄。高速公路表示为整数轴，每个村庄的位置用单个整数坐标标识。没有两个在同样地方的村庄。两个位置之间的距离是其整数坐标差的绝对值。 邮局将建在一些，但不一定是所有的村庄中。为了建立邮局，应选择他们建造的位置，使每个村庄与其最近的邮局之间的距离总和最小。 你要编写一个程序，已知村庄的位置和邮局的数量，计算每个村庄和最近的邮局之间所有距离的最小可能的总和。 输入格式: 第一行包含两个整数：第一个是村庄 VVV 的数量，第二个是邮局的数量 PPP。 第二行包含 VVV 个整数。这些整数是村庄的位置。 输出格式: 第一行包含一个整数SSS，它是每个村庄与其最近的邮局之间的所有距离的总和。 样例: 样例输入1: 10 5 1 2 3 6 7 9 11 22 44 50 样例输出1: 9 思路: 实现: // Problem: P4767 [IOI2000]邮局 // Contest: Luogu // URL: https://www.luogu.com.cn/problem/P4767 // Memory Limit: 125 MB // Time Limit: 1000 ms // Author: Ybw051114 // // Powered by CP Editor (https://cpeditor.org) #include \"ybwhead/ios.h\" #define reg register const int N = 5e5; const int M = 5e5; using namespace std; struct que { int p, l, r; } q[N + 5]; int n, m, a[N + 5], s[N + 5], f[N + 5], pre[N + 5], ans; inline int dist(int l, int r) { int mid = l + r \u003e\u003e 1; return s[r] - s[mid] - a[mid] * (r - mid) + a[mid] * (mid - l) - (s[mid - 1] - s[l - 1]); } inline int check(int k) { int R = 0; q[++R] = (que){0, 1, n}; for (reg int i = 1; i \u003c= n; i++) { int l = 1, r = R, p, mid; while (l \u003c= r) { mid = l + r \u003e\u003e 1; if (q[mid].l \u003c= i) l = mid + 1, p = mid; else r = mid - 1; } f[i] = f[q[p].p] + dist(q[p].p + 1, i) + k; pre[i] = pre[q[p].p] + 1; p = 0; while (R \u0026\u0026 f[i] + dist(i + 1, q[R].l) + k \u003c= f[q[R].p] + dist(q[R].p + 1, q[R].l) + k) p = q[R--].l; if (R \u0026\u0026 f[i] + dist(i + 1, n) + k \u003c= f[q[R].p] + dist(q[R].p + 1, n) + k) { l = q[R].l, r = n; while (l \u003c= r) { mid = l + r \u003e\u003e 1; if (f[i] + dist(i + 1, mid) + k \u003c= f[q[R].p] + dist(q[R].p + 1, mid) + k) r = mid - 1, p = mid; else l = mid + 1; q[R].r = p - 1; } } if (p) q[++R] = (que){i, p, n}; } return pre[n]; } int main() { yin \u003e\u003e n \u003e\u003e m; for (reg int i = 1; i \u003c= n; i++) yin \u003e\u003e a[i], s[i] = s[i - 1] + a[i]; int l = 0, r = 3e7, mid; while (l \u003c= r) { mid = l + r \u003e\u003e 1; if (check(mid) \u003e= m) l = mid + 1, ans = f[n] - m * mid; else r = mid - 1; } yout \u003c\u003c ans \u003c\u003c endl; return 0; } ","date":"2020-10-15","objectID":"/posts/oi/problems/p4767/:0:0","series":null,"tags":["数论,数学",2e3,"IOI","枚举,暴力","区间动规,区间dp","四边形不等式","Notebooks/OI/OJ/Luogu"],"title":"P4767-[IOI2000]邮局","uri":"/posts/oi/problems/p4767/#"},{"categories":null,"content":"P4728-[HNOI2009]双递增序列 题目: 题目描述: 考虑一个长度为偶数 nnn 的序列 a1,a2,…,ana_1, a_2, \\dots, a_na1​,a2​,…,an​，我们称这个序列为好的，当且仅当存在 a1,a2,…,ana_1, a_2, \\dots, a_na1​,a2​,…,an​ 的一个划分 U={ai1,ai2,…,ain/2},V={aj1,aj2,…,ajn/2}={a1,a2,…,an}−UU=\\{ a_{i_1}, a_{i_2}, \\dots, a_{i_{n/2}} \\}, V=\\{ a_{j_1}, a_{j_2}, \\dots, a_{j_{n/2}} \\}=\\{ a_1, a_2, \\dots, a_n \\}-UU={ai1​​,ai2​​,…,ain/2​​},V={aj1​​,aj2​​,…,ajn/2​​}={a1​,a2​,…,an​}−U，且 i1\u003ci2\u003c⋯\u003cin/2,ai1\u003cai2\u003c⋯\u003cain/2,j1\u003cj2\u003c⋯\u003cjn/2,aj1\u003caj2\u003c⋯\u003cajn/2i_1\u003ci_2\u003c \\dots \u003ci_{n/2}, a_{i_1}\u003ca_{i_2}\u003c \\dots \u003ca_{i_{n/2}}, j_1\u003cj_2\u003c \\dots \u003cj_{n/2}, a_{j_1}\u003ca_{j_2}\u003c \\dots \u003ca_{j_{n/2}}i1​\u003ci2​\u003c⋯\u003cin/2​,ai1​​\u003cai2​​\u003c⋯\u003cain/2​​,j1​\u003cj2​\u003c⋯\u003cjn/2​,aj1​​\u003caj2​​\u003c⋯\u003cajn/2​​。 比如序列 3,1,4,5,8,73, 1, 4, 5, 8, 73,1,4,5,8,7 就是一个好的序列。因为它可以分成 U={3,4,8},V={1,5,7}U=\\{3, 4, 8\\}, V=\\{1, 5, 7\\}U={3,4,8},V={1,5,7}。而序列 3,2,1,6,5,43, 2, 1, 6, 5, 43,2,1,6,5,4 则不是一个好的序列。 现在的问题是，针对给出的若干序列，请你判断它们是否是好的序列。 输入格式: 第一行仅包含一个整数 mmm，表示需要判断 mmm 个序列。 接下来的 mmm 行分别给出这些序列。每个序列的输入为一行，每行的第一个数为一个偶数 nnn，表示序列的长度，随后的 nnn 个整数表示序列本身的元素 a1,a2,…,ana_1, a_2, \\dots, a_na1​,a2​,…,an​。同一行的各数之间用一个空格隔开。 输出格式: 输出 mmm 行，如果第 iii 个序列为好的序列，那么第 iii 行输出 Yes! ，否则输出 No! 。 样例: 样例输入1: 2 6 3 1 4 5 8 7 6 3 2 1 6 5 4 样例输出1: Yes! No! 思路: 实现: // Problem: P4728 [HNOI2009]双递增序列 // Contest: Luogu // URL: https://www.luogu.com.cn/problem/P4728 // Memory Limit: 125 MB // Time Limit: 2000 ms // Author: Ybw051114 // // Powered by CP Editor (https://cpeditor.org) #include \"ybwhead/ios.h\" int n; const int maxn = 2010; const int inf = 0x3f3f3f3f; int f[maxn][maxn], a[maxn]; int main() { int TTT; yin \u003e\u003e TTT; while (TTT--) { yin \u003e\u003e n; for (int i = 1; i \u003c= n; i++) yin \u003e\u003e a[i]; memset(f, 0x3f3f3f3f, sizeof(f)); f[1][1] = -1; for (int i = 1; i \u003c n; i++) { for (int j = 1; j \u003c= min(n \u003e\u003e 1, i); j++) { if (a[i] \u003c a[i + 1]) f[i + 1][j + 1] = min(f[i + 1][j + 1], f[i][j]); if (a[i + 1] \u003e f[i][j]) f[i + 1][i - j + 1] = min(f[i + 1][i - j + 1], a[i]); } } if (f[n][n \u003e\u003e 1] == inf) { yout \u003c\u003c \"No!\" \u003c\u003c endl; } else { yout \u003c\u003c \"Yes!\" \u003c\u003c endl; } } return 0; } ","date":"2020-10-07","objectID":"/posts/oi/problems/p4728/:0:0","series":null,"tags":["dp",2009,"各省省选","湖南","Notebooks/OI/OJ/Luogu"],"title":"P4728-[HNOI2009]双递增序列","uri":"/posts/oi/problems/p4728/#"},{"categories":null,"content":"P3224-[HNOI2012]永无乡 题目: 题目描述: 永无乡包含 nnn 座岛，编号从 111 到 nnn ，每座岛都有自己的独一无二的重要度，按照重要度可以将这 nnn 座岛排名，名次用 111 到 nnn 来表示。某些岛之间由巨大的桥连接，通过桥可以从一个岛到达另一个岛。如果从岛 aaa 出发经过若干座（含 000 座）桥可以 到达岛 bbb ，则称岛 aaa 和岛 bbb 是连通的。 现在有两种操作： B x y 表示在岛 xxx 与岛 yyy 之间修建一座新桥。 Q x k 表示询问当前与岛 xxx 连通的所有岛中第 kkk 重要的是哪座岛，即所有与岛 xxx 连通的岛中重要度排名第 kkk 小的岛是哪座，请你输出那个岛的编号。 输入格式: 第一行是用空格隔开的两个整数，分别表示岛的个数 nnn 以及一开始存在的桥数 mmm。 第二行有 nnn 个整数，第 iii 个整数表示编号为 iii 的岛屿的排名 pip_ipi​。 接下来 mmm 行，每行两个整数 u,vu, vu,v，表示一开始存在一座连接编号为 uuu 的岛屿和编号为 vvv 的岛屿的桥。 接下来一行有一个整数，表示操作个数 qqq。 接下来 qqq 行，每行描述一个操作。每行首先有一个字符 opopop，表示操作类型，然后有两个整数 x,yx, yx,y。 若 opopop 为 Q，则表示询问所有与岛 xxx 连通的岛中重要度排名第 yyy 小的岛是哪座，请你输出那个岛的编号。 若 opopop 为 B，则表示在岛 xxx 与岛 yyy 之间修建一座新桥。 输出格式: 对于每个询问操作都要依次输出一行一个整数，表示所询问岛屿的编号。如果该岛屿不存在，则输出 −1-1−1 。 样例: 样例输入1: 5 1 4 3 2 5 1 1 2 7 Q 3 2 Q 2 1 B 2 3 B 1 5 Q 2 1 Q 2 4 Q 2 3 样例输出1: -1 2 5 1 2 思路: 实现: // Problem: P3224 [HNOI2012]永无乡 // Contest: Luogu // URL: https://www.luogu.com.cn/problem/P3224 // Memory Limit: 125 MB // Time Limit: 1000 ms // Author: Ybw051114 // // Powered by CP Editor (https://cpeditor.org) #include \"ybwhead/ios.h\" #include \u003cext/pb_ds/assoc_container.hpp\u003e #include \u003cext/pb_ds/tree_policy.hpp\u003e //把这两个东西背下来 int Read() { int x = 0; char c = getchar(); while (!isdigit(c)) c = getchar(); while (isdigit(c)) { x = x * 10 + (c ^ 48); c = getchar(); } return x; } using namespace __gnu_pbds; //把这个命名空间背下来 int imp[100005], fa[100005]; //重要程度，并查集 void init_set(int n) { for (int i = 1; i \u003c= n; ++i) fa[i] = i; } int find(int x) { return x == fa[x] ? x : fa[x] = find(fa[x]); } void uni_set(int x, int y) { x = find(x), y = find(y); fa[x] = y; } typedef tree\u003cint, int, std::greater\u003cint\u003e, rb_tree_tag, tree_order_statistics_node_update\u003e Tree; Tree block[100005]; //每个点一棵红黑树，资瓷查询第k大 void init_tree(int n) { for (int i = 1; i \u003c= n; ++i) block[find(i)].insert(std::pair\u003cint, int\u003e(imp[i], i)); } //以重要度为关键字 void uni_tree(int x, int y) { //启发式合并 x = fa[x], y = fa[y]; if (x == y) //如果已在同一联通块中，直接返回 return; int size_x = block[x].size(), size_y = block[y].size(); if (size_x \u003e size_y) std::swap(x, y); //x更小 Tree::point_iterator it = block[x].begin(); for (; it != block[x].end(); ++it) { block[y].insert(std::pair\u003cint, int\u003e(it-\u003efirst, it-\u003esecond)); // block[x].erase(it); } uni_set(x, y); } int main() { int n = Read(), m = Read(); init_set(n); for (int i = 1; i \u003c= n; ++i) imp[i] = Read(); for (int i = 0; i \u003c m; ++i) uni_set(Read(), Read()); init_tree(n); int q = Read(); char opt[5]; for (int i = 0; i \u003c q; ++i) { scanf(\"%s\", opt); if (opt[0] == 'B') uni_tree(Read(), Read()); else { int father = find(Read()); int k = Read(); if (k \u003e block[father].size()) puts(\"-1\"); else //注意，find_by_order找的是第k大，而且从0开始排 printf(\"%d\\n\", block[father].find_by_order(block[father].size() - k)-\u003esecond); } } return 0; } ","date":"2020-10-06","objectID":"/posts/oi/problems/p3224/:0:0","series":null,"tags":[2012,"线段树","平衡树","湖南","Splay","高性能","Notebooks/OI/OJ/Luogu"],"title":"P3224-[HNOI2012]永无乡","uri":"/posts/oi/problems/p3224/#"},{"categories":null,"content":"P5205-【模板】多项式开根 题目: 题目描述: 给定一个n−1n-1n−1次多项式A(x)A(x)A(x)，求一个在 mod xn\\bmod\\ x^nmod xn意义下的多项式B(x)B(x)B(x)，使得B2(x)≡A(x) ( mod xn)B^2(x) \\equiv A(x) \\ (\\bmod\\ x^n)B2(x)≡A(x) (mod xn)。若有多解，请取零次项系数较小的作为答案。 多项式的系数在 mod 998244353\\bmod\\ 998244353mod 998244353的意义下进行运算。 输入格式: 第一行一个正整数nnn。 接下来nnn个整数，依次表示多项式的系数a0,a1,…,an−1a_0, a_1, \\dots, a_{n-1}a0​,a1​,…,an−1​ 保证a0=1a_0 = 1a0​=1. 输出格式: 输出nnn个整数，表示答案多项式的系数b0,b1,…,bn−1b_0, b_1, \\dots, b_{n-1}b0​,b1​,…,bn−1​ 样例: 样例输入1: 3 1 2 1 样例输出1: 1 1 0 样例输入2: 7 1 8596489 489489 4894 1564 489 35789489 样例输出2: 1 503420421 924499237 13354513 217017417 707895465 411020414 思路: 实现: // Problem: P5205 【模板】多项式开根 // Contest: Luogu // URL: https://www.luogu.com.cn/problem/P5205 // Memory Limit: 125 MB // Time Limit: 1000 ms // Author: Ybw051114 // // Powered by CP Editor (https://cpeditor.org) #include \"ybwhead/ios.h\" const int maxn = 400000 + 10; const int mod = 998244353; const int inv2 = 499122177; int n, a[maxn], b[maxn], A[maxn], B[maxn], C[maxn], D[maxn], r[maxn]; int fpow(int a, int b) { int ret = 1; for (; b; b \u003e\u003e= 1, a = 1ll * a * a % mod) if (b \u0026 1) ret = 1ll * ret * a % mod; return ret; } void NTT(int *f, int n, int op) { for (int i = 0; i \u003c n; i++) if (i \u003c r[i]) swap(f[i], f[r[i]]); int buf, tmp, x, y; for (int len = 1; len \u003c n; len \u003c\u003c= 1) { tmp = fpow(3, (mod - 1) / (len \u003c\u003c 1)); if (op == -1) tmp = fpow(tmp, mod - 2); for (int i = 0; i \u003c n; i += len \u003c\u003c 1) { buf = 1; for (int j = 0; j \u003c len; j++) { x = f[i + j]; y = 1ll * buf * f[i + j + len] % mod; f[i + j] = (x + y) % mod; f[i + j + len] = (x - y + mod) % mod; buf = 1ll * buf * tmp % mod; } } } if (op == 1) return; int inv = fpow(n, mod - 2); for (int i = 0; i \u003c n; i++) f[i] = 1ll * f[i] * inv % mod; } void Inv(int *a, int *b, int n) { b[0] = fpow(a[0], mod - 2); int len, lim; for (len = 1; len \u003c (n \u003c\u003c 1); len \u003c\u003c= 1) { lim = len \u003c\u003c 1; for (int i = 0; i \u003c len; i++) A[i] = a[i], B[i] = b[i]; for (int i = 0; i \u003c lim; i++) r[i] = (r[i \u003e\u003e 1] \u003e\u003e 1) | ((i \u0026 1) ? len : 0); NTT(A, lim, 1); NTT(B, lim, 1); for (int i = 0; i \u003c lim; i++) b[i] = ((2ll - 1ll * A[i] * B[i] % mod) * B[i] % mod + mod) % mod; NTT(b, lim, -1); for (int i = len; i \u003c lim; i++) b[i] = 0; } for (int i = 0; i \u003c len; i++) A[i] = B[i] = 0; for (int i = n; i \u003c len; i++) b[i] = 0; } void Sqrt(int *a, int *b, int n) { b[0] = 1; int *A = C, *B = D, len, lim; for (len = 1; len \u003c (n \u003c\u003c 1); len \u003c\u003c= 1) { lim = len \u003c\u003c 1; for (int i = 0; i \u003c len; i++) A[i] = a[i]; Inv(b, B, lim \u003e\u003e 1); for (int i = 0; i \u003c lim; i++) r[i] = (r[i \u003e\u003e 1] \u003e\u003e 1) | ((i \u0026 1) ? len : 0); NTT(A, lim, 1); NTT(B, lim, 1); for (int i = 0; i \u003c lim; i++) A[i] = 1ll * A[i] * B[i] % mod; NTT(A, lim, -1); for (int i = 0; i \u003c len; i++) b[i] = 1ll * (b[i] + A[i]) % mod * inv2 % mod; for (int i = len; i \u003c lim; i++) b[i] = 0; } for (int i = 0; i \u003c len; i++) A[i] = B[i] = 0; for (int i = n; i \u003c len; i++) b[i] = 0; } int main() { yin \u003e\u003e n; for (int i = 0; i \u003c n; ++i) yin \u003e\u003e a[i]; Sqrt(a, b, n); for (int i = 0; i \u003c n; i++) yout \u003c\u003c b[i] \u003c\u003c \" \"; yout \u003c\u003c endl; return 0; } ","date":"2020-10-06","objectID":"/posts/oi/problems/p5205/:0:0","series":null,"tags":["Notebooks/OI/OJ/Luogu"],"title":"P5205-【模板】多项式开根","uri":"/posts/oi/problems/p5205/#"},{"categories":null,"content":"CF525D-Arthur and Walls 题目: 题目描述: Finally it is a day when Arthur has enough money for buying an apartment. He found a great option close to the center of the city with a nice price. Plan of the apartment found by Arthur looks like a rectangle n×m n×m n×m consisting of squares of size 1×1 1×1 1×1 . Each of those squares contains either a wall (such square is denoted by a symbol “*” on the plan) or a free space (such square is denoted on the plan by a symbol “.”). Room in an apartment is a maximal connected area consisting of free squares. Squares are considered adjacent if they share a common side. The old Arthur dream is to live in an apartment where all rooms are rectangles. He asks you to calculate minimum number of walls you need to remove in order to achieve this goal. After removing a wall from a square it becomes a free square. While removing the walls it is possible that some rooms unite into a single one. 输入格式: The first line of the input contains two integers n,m n,m n,m ( 1\u003c=n,m\u003c=2000 1\u003c=n,m\u003c=2000 1\u003c=n,m\u003c=2000 ) denoting the size of the Arthur apartments. Following n n n lines each contain m m m symbols — the plan of the apartment. If the cell is denoted by a symbol “*” then it contains a wall. If the cell is denoted by a symbol “.” then it this cell is free from walls and also this cell is contained in some of the rooms. 输出格式: Output n n n rows each consisting of m m m symbols that show how the Arthur apartment plan should look like after deleting the minimum number of walls in order to make each room (maximum connected area free from walls) be a rectangle. If there are several possible answers, output any of them. 样例: 样例输入1: 5 5 .*.*. ***** .*.*. ***** .*.*. 样例输出1: .*.*. ***** .*.*. ***** .*.*. 样例输入2: 6 7 ***.*.* ..*.*.* *.*.*.* *.*.*.* ..*...* ******* 样例输出2: ***...* ..*...* ..*...* ..*...* ..*...* ******* 样例输入3: 4 5 ..... ..... ..*** ..*.. 样例输出3: ..... ..... ..... ..... 思路: 实现: #include \"ybwhead/ios.h\" int n, m; char cc[5000][5000]; queue\u003cpair\u003cint, int\u003e\u003e q; int dx[] = {1, -1, 0, 0, 1, -1, 1, -1}; int dy[] = {0, 0, 1, -1, 1, -1, -1, 1}; bool check(int i, int j) { if (i \u003c 1 || i \u003e n || j \u003c 1 || j \u003e m) return 0; if ((cc[i - 1][j] == '.' \u0026\u0026 cc[i][j - 1] == '.' \u0026\u0026 cc[i - 1][j - 1] == '.') || (cc[i + 1][j] == '.' \u0026\u0026 cc[i][j - 1] == '.' \u0026\u0026 cc[i + 1][j - 1] == '.') || (cc[i - 1][j] == '.' \u0026\u0026 cc[i][j + 1] == '.' \u0026\u0026 cc[i - 1][j + 1] == '.') || (cc[i + 1][j] == '.' \u0026\u0026 cc[i][j + 1] == '.' \u0026\u0026 cc[i + 1][j + 1] == '.')) return 1; return 0; } int main() { yin \u003e\u003e n \u003e\u003e m; for (int i = 1; i \u003c= n; i++) for (int j = 1; j \u003c= m; j++) { yin \u003e\u003e cc[i][j]; if (cc[i][j] == '.') q.push(make_pair(i, j)); } while (!q.empty()) { int i = q.front().first, j = q.front().second; q.pop(); for (int now = 0; now \u003c 8; now++) { if (cc[i + dx[now]][j + dy[now]] == '*' \u0026\u0026 check(i + dx[now], j + dy[now])) { cc[i + dx[now]][j + dy[now]] = '.'; q.push(make_pair(i + dx[now], j + dy[now])); } } } for (int i = 1; i \u003c= n; i++) { for (int j = 1; j \u003c= m; j++) yout \u003c\u003c cc[i][j]; yout \u003c\u003c \"\\n\"; } } ","date":"2020-10-04","objectID":"/posts/oi/problems/cf525d/:0:0","series":null,"tags":["Notebooks/OI/OJ/Luogu"],"title":"CF525D-Arthur and Walls","uri":"/posts/oi/problems/cf525d/#"},{"categories":null,"content":"CF662B-Graph Coloring 题目: 题目描述: You are given an undirected graph that consists of n n n vertices and m m m edges. Initially, each edge is colored either red or blue. Each turn a player picks a single vertex and switches the color of all edges incident to it. That is, all red edges with an endpoint in this vertex change the color to blue, while all blue edges with an endpoint in this vertex change the color to red. Find the minimum possible number of moves required to make the colors of all edges equal. 输入格式: The first line of the input contains two integers n n n and m m m ( 1\u003c=n,m\u003c=100000 1\u003c=n,m\u003c=100000 1\u003c=n,m\u003c=100000 ) — the number of vertices and edges, respectively. The following m m m lines provide the description of the edges, as the i i i -th of them contains two integers ui u_{i} ui​ and vi v_{i} vi​ ( 1\u003c=ui,vi\u003c=n 1\u003c=u_{i},v_{i}\u003c=n 1\u003c=ui​,vi​\u003c=n , ui≠vi u_{i}≠v_{i} ui​=vi​ ) — the indices of the vertices connected by the i i i -th edge, and a character ci c_{i} ci​ () providing the initial color of this edge. If ci c_{i} ci​ equals ‘R’, then this edge is initially colored red. Otherwise, ci c_{i} ci​ is equal to ‘B’ and this edge is initially colored blue. It’s guaranteed that there are no self-loops and multiple edges. 输出格式: If there is no way to make the colors of all edges equal output −1 -1 −1 in the only line of the output. Otherwise first output k k k — the minimum number of moves required to achieve the goal, then output k k k integers a1,a2,...,ak a_{1},a_{2},...,a_{k} a1​,a2​,...,ak​ , where ai a_{i} ai​ is equal to the index of the vertex that should be used at the i i i -th move. If there are multiple optimal sequences of moves, output any of them. 样例: 样例输入1: 3 3 1 2 B 3 1 R 3 2 B 样例输出1: 1 2 样例输入2: 6 5 1 3 R 2 3 R 3 4 B 4 5 R 4 6 R 样例输出2: 2 3 4 样例输入3: 4 5 1 2 R 1 3 R 2 3 B 3 4 B 1 4 B 样例输出3: -1 思路: 实现: #include\u003ccstdio\u003e #include\u003ccstring\u003e #include\u003cqueue\u003e using namespace std; #define rep(i,__l,__r) for(signed i=(__l),i##_end_=(__r);i\u003c=i##_end_;++i) #define fep(i,__l,__r) for(signed i=(__l),i##_end_=(__r);i\u003e=i##_end_;--i) #define erep(i,u) for(signed i=tail[u],v=e[i].to;i;i=e[i].nxt,v=e[i].to) #define writc(a,b) fwrit(a),putchar(b) #define mp(a,b) make_pair(a,b) #define ft first #define sd second typedef long long LL; // typedef pair\u003cint,int\u003e pii; typedef unsigned long long ull; typedef unsigned uint; #define Endl putchar('\\n') // #define int long long // #define int unsigned // #define int unsigned long long #define cg (c=getchar()) template\u003cclass T\u003einline void read(T\u0026 x){ char c;bool f=0; while(cg\u003c'0'||'9'\u003cc)f|=(c=='-'); for(x=(c^48);'0'\u003c=cg\u0026\u0026c\u003c='9';x=(x\u003c\u003c1)+(x\u003c\u003c3)+(c^48)); if(f)x=-x; } template\u003cclass T\u003einline T read(const T sample){ T x=0;char c;bool f=0; while(cg\u003c'0'||'9'\u003cc)f|=(c=='-'); for(x=(c^48);'0'\u003c=cg\u0026\u0026c\u003c='9';x=(x\u003c\u003c1)+(x\u003c\u003c3)+(c^48)); return f?-x:x; } template\u003cclass T\u003evoid fwrit(const T x){//just short,int and long long if(x\u003c0)return (void)(putchar('-'),fwrit(-x)); if(x\u003e9)fwrit(x/10); putchar(x%10^48); } template\u003cclass T\u003einline T Max(const T x,const T y){return x\u003ey?x:y;} template\u003cclass T\u003einline T Min(const T x,const T y){return x\u003cy?x:y;} template\u003cclass T\u003einline T fab(const T x){return x\u003e0?x:-x;} inline int gcd(const int a,const int b){return b?gcd(b,a%b):a;} inline void getInv(int inv[],const int lim,const int MOD){ inv[0]=inv[1]=1;for(int i=2;i\u003c=lim;++i)inv[i]=1ll*inv[MOD%i]*(MOD-MOD/i)%MOD; } inline LL mulMod(const LL a,const LL b,const LL mod){//long long multiplie_mod return ((a*b-(LL)((long double)a/mod*b+1e-8)*mod)%mod+mod)%mod; } const int MAXN=100000; const int MAXM=100000; const int INF=(1\u003c\u003c30)-1; struct edge{int to,nxt,c;}e[MAXM*2+5]; int tail[MAXN+5],ecnt; inline void add_edge(const int u,const int v,const int c){ e[++ecnt]=edge{v,tail[u],c};tail[u]=ecnt; e[++ecnt]=edge{u,tail[v],c};tail[v]=ecnt; } int n,m; inline void Init(){ n=read(1),m=read(1); int u,v;char ch[5]; rep(i,1,m){ scanf(\"%d %d %s\",\u0026u,\u0026v,ch); add_edge(u,v,ch[0]=='R'); } } int rever[MAXN+5]; void Clear(const int u){ rever[u]=-1","date":"2020-10-03","objectID":"/posts/oi/problems/cf662b/:0:0","series":null,"tags":["Notebooks/OI/OJ/Luogu"],"title":"CF662B-Graph Coloring","uri":"/posts/oi/problems/cf662b/#"},{"categories":null,"content":"CF1120D-Power Tree 题目: 题目描述: You are given a rooted tree with n n n vertices, the root of the tree is the vertex 1 1 1 . Each vertex has some non-negative price. A leaf of the tree is a non-root vertex that has degree 1 1 1 . Arkady and Vasily play a strange game on the tree. The game consists of three stages. On the first stage Arkady buys some non-empty set of vertices of the tree. On the second stage Vasily puts some integers into all leaves of the tree. On the third stage Arkady can perform several (possibly none) operations of the following kind: choose some vertex v v v he bought on the first stage and some integer x x x , and then add x x x to all integers in the leaves in the subtree of v v v . The integer x x x can be positive, negative of zero. A leaf a a a is in the subtree of a vertex b b b if and only if the simple path between a a a and the root goes through b b b . Arkady’s task is to make all integers in the leaves equal to zero. What is the minimum total cost s s s he has to pay on the first stage to guarantee his own win independently of the integers Vasily puts on the second stage? Also, we ask you to find all such vertices that there is an optimal (i.e. with cost s s s ) set of vertices containing this one such that Arkady can guarantee his own win buying this set on the first stage. 输入格式: The first line contains a single integer n n n ( 2≤n≤200 000 2 \\le n \\le 200\\,000 2≤n≤200000 ) — the number of vertices in the tree. The second line contains n n n integers c1,c2,…,cn c_1, c_2, \\ldots, c_n c1​,c2​,…,cn​ ( 0≤ci≤109 0 \\le c_i \\le 10^9 0≤ci​≤109 ), where ci c_i ci​ is the price of the i i i -th vertex. Each of the next n−1 n - 1 n−1 lines contains two integers a a a and b b b ( 1≤a,b≤n 1 \\le a, b \\le n 1≤a,b≤n ), denoting an edge of the tree. 输出格式: In the first line print two integers: the minimum possible cost s s s Arkady has to pay to guarantee his own win, and the number of vertices k k k that belong to at least one optimal set. In the second line print k k k distinct integers in increasing order the indices of the vertices that belong to at least one optimal set. 样例: 样例输入1: 5 5 1 3 2 1 1 2 2 3 2 4 1 5 样例输出1: 4 3 2 4 5 样例输入2: 3 1 1 1 1 2 1 3 样例输出2: 2 3 1 2 3 思路: 实现: #include \u003cbits/stdc++.h\u003e using namespace std; #define LL long long const int maxn = 2e5 + 5; int n, deg[maxn], w[maxn]; LL d[maxn][2]; vector\u003cint\u003e G[maxn]; vector\u003cint\u003e p[maxn][2]; void dfs(int u, int fa) { if (deg[u] == 1 \u0026\u0026 fa) { d[u][1] = w[u], d[u][0] = 0; return; } LL tmp = 0; for (int i = 0, v; i \u003c G[u].size(); ++i) if ((v = G[u][i]) != fa) { dfs(v, u); tmp += d[v][1]; } d[u][1] = d[u][0] = tmp; for (int i = 0, v; i \u003c G[u].size(); ++i) if ((v = G[u][i]) != fa) { d[u][1] = min(d[u][1], tmp - d[v][1] + d[v][0] + w[u]), d[u][0] = min(d[u][0], tmp - d[v][1] + d[v][0]); } for (int i = 0, v; i \u003c G[u].size(); ++i) if ((v = G[u][i]) != fa) { if (d[u][1] == tmp - d[v][1] + d[v][0] + w[u]) p[u][1].push_back(v); if (d[u][0] == tmp - d[v][1] + d[v][0]) p[u][0].push_back(v); //转移可能多于一种，用vector存 } } bool chose[maxn], vis[maxn][2]; struct Node { int u, fa, tp; }; queue\u003cNode\u003e Q; void bfs() { Q.push((Node){1, 0, 1}); while (!Q.empty()) { int u = Q.front().u, fa = Q.front().fa, tp = Q.front().tp; Q.pop(); if (deg[u] == 1 \u0026\u0026 fa) { if (tp) chose[u] = 1; continue; } //在这里重新做一遍……主要是要特判一些特殊的情况 LL tmp = 0; for (int i = 0, v; i \u003c G[u].size(); ++i) if ((v = G[u][i]) != fa) { tmp += d[v][1]; } if (tmp == d[u][tp]) //在这种情况下p不一定为空，而如果不进行这个特判可能会使后面原本可以作为d(v,1)的v被跳过 { for (int i = 0, v; i \u003c G[u].size(); ++i) if ((v = G[u][i]) != fa \u0026\u0026 !vis[v][1]) vis[v][1] = 1, Q.push((Node){v, u, 1}); } if (p[u][tp].size() == 1) //它和之前的并不互斥 { if (tp || w[u] == 0) chose[u] = 1; for (int i = 0, v; i \u003c G[u].size(); ++i) if ((v = G[u][i]) != fa \u0026\u0026 v != p[u][tp][0] \u0026\u0026 !vis[v][1]) { vis[v][1] = 1; Q.push((Node){v, u, 1}); } if (!vis[p[u][tp][0]][0]) vis[p[u][tp][0]][0] = 1, Q.push((Node){p[u][tp][0], u, 0}); } else if (p[u][tp].size() \u003e 1) { //在这种情况下，所有子节点都有可能作为d(v,1)加入 if (tp || w[u] == 0","date":"2020-10-02","objectID":"/posts/oi/problems/cf1120d/:0:0","series":null,"tags":["Notebooks/OI/OJ/Luogu"],"title":"CF1120D-Power Tree","uri":"/posts/oi/problems/cf1120d/#"},{"categories":null,"content":"CF835F-Roads in the Kingdom 题目: 题目描述: In the Kingdom K., there are n n n towns numbered with integers from 1 1 1 to n n n . The towns are connected by n n n bi-directional roads numbered with integers from 1 1 1 to n n n . The i i i -th road connects the towns ui u_{i} ui​ and vi v_{i} vi​ and its length is li l_{i} li​ . There is no more than one road between two towns. Also, there are no roads that connect the towns with itself. Let’s call the inconvenience of the roads the maximum of the shortest distances between all pairs of towns. Because of lack of money, it was decided to close down one of the roads so that after its removal it is still possible to reach any town from any other. You have to find the minimum possible inconvenience of the roads after closing down one of the roads. 输入格式: The first line contains the integer n n n ( 3\u003c=n\u003c=2⋅105 3\u003c=n\u003c=2·10^{5} 3\u003c=n\u003c=2⋅105 ) — the number of towns and roads. The next n n n lines contain the roads description. The i i i -th from these lines contains three integers ui u_{i} ui​ , vi v_{i} vi​ , li l_{i} li​ ( 1\u003c=ui,vi\u003c=n 1\u003c=u_{i},v_{i}\u003c=n 1\u003c=ui​,vi​\u003c=n , 1\u003c=li\u003c=109 1\u003c=l_{i}\u003c=10^{9} 1\u003c=li​\u003c=109 ) — the numbers of towns connected by the i i i -th road and the length of the i i i -th road. No road connects a town to itself, no two roads connect the same towns. It’s guaranteed that it’s always possible to close down one of the roads so that all the towns are still reachable from each other. 输出格式: Print a single integer — the minimum possible inconvenience of the roads after the refusal from one of the roads. 样例: 样例输入 1: 3 1 2 4 2 3 5 1 3 1 样例输出 1: 5 样例输入 2: 5 2 3 7 3 1 9 4 1 8 3 5 4 4 5 5 样例输出 2: 18 思路: 实现: #include \"ybwhead/ios.h\" #define MAX (200000 + 7) #define long long long int N, M, c[MAX], use[MAX], head[MAX]; long ans1, ans2, FA, v[MAX], f[MAX], L[MAX], L0[MAX], R[MAX], R0[MAX]; struct edge { int y, z, nxt; } E[MAX \u003c\u003c 1]; void add(int x, int y, int z, int i) { E[i] = edge{y, z, head[x]}; head[x] = i; } #define y E[p].y #define z E[p].z int DFS(int x, int fa) { if (use[x]) return x; use[x] = 1; for (int p = head[x]; p; p = E[p].nxt) if (y != fa) { FA = DFS(y, x); if (FA) { c[++M] = x; v[M] = z; use[x] = 2; return FA == x ? 0 : FA; } } return 0; } void DFS2(int x, int fa) { for (int p = head[x]; p; p = E[p].nxt) if (use[y] != 2 \u0026\u0026 y != fa) { DFS2(y, x); ans1 = max(ans1, f[x] + f[y] + z); f[x] = max(f[x], f[y] + z); } } #undef y #undef z int main() { yin \u003e\u003e N; for (int i = 1, x, y, z; i \u003c= N; i++) { yin \u003e\u003e x \u003e\u003e y \u003e\u003e z; add(x, y, z, i * 2); add(y, x, z, i * 2 - 1); } DFS(1, -1); //找环，求解c，v数组。 for (int i = 1; i \u003c= M; i++) DFS2(c[i], 0), v[i] += v[i - 1]; //求解ans1，f数组并计算v的前缀和 //以上为树的直径知识 FA = L[0] = L0[0] = -1e18; for (int i = 1; i \u003c= M; i++) { //从左向右更新L和L0 L0[i] = max(L0[i - 1], f[c[i]] + v[i] + FA); L[i] = max(L[i - 1], f[c[i]] + v[i]); FA = max(FA, f[c[i]] - v[i]); //更新当前f[i]-c[i]最大值 } FA = R[M + 1] = R0[M + 1] = -1e18; for (int i = M; i \u003e= 1; i--) { //同上 R0[i] = max(R0[i + 1], f[c[i]] - v[i] + FA); R[i] = max(R[i + 1], f[c[i]] + v[M] - v[i]); FA = max(FA, f[c[i]] + v[i]); } ans2 = 1e18; for (int i = 1; i \u003c= M; i++) //统计答案 ans2 = min(ans2, max(L[i - 1] + R[i], max(L0[i - 1], R0[i]))); yout \u003c\u003c max(ans1, ans2) \u003c\u003c endl; } ","date":"2020-10-01","objectID":"/posts/oi/problems/cf835f/:0:0","series":null,"tags":["树的直径","Notebooks/OI/OJ/Luogu"],"title":"CF835F-Roads in the Kingdom","uri":"/posts/oi/problems/cf835f/#"},{"categories":null,"content":"CF165D-Beard Graph 题目: 题目描述: Let’s define a non-oriented connected graph of n n n vertices and n−1 n-1 n−1 edges as a beard, if all of its vertices except, perhaps, one, have the degree of 2 or 1 (that is, there exists no more than one vertex, whose degree is more than two). Let us remind you that the degree of a vertex is the number of edges that connect to it. Let each edge be either black or white. Initially all edges are black. You are given the description of the beard graph. Your task is to analyze requests of the following types: paint the edge number i i i black. The edge number i i i is the edge that has this number in the description. It is guaranteed that by the moment of this request the i i i -th edge is white paint the edge number i i i white. It is guaranteed that by the moment of this request the i i i -th edge is black find the length of the shortest path going only along the black edges between vertices a a a and b b b or indicate that no such path exists between them (a path’s length is the number of edges in it) The vertices are numbered with integers from 1 1 1 to n n n , and the edges are numbered with integers from 1 1 1 to n−1 n-1 n−1 . 输入格式: The first line of the input contains an integer n n n ( 2\u003c=n\u003c=105 2\u003c=n\u003c=10^{5} 2\u003c=n\u003c=105 ) — the number of vertices in the graph. Next n−1 n-1 n−1 lines contain edges described as the numbers of vertices vi v_{i} vi​ , ui u_{i} ui​ ( 1\u003c=vi,ui\u003c=n 1\u003c=v_{i},u_{i}\u003c=n 1\u003c=vi​,ui​\u003c=n , vi≠ui v_{i}≠u_{i} vi​=ui​ ) connected by this edge. It is guaranteed that the given graph is connected and forms a beard graph, and has no self-loops or multiple edges. The next line contains an integer m m m ( 1\u003c=m\u003c=3⋅105 1\u003c=m\u003c=3·10^{5} 1\u003c=m\u003c=3⋅105 ) — the number of requests. Next m m m lines contain requests in the following form: first a line contains an integer type type type , which takes values ​​from 1 1 1 to 3 3 3 , and represents the request type. If type=1 type=1 type=1 , then the current request is a request to paint the edge black. In this case, in addition to number type type type the line should contain integer id id id ( 1\u003c=id\u003c=n−1 1\u003c=id\u003c=n-1 1\u003c=id\u003c=n−1 ), which represents the number of the edge to paint. If type=2 type=2 type=2 , then the current request is a request to paint the edge white, its form is similar to the previous request. If type=3 type=3 type=3 , then the current request is a request to find the distance. In this case, in addition to type type type , the line should contain two integers a a a , b b b ( 1\u003c=a,b\u003c=n 1\u003c=a,b\u003c=n 1\u003c=a,b\u003c=n , a a a can be equal to b b b ) — the numbers of vertices, the distance between which must be found. The numbers in all lines are separated by exactly one space. The edges are numbered in the order in which they are given in the input. 输出格式: For each request to “find the distance between vertices a a a and b b b \" print the result. If there is no path going only along the black edges between vertices a a a and b b b , then print “-1” (without the quotes). Print the results in the order of receiving the requests, separate the numbers with spaces or line breaks. 样例: 样例输入 1: 3 1 2 2 3 7 3 1 2 3 1 3 3 2 3 2 2 3 1 2 3 1 3 3 2 3 样例输出 1: 1 2 1 1 -1 -1 样例输入 2: 6 1 5 6 4 2 3 3 5 5 6 6 3 3 4 2 5 3 2 6 3 1 2 2 3 3 3 1 样例输出 2: 3 -1 3 2 思路: 实现: #include \"ybwhead/ios.h\" #define maxn 800001 #define int long long #define L(x) (x \u003c\u003c 1) #define R(x) ((x \u003c\u003c 1) | 1) int tree[maxn], tag[maxn]; int rev[maxn], dep[maxn], size[maxn], seg[maxn], top[maxn], son[maxn], father[maxn]; int n, m, root, x, y, z, a[maxn], tot, mode; int cnt, from[maxn], to[maxn], Next[maxn], head[maxn]; int Gx, Gy, Gz, Gd; int fa[maxn], X[maxn], Y[maxn], Z[maxn]; void add(int x, int y) { cnt++; from[cnt] = x; to[cnt] = y; Next[cnt] = head[x]; head[x] = cnt; } void update(int node, int begin, int end, int x, int y, int val) { if (begin \u003e y || end \u003c x) return; if (begin \u003e= x \u0026\u0026 end \u003c= y) { tree[node] = val; return; } else { int mid = (begin + end) \u003e\u003e 1; if (x \u003c= mid) update(L(node),","date":"2020-10-01","objectID":"/posts/oi/problems/cf165d/:0:0","series":null,"tags":["树链剖分,树剖","Notebooks/OI/OJ/Luogu"],"title":"CF165D-Beard Graph","uri":"/posts/oi/problems/cf165d/#"},{"categories":null,"content":"CF1045G-AI robots 题目: 题目描述: In the last mission, MDCS has successfully shipped N N N AI robots to Mars. Before they start exploring, system initialization is required so they are arranged in a line. Every robot can be described with three numbers: position ( xi x_i xi​ ), radius of sight ( ri r_i ri​ ) and IQ ( qi q_i qi​ ). Since they are intelligent robots, some of them will talk if they see each other. Radius of sight is inclusive, so robot can see other all robots in range [xi−ri,xi+ri] [x_i - r_i, x_i + r_i] [xi​−ri​,xi​+ri​] . But they don’t walk to talk with anybody, but only with robots who have similar IQ. By similar IQ we mean that their absolute difference isn’t more than K K K . Help us and calculate how many pairs of robots are going to talk with each other, so we can timely update their software and avoid any potential quarrel. 输入格式: The first line contains two integers, numbers N(1≤N≤105) N (1 \\leq N \\leq 10^5) N(1≤N≤105) and K(0≤K≤20) K (0 \\leq K \\leq 20) K(0≤K≤20) . Next N N N lines contain three numbers each xi,ri,qi(0≤xi,ri,qi≤109) x_i, r_i, q_i (0 \\leq x_i,r_i,q_i \\leq 10^9) xi​,ri​,qi​(0≤xi​,ri​,qi​≤109) — position, radius of sight and IQ of every robot respectively. 输出格式: Output contains only one number — solution to the problem. 样例: 样例输入 1: 3 2 3 6 1 7 3 10 10 5 8 样例输出 1: 1 思路: 实现: #include \"ybwhead/ios.h\" int n, k; const int maxn = 2e5 + 10; struct node { int x, l, r, q, len; } a[maxn]; int tmp[maxn]; long long ans; int cmp(node a, node b) { return a.len \u003e b.len; } #define lowbit(x) x \u0026(-x) void add(int x, int d) { for (; x \u003c= n; x += lowbit(x)) tmp[x] += d; } int qq(int x) { int ans = 0; for (; x; x -= lowbit(x)) ans += tmp[x]; return ans; } int query(int l, int r) { return qq(r) - qq(l - 1); } int cmp2(node a, node b) { return a.q \u003c b.q; } void cdq(int l, int r) { if (l == r) return; int mid = (l + r) \u003e\u003e 1; cdq(l, mid); cdq(mid + 1, r); int L = l, R = l - 1; for (int i = mid + 1; i \u003c= r; i++) { while (L \u003c= mid \u0026\u0026 a[i].q - a[L].q \u003e k) add(a[L].x, -1), ++L; while (R \u003c mid \u0026\u0026 a[R + 1].q - a[i].q \u003c= k) ++R, add(a[R].x, 1); ans += query(a[i].l, a[i].r); } for (int i = L; i \u003c= R; i++) add(a[i].x, -1); sort(a + l, a + r + 1, cmp2); } int main() { yin \u003e\u003e n \u003e\u003e k; for (int i = 1; i \u003c= n; i++) yin \u003e\u003e a[i].x \u003e\u003e a[i].len \u003e\u003e a[i].q, tmp[i] = a[i].x; sort(tmp + 1, tmp + n + 1); int m = unique(tmp + 1, tmp + n + 1) - tmp - 1; for (int i = 1; i \u003c= n; i++) a[i].l = lower_bound(tmp + 1, tmp + m + 1, a[i].x - a[i].len) - tmp, a[i].r = upper_bound(tmp + 1, tmp + m + 1, a[i].x + a[i].len) - tmp - 1, a[i].x = lower_bound(tmp + 1, tmp + m + 1, a[i].x) - tmp; sort(a + 1, a + n + 1, cmp); for (int i = 1; i \u003c= n; i++) tmp[i] = 0; cdq(1, n); yout \u003c\u003c ans \u003c\u003c endl; return 0; } ","date":"2020-10-01","objectID":"/posts/oi/problems/cf1045g/:0:0","series":null,"tags":["树套树","cdq","Notebooks/OI/OJ/Luogu"],"title":"CF1045G-AI robots","uri":"/posts/oi/problems/cf1045g/#"},{"categories":null,"content":"CF1416C-XOR Inverse 题目: 题目描述: You are given an array a a a consisting of n n n non-negative integers. You have to choose a non-negative integer x x x and form a new array b b b of size n n n according to the following rule: for all i i i from 1 1 1 to n n n , bi=ai⊕x b_i = a_i \\oplus x bi​=ai​⊕x ( ⊕ \\oplus ⊕ denotes the operation bitwise XOR). An inversion in the b b b array is a pair of integers i i i and j j j such that 1≤i\u003cj≤n 1 \\le i \u003c j \\le n 1≤i\u003cj≤n and bi\u003ebj b_i \u003e b_j bi​\u003ebj​ . You should choose x x x in such a way that the number of inversions in b b b is minimized. If there are several options for x x x — output the smallest one. 输入格式: First line contains a single integer n n n ( 1≤n≤3⋅105 1 \\le n \\le 3 \\cdot 10^5 1≤n≤3⋅105 ) — the number of elements in a a a . Second line contains n n n space-separated integers a1 a_1 a1​ , a2 a_2 a2​ , …, an a_n an​ ( 0≤ai≤109 0 \\le a_i \\le 10^9 0≤ai​≤109 ), where ai a_i ai​ is the i i i -th element of a a a . 输出格式: Output two integers: the minimum possible number of inversions in b b b , and the minimum possible value of x x x , which achieves those number of inversions. 样例: 样例输入1: 4 0 1 3 2 样例输出1: 1 0 样例输入2: 9 10 7 9 10 7 5 5 3 5 样例输出2: 4 14 样例输入3: 3 8 10 3 样例输出3: 0 8 思路: 实现: #include \"ybwhead/ios.h\" #define int long long const int N = 3e5 + 5; typedef long long ll; typedef vector\u003cint\u003e vi; #define pb push_back int n; ll dp[N][2]; void Solve(vi \u0026cur, int p) { if (p \u003c 0 || cur.size() == 0) { return; } int cnt1 = 0, cnt2 = 0; int ans1 = 0, ans2 = 0; vi left, right; for (int x : cur) { if ((x \u003e\u003e p) \u0026 1) { ans2 += cnt1; cnt2++; right.pb(x); } else { ans1 += cnt2; cnt1++; left.pb(x); } } dp[p][0] += ans2; dp[p][1] += ans1; Solve(left, p - 1), Solve(right, p - 1); } signed main() { yin \u003e\u003e n; vi a(n); for (int \u0026x : a) { yin \u003e\u003e x; } reverse(a.begin(), a.end()); Solve(a, 30); ll res = 0, ans = 0; for (int i = 0; i \u003c= 30; i++) { if (dp[i][0] \u003c= dp[i][1]) { ans += dp[i][0]; } else { ans += dp[i][1]; res += 1 \u003c\u003c i; } } yout \u003c\u003c ans \u003c\u003c \" \" \u003c\u003c res \u003c\u003c endl; return 0; } ","date":"2020-09-30","objectID":"/posts/oi/problems/cf1416c/:0:0","series":null,"tags":["Notebooks/OI/OJ/Luogu"],"title":"CF1416C-XOR Inverse","uri":"/posts/oi/problems/cf1416c/#"},{"categories":null,"content":"CF1416B-Make Them Equal 题目: 题目描述: You are given an array a a a consisting of n n n positive integers, numbered from 1 1 1 to n n n . You can perform the following operation no more than 3n 3n 3n times: choose three integers i i i , j j j and x x x ( 1≤i,j≤n 1 \\le i, j \\le n 1≤i,j≤n ; 0≤x≤109 0 \\le x \\le 10^9 0≤x≤109 ); assign ai:=ai−x⋅i a_i := a_i - x \\cdot i ai​:=ai​−x⋅i , aj:=aj+x⋅i a_j := a_j + x \\cdot i aj​:=aj​+x⋅i . After each operation, all elements of the array should be non-negative. Can you find a sequence of no more than 3n 3n 3n operations after which all elements of the array are equal? 输入格式: The first line contains one integer t t t ( 1≤t≤104 1 \\le t \\le 10^4 1≤t≤104 ) — the number of test cases. Then t t t test cases follow. The first line of each test case contains one integer n n n ( 1≤n≤104 1 \\le n \\le 10^4 1≤n≤104 ) — the number of elements in the array. The second line contains n n n integers a1,a2,…,an a_1, a_2, \\dots, a_n a1​,a2​,…,an​ ( 1≤ai≤105 1 \\le a_i \\le 10^5 1≤ai​≤105 ) — the elements of the array. It is guaranteed that the sum of n n n over all test cases does not exceed 104 10^4 104 . 输出格式: For each test case print the answer to it as follows: if there is no suitable sequence of operations, print −1 -1 −1 ; otherwise, print one integer k k k ( 0≤k≤3n 0 \\le k \\le 3n 0≤k≤3n ) — the number of operations in the sequence. Then print k k k lines, the m m m -th of which should contain three integers i i i , j j j and x x x ( 1≤i,j≤n 1 \\le i, j \\le n 1≤i,j≤n ; 0≤x≤109 0 \\le x \\le 10^9 0≤x≤109 ) for the m m m -th operation. If there are multiple suitable sequences of operations, print any of them. Note that you don’t have to minimize k k k . 样例: 样例输入 1: 3 4 2 16 4 18 6 1 2 3 4 5 6 5 11 19 1 1 3 样例输出 1: 2 4 1 2 2 3 3 -1 4 1 2 4 2 4 5 2 3 3 4 5 1 思路: 实现: #include \"ybwhead/ios.h\" #define ll long long const int maxn = 4e4 + 10; int n; ll a[maxn], b[maxn], c[maxn], d[maxn]; int cnt; void pp(ll x, ll y, ll z) { ++cnt; b[cnt] = x; c[cnt] = y; d[cnt] = z; } void pr() { yout \u003c\u003c cnt \u003c\u003c endl; for (int i = 1; i \u003c= cnt; i++) { yout \u003c\u003c b[i] \u003c\u003c \" \" \u003c\u003c c[i] \u003c\u003c ' ' \u003c\u003c d[i] \u003c\u003c endl; } } int main() { int TTT; yin \u003e\u003e TTT; while (TTT--) { cnt = 0; ll sum = 0; yin \u003e\u003e n; for (int i = 1; i \u003c= n; i++) yin \u003e\u003e a[i], sum += a[i]; if (sum % n) { yout \u003c\u003c -1 \u003c\u003c endl; continue; } sum /= n; for (int i = 2; i \u003c= n; i++) { if (a[i] % i == 0) { pp(i, 1, a[i] / i); } else { pp(1, i, i - a[i] % i); pp(i, 1, a[i] / i + 1); } } for (int i = 2; i \u003c= n; i++) pp(1, i, sum); pr(); } } ","date":"2020-09-30","objectID":"/posts/oi/problems/cf1416b/:0:0","series":null,"tags":["Notebooks/OI/OJ/Luogu"],"title":"CF1416B-Make Them Equal","uri":"/posts/oi/problems/cf1416b/#"},{"categories":null,"content":"CF1416A-k-Amazing Numbers 题目: 题目描述: You are given an array a a a consisting of n n n integers numbered from 1 1 1 to n n n . Let’s define the k k k -amazing number of the array as the minimum number that occurs in all of the subsegments of the array having length k k k (recall that a subsegment of a a a of length k k k is a contiguous part of a a a containing exactly k k k elements). If there is no integer occuring in all subsegments of length k k k for some value of k k k , then the k k k -amazing number is −1 -1 −1 . For each k k k from 1 1 1 to n n n calculate the k k k -amazing number of the array a a a . 输入格式: The first line contains one integer t t t ( 1≤t≤1000 1 \\le t \\le 1000 1≤t≤1000 ) — the number of test cases. Then t t t test cases follow. The first line of each test case contains one integer n n n ( 1≤n≤3⋅105 1 \\le n \\le 3 \\cdot 10^5 1≤n≤3⋅105 ) — the number of elements in the array. The second line contains n n n integers a1,a2,…,an a_1, a_2, \\dots, a_n a1​,a2​,…,an​ ( 1≤ai≤n 1 \\le a_i \\le n 1≤ai​≤n ) — the elements of the array. It is guaranteed that the sum of n n n over all test cases does not exceed 3⋅105 3 \\cdot 10^5 3⋅105 . 输出格式: For each test case print n n n integers, where the i i i -th integer is equal to the i i i -amazing number of the array. 样例: 样例输入 1: 3 5 1 2 3 4 5 5 4 4 4 4 2 6 1 3 1 5 3 1 样例输出 1: -1 -1 3 2 1 -1 4 4 4 2 -1 -1 1 1 1 1 思路: 实现: #include \"ybwhead/ios.h\" int n; const int maxn = 3e5 + 10; int ma[maxn], las[maxn]; int cmp(int a, int b) { return ma[a] \u003c ma[b] || ma[a] == ma[b] \u0026\u0026 a \u003c b; } int main() { int TTT; yin \u003e\u003e TTT; while (TTT--) { yin \u003e\u003e n; for (int i = 1; i \u003c= n; i++) las[i] = 0, ma[i] = 0; for (int i = 1; i \u003c= n; i++) { int x; yin \u003e\u003e x; // if (las[x]) ma[x] = max(ma[x], i - las[x]); las[x] = i; } for (int i = 1; i \u003c= n; i++) ma[i] = max(ma[i], n + 1 - las[i]); for (int i = 1; i \u003c= n; i++) las[i] = i; sort(las + 1, las + n + 1, cmp); int kk = 1, ans = -1; for (int i = 1; i \u003c= n; i++) { if (ma[las[i]] \u003e kk) { for (int j = kk; j \u003c ma[las[i]]; j++) yout \u003c\u003c ans \u003c\u003c \" \"; kk = ma[las[i]]; } if (ans \u003e= 0) ans = min(ans, las[i]); else ans = las[i]; } if (kk == 1) for (int i = 1; i \u003c= n; i++) yout \u003c\u003c las[1] \u003c\u003c \" \"; else for (int j = kk; j \u003c= n; j++) yout \u003c\u003c ans \u003c\u003c \" \"; yout \u003c\u003c endl; } } ","date":"2020-09-30","objectID":"/posts/oi/problems/cf1416a/:0:0","series":null,"tags":["Notebooks/OI/OJ/Luogu"],"title":"CF1416A-k-Amazing Numbers","uri":"/posts/oi/problems/cf1416a/#"},{"categories":null,"content":"P5494-【模板】线段树分裂 题目: 题目描述: 给出一个可重集 aaa（编号为 111），它支持以下操作： 0 p x y：将可重集 ppp 中大于等于 xxx 且小于等于 yyy 的值放入一个新的可重集中（新可重集编号为从 222 开始的正整数，是上一次产生的新可重集的编号+1）。 1 p t：将可重集 ttt 中的数放入可重集 ppp，且清空可重集 ttt（数据保证在此后的操作中不会出现可重集 ttt）。 2 p x q：在 ppp 这个可重集中加入 xxx 个数字 qqq。 3 p x y：查询可重集 ppp 中大于等于 xxx 且小于等于 yyy 的值的个数。 4 p k：查询在 ppp 这个可重集中第 kkk 小的数，不存在时输出 -1。 输入格式: 第一行两个整数 n,mn,mn,m，表示可重集中的数在 1∼n1\\sim n1∼n 的范围内，有 mmm 个操作。 接下来一行 nnn 个整数，表示 1∼n1 \\sim n1∼n 这些数在 aaa 中出现的次数 (ai≤m)(a_{i} \\leq m)(ai​≤m)。 接下来的 mmm 行每行若干个整数，第一个数为操作的编号 optoptopt（0≤opt≤40 \\leq opt \\leq 40≤opt≤4），以题目描述为准。 输出格式: 依次输出每个查询操作的答案。 样例: 样例输入 1: 5 12 0 0 0 0 0 2 1 1 1 2 1 1 2 2 1 1 3 3 1 1 3 4 1 2 2 1 1 4 2 1 1 5 0 1 2 4 2 2 1 4 3 2 2 4 1 1 2 4 1 3 样例输出 1: 3 2 4 3 思路: 实现: #include \"ybwhead/ios.h\" #define ll long long const int MAXN = 200010; int n, m, tot, cnt, seq = 1, op, x, y, z, bac[MAXN \u003c\u003c 5], ch[MAXN \u003c\u003c 5][2], rt[MAXN]; ll val[MAXN \u003c\u003c 5]; int newnod() { return (cnt ? bac[cnt--] : ++tot); } void del(int p) { bac[++cnt] = p, ch[p][0] = ch[p][1] = val[p] = 0; return; } void modify(int \u0026p, int l, int r, int pos, int v) { if (!p) { p = newnod(); } val[p] += v; if (l == r) { return; } int mid = (l + r) \u003e\u003e 1; if (pos \u003c= mid) { modify(ch[p][0], l, mid, pos, v); } else { modify(ch[p][1], mid + 1, r, pos, v); } return; } ll query(int p, int l, int r, int xl, int xr) { if (xr \u003c l || r \u003c xl) { return 0; } if (xl \u003c= l \u0026\u0026 r \u003c= xr) { return val[p]; } int mid = (l + r) \u003e\u003e 1; return query(ch[p][0], l, mid, xl, xr) + query(ch[p][1], mid + 1, r, xl, xr); } int kth(int p, int l, int r, int k) { if (l == r) { return l; } int mid = (l + r) \u003e\u003e 1; if (val[ch[p][0]] \u003e= k) { return kth(ch[p][0], l, mid, k); } else { return kth(ch[p][1], mid + 1, r, k - val[ch[p][0]]); } } int merge(int x, int y) { if (!x || !y) { return x + y; } val[x] += val[y]; ch[x][0] = merge(ch[x][0], ch[y][0]); ch[x][1] = merge(ch[x][1], ch[y][1]); del(y); return x; } void split(int x, int \u0026y, ll k) { if (x == 0) { return; } y = newnod(); ll v = val[ch[x][0]]; if (k \u003e v) { split(ch[x][1], ch[y][1], k - v); } else { swap(ch[x][1], ch[y][1]); } if (k \u003c v) { split(ch[x][0], ch[y][0], k); } val[y] = val[x] - k; val[x] = k; return; } int main() { yin \u003e\u003e n \u003e\u003e m; for (int i = 1; i \u003c= n; i++) { yin \u003e\u003e x; modify(rt[1], 1, n, i, x); } for (int i = 1; i \u003c= m; i++) { yin \u003e\u003e op; if (op == 0) { yin \u003e\u003e x \u003e\u003e y \u003e\u003e z; ll k1 = query(rt[x], 1, n, 1, z), k2 = query(rt[x], 1, n, y, z); int tmp = 0; split(rt[x], rt[++seq], k1 - k2); split(rt[seq], tmp, k2); rt[x] = merge(rt[x], tmp); } else if (op == 1) { yin \u003e\u003e x \u003e\u003e y; rt[x] = merge(rt[x], rt[y]); } else if (op == 2) { yin \u003e\u003e x \u003e\u003e y \u003e\u003e z; modify(rt[x], 1, n, z, y); } else if (op == 3) { yin \u003e\u003e x \u003e\u003e y \u003e\u003e z; yout \u003c\u003c query(rt[x], 1, n, y, z) \u003c\u003c endl; } else if (op == 4) { yin \u003e\u003e x \u003e\u003e y; if (val[rt[x]] \u003c y) { printf(\"-1\\n\"); continue; } yout \u003c\u003c kth(rt[x], 1, n, y) \u003c\u003c endl; } } return 0; } ","date":"2020-09-30","objectID":"/posts/oi/problems/p5494/:0:0","series":null,"tags":["线段树","平衡树","Notebooks/OI/OJ/Luogu"],"title":"P5494-【模板】线段树分裂","uri":"/posts/oi/problems/p5494/#"},{"categories":null,"content":"P3233-[HNOI2014]世界树 题目: 题目描述: 世界树是一棵无比巨大的树，它伸出的枝干构成了整个世界。在这里，生存着各种各样的种族和生灵，他们共同信奉着绝对公正公平的女神艾莉森，在他们的信条里，公平是使世界树能够生生不息、持续运转的根本基石。 世界树的形态可以用一个数学模型来描述：世界树中有 nnn 个种族，种族的编号分别从 111 到 nnn，分别生活在编号为 111 到 nnn 的聚居地上，种族的编号与其聚居地的编号相同。有的聚居地之间有双向的道路相连，道路的长度为 111。保证连接的方式会形成一棵树结构，即所有的聚居地之间可以互相到达，并且不会出现环。定义两个聚居地之间的距离为连接他们的道路的长度；例如，若聚居地 aaa 和 bbb 之间有道路，bbb 和 ccc 之间有道路，因为每条道路长度为 111 而且又不可能出现环，所以 aaa 与 ccc 之间的距离为 222。 出于对公平的考虑，第 iii 年，世界树的国王需要授权 mim_imi​ 个种族的聚居地为临时议事处。对于某个种族 xxx（xxx 为种族的编号），如果距离该种族最近的临时议事处为 yyy（yyy 为议事处所在聚居地的编号），则种族 xxx 将接受 yyy 议事处的管辖（如果有多个临时议事处到该聚居地的距离一样，则 yyy 为其中编号最小的临时议事处）。 现在国王想知道，在 qqq 年的时间里，每一年完成授权后，当年每个临时议事处将会管理多少个种族（议事处所在的聚居地也将接受该议事处管理）。 现在这个任务交给了以智慧著称的灵长类的你：程序猿。请帮国王完成这个任务吧。 输入格式: 第一行为一个正整数 nnn，表示世界树中种族的个数。接下来 n−1n-1n−1 行，每行两个正整数 x，y，表示 xxx 聚居地与 yyy 聚居地之间有一条长度为 111 的双向道路。接下来一行为一个正整数 qqq，表示国王询问的年数。接下来 qqq 块，每块两行：第 iii 块的第一行为 111 个正整数 mim_imi​，表示第 iii 年授权的临时议事处的个数。第 iii 块的第二行为 mim_imi​ 个正整数 h1,h2,…,hmih_1, h_2, \\ldots, h_{m_i}h1​,h2​,…,hmi​​，表示被授权为临时议事处的聚居地编号（保证互不相同）。 输出格式: 输出包含 qqq 行，第 iii 行为 mim_imi​ 个整数，该行的第 jjj (j=1,2,…,mij=1, 2, \\ldots, m_ij=1,2,…,mi​) 个数表示第 iii 年被授权的聚居地 hjh_jhj​ 的临时议事处管理的种族个数。 样例: 样例输入 1: 10 2 1 3 2 4 3 5 4 6 1 7 3 8 3 9 4 10 1 5 2 6 1 5 2 7 3 6 9 1 8 4 8 7 10 3 5 2 9 3 5 8 样例输出 1: 1 9 3 1 4 1 1 10 1 1 3 5 4 1 3 1 1 思路: 实现: #include \"ybwhead/ios.h\" const int N = 3e5 + 10, INF = 1e9 + 10; int n, m, top, cnt; int dep[N], f[N][20], dfn[N], size[N], lg2[N], sta[N], pnt[N], vis[N], g[N], dp[N], ans[N], tmp[N]; struct graph { int tot; int fir[N], to[2 * N], nxt[2 * N]; graph() { tot = 0; memset(fir, 0, sizeof(fir)); } inline void add(int x, int y) { to[++tot] = y; nxt[tot] = fir[x]; fir[x] = tot; to[++tot] = x; nxt[tot] = fir[y]; fir[y] = tot; } } e1, e2; inline void dfs(int p) //预处理dfn,dep,size { dfn[p] = ++cnt, size[p] = 1; for (register int i = e1.fir[p]; i; i = e1.nxt[i]) { int q = e1.to[i]; if (q == f[p][0]) continue; dep[q] = dep[p] + 1, f[q][0] = p; for (register int j = 1; j \u003c= lg2[dep[q]] + 1; j++) f[q][j] = f[f[q][j - 1]][j - 1]; dfs(q); size[p] += size[q]; } } inline int get_lca(int x, int y) //找lca { if (dep[x] \u003c dep[y]) swap(x, y); for (register int i = lg2[dep[x]]; i \u003e= 0; i--) if (dep[f[x][i]] \u003e= dep[y]) x = f[x][i]; if (x == y) return x; for (register int i = lg2[dep[x]]; i \u003e= 0; i--) if (f[x][i] != f[y][i]) x = f[x][i], y = f[y][i]; return f[x][0]; } inline bool cmp(int a, int b) { return dfn[a] \u003c dfn[b]; } inline void build(int p) //建立虚树 { if (top == 0) { sta[top = 1] = p; return; } int lca = get_lca(sta[top], p); while (top \u003e 1 \u0026\u0026 dep[lca] \u003c dep[sta[top - 1]]) e2.add(sta[top - 1], sta[top]), top--; if (dep[lca] \u003c dep[sta[top]]) e2.add(lca, sta[top--]); if (top == 0 || sta[top] != lca) sta[++top] = lca; sta[++top] = p; } inline void cal(int x, int y) { int p = y, q = y; for (register int i = lg2[dep[p]]; i \u003e= 0; i--) if (dep[f[p][i]] \u003e dep[x]) p = f[p][i]; ans[g[x]] -= size[p]; //跳到y在原树上对应的x的儿子 for (register int i = lg2[dep[q]]; i \u003e= 0; i--) { int llen = dep[y] - dep[f[q][i]] + dp[y], rlen = dep[f[q][i]] - dep[x] + dp[x]; if (dep[f[q][i]] \u003e dep[x] \u0026\u0026 (llen \u003c rlen || (llen == rlen \u0026\u0026 g[y] \u003c g[x]))) q = f[q][i]; //倍增找到分割点 } ans[g[y]] += size[q] - size[y], ans[g[x]] += size[p] - size[q]; //注意这里要加的是size，因为虚树路径上会有子树 } inline void dfs1(int p, int fa) { dp[p] = INF; for (register int i = e2.fir[p]; i; i = e2.nxt[i]) { int q = e2.to[i]; if (q == fa) continue; dfs1(q, p); int dis = dep[q] - dep[p]; //注意这里，虚树上的节点并不是连续的 if (dp[q] + dis \u003c dp[p]) dp[p] = dp[q] + dis, g[p] = g[q]; else if (dp[q] + dis == dp[p]) g[p] = min(g[p], g[q]); } if (vis[p]) dp[p] = 0, g[p] = p; } inline void dfs2(int p, int fa) { for (register int i = e2.fir[p]; i; i = e2.nxt[i]) { int q = e2.to[i]; if (q == fa) continue; int dis = dep[q] - dep[p]; if (dp[p] + dis \u003c dp[q]) dp[q] = dp[p] + dis, g[q] = g[p]; else if (dp[p] + dis == dp[q]) g[q] = min(g[q], g[p]); cal(p, q); dfs2(q, p); } ans[g[p]] += size[p]; //注意这里，还要加上自己 vis[p] = e2.fir[p] = 0; } int main() { lg2[1] = 0; for (register int i = 1; i \u003c= 3e5; i++) lg2[i] = lg2[i \u003e\u003e 1]","date":"2020-09-26","objectID":"/posts/oi/problems/p3233/:0:0","series":null,"tags":["dp",2014,"倍增","湖南","最近公共祖先, LCA","虚树","高性能","Notebooks/OI/OJ/Luogu"],"title":"P3233-[HNOI2014]世界树","uri":"/posts/oi/problems/p3233/#"},{"categories":null,"content":"P4381-[IOI2008]Island 题目: 题目描述: 你准备浏览一个公园，该公园由 NNN 个岛屿组成，当地管理部门从每个岛屿 iii 出发向另外一个岛屿建了一座长度为 LiL_iLi​ 的桥，不过桥是可以双向行走的。同时，每对岛屿之间都有一艘专用的往来两岛之间的渡船。相对于乘船而言，你更喜欢步行。你希望经过的桥的总长度尽可能长，但受到以下的限制： 可以自行挑选一个岛开始游览。 任何一个岛都不能游览一次以上。 无论任何时间，你都可以由当前所在的岛 SSS 去另一个从未到过的岛 DDD。从 SSS 到 DDD 有如下方法： 步行：仅当两个岛之间有一座桥时才有可能。对于这种情况，桥的长度会累加到你步行的总距离中。 渡船：你可以选择这种方法，仅当没有任何桥和以前使用过的渡船的组合可以由 SSS 走到 DDD (当检查是否可到达时，你应该考虑所有的路径，包括经过你曾游览过的那些岛)。 注意，你不必游览所有的岛，也可能无法走完所有的桥。 请你编写一个程序，给定 NNN 座桥以及它们的长度，按照上述的规则，计算你可以走过的桥的长度之和的最大值。 输入格式: 第一行包含 NNN 个整数，即公园内岛屿的数目。 随后的 NNN 行每一行用来表示一个岛。第 iii 行由两个以单空格分隔的整数，表示由岛 iii 筑的桥。第一个整数表示桥另一端的岛，第二个整数表示该桥的长度 LiL_iLi​。你可以假设对于每座桥，其端点总是位于不同的岛上。 输出格式: 仅包含一个整数，即可能的最大步行距离。 样例: 样例输入1: 7 3 8 7 2 4 2 1 4 1 9 3 4 2 3 样例输出1: 24 思路: 实现: #include \"ybwhead/ios.h\" int n; const int maxn = 1e6 + 10; struct edge { int v, w, nxt; } e[maxn \u003c\u003c 1]; int tot, head[maxn]; void __ADD(int u, int v, int w) { e[++tot] = {v, w, head[u]}; head[u] = tot; } void add(int u, int v, int w) { __ADD(u, v, w); __ADD(v, u, w); } bool v[maxn]; int v1[maxn]; long long ans; int now, cnt; int r[maxn]; int st; long long s[maxn]; int dfs1(int u, int fa) { if (v1[u] == 1) { v1[u] = 2; r[++cnt] = u; v[u] = 1; return 1; } v1[u] = 1; // cout \u003c\u003c u \u003c\u003c endl; for (int i = head[u]; i; i = e[i].nxt) { int vv = e[i].v; if (i == ((fa - 1) ^ 1) + 1) continue; int tt = dfs1(vv, i); if (tt == 0) continue; if (v1[u] == 2) { s[st - 1] = s[st] - e[i].w; return 0; } r[++cnt] = u; v[u] = 1; s[cnt] = s[cnt - 1] + e[i].w; return 1; } return 0; } long long ans1, ans2, ans3; long long d[maxn]; void dp(int u) { v[u] = 1; for (int i = head[u]; i; i = e[i].nxt) { int vv = e[i].v; if (v[vv]) continue; dp(vv); ans1 = max(ans1, d[u] + d[vv] + e[i].w); d[u] = max(d[u], d[vv] + e[i].w); } } long long f[maxn \u003c\u003c 1]; deque\u003cint\u003e q; long long dfs(int u) { st = cnt + 1; ans2 = ans3 = 0; dfs1(u, 0); for (int i = st; i \u003c= cnt; i++) { ans1 = 0; dp(r[i]); ans2 = max(ans2, ans1); f[i + cnt - st + 1] = f[i] = d[r[i]]; s[i + cnt - st + 1] = s[i + cnt - st] + s[i] - s[i - 1]; // yout \u003c\u003c i \u003c\u003c \" \" \u003c\u003c s[4] \u003c\u003c \" \" \u003c\u003c s[3] \u003c\u003c endl; } while (!q.empty()) q.pop_back(); // puts(\"!!!\"); for (int i = st; i \u003c= cnt * 2 - st + 1; i++) { while (!q.empty() \u0026\u0026 q.front() \u003c= i - cnt + st - 1) q.pop_front(); // yout \u003c\u003c q.front() \u003c\u003c \" \" \u003c\u003c i - cnt + st - 1 \u003c\u003c endl; if (!q.empty()) ans3 = max(ans3, f[i] + f[q.front()] + s[i] - s[q.front()]); while (!q.empty() \u0026\u0026 f[q.back()] - s[q.back()] \u003c= f[i] - s[i]) q.pop_back(); q.push_back(i); // yout \u003c\u003c ans3 \u003c\u003c endl; } return max(ans2, ans3); } int main() { yin \u003e\u003e n; for (int i = 1; i \u003c= n; i++) { int x, y; yin \u003e\u003e x \u003e\u003e y; add(i, x, y); } for (int i = 1; i \u003c= n; i++) if (!v[i]) ans += dfs(i); yout \u003c\u003c ans \u003c\u003c endl; return 0; } ","date":"2020-09-24","objectID":"/posts/oi/problems/p4381/:0:0","series":null,"tags":["dp",2008,"IOI","O2优化","新云端","树的直径","栈","队列","高性能","Notebooks/OI/OJ/Luogu"],"title":"P4381-[IOI2008]Island","uri":"/posts/oi/problems/p4381/#"},{"categories":null,"content":"P4068-[SDOI2016]数字配对 题目: 题目描述: 有 n 种数字，第 i 种数字是 aia_iai​、有 bib_ibi​ 个，权值是 cic_ici​。 若两个数字 aia_iai​、aja_jaj​ 满足，aia_iai​ 是 aja_jaj​ 的倍数，且 ai/aja_i/a_jai​/aj​ 是一个质数， 那么这两个数字可以配对，并获得 ci×cjc_i \\times c_jci​×cj​ 的价值。 一个数字只能参与一次配对，可以不参与配对。 在获得的价值总和不小于 0 的前提下，求最多进行多少次配对。 输入格式: 第一行一个整数 n。 第二行 n 个整数 a1,a2,⋯ ,ana_1,a_2,\\cdots,a_na1​,a2​,⋯,an​。 第三行 n 个整数 b1,b2,⋯ ,bnb_1,b_2,\\cdots,b_nb1​,b2​,⋯,bn​。 第四行 n 个整数 c1,c2,⋯ ,cnc_1,c_2,\\cdots,c_nc1​,c2​,⋯,cn​。 输出格式: 一行一个数，最多进行多少次配对 样例: 样例输入 1: 3 2 4 8 2 200 7 -1 -2 1 样例输出 1: 4 思路: 实现: #include \"ybwhead/ios.h\" #define int long long int n; const int maxn = 2e2 + 10; const int maxm = 5e5 + 10; const long long inf = 0x3f3f3f3f3f3f3f3f; int a[maxn], b[maxn], c[maxn]; int tot = 1, head[maxn]; struct edge { int u, v, nxt; long long w, x; } e[maxm]; void __ADD(int u, int v, long long w, int x) { e[++tot] = (edge){u, v, head[u], w, x}; head[u] = tot; } void add(int u, int v, long long w, int x) { __ADD(u, v, w, x); __ADD(v, u, 0, -x); } int S, T; int prime(int n) { int x = 0; for (int i = 2; i * i \u003c= n; i++) { while (n % i == 0) x++, n /= i; } if (n \u003e 1) return x + 1; return x; } int cnt[maxn]; long long dis[maxn]; queue\u003cint\u003e q; int vis[maxn]; int frm[maxm]; int bfs() { for (int i = 0; i \u003c= n + 1; i++) vis[i] = 0, dis[i] = -inf; q.push(S); dis[S] = 0; while (!q.empty()) { int u = q.front(); q.pop(); vis[u] = 0; for (int i = head[u]; i; i = e[i].nxt) { int v = e[i].v; if (e[i].w \u0026\u0026 dis[u] + e[i].x \u003e dis[v]) { dis[v] = dis[u] + e[i].x; frm[v] = i; if (!vis[v]) q.push(v), vis[v] = 1; } // yout \u003c\u003c e[i].v \u003c\u003c ' ' \u003c\u003c e[i].u \u003c\u003c \" \" \u003c\u003c e[i].w \u003c\u003c endl; } } // yout \u003c\u003c T \u003c\u003c ' ' \u003c\u003c dis[T] \u003c\u003c endl; return dis[T] \u003e -inf; } long long sum, ans; int check() { long long fl = inf, delta; for (int i = frm[T]; i; i = frm[e[i].u]) fl = min(fl, e[i].w); delta = dis[T] * fl; if (sum + delta \u003c 0) { ans += sum / (-dis[T]); return 0; } else { sum += delta; ans += fl; for (int i = frm[T]; i; i = frm[e[i].u]) e[i].w -= fl, e[i ^ 1].w += fl; return 1; } } signed main() { yin \u003e\u003e n; for (int i = 1; i \u003c= n; i++) yin \u003e\u003e a[i]; for (int i = 1; i \u003c= n; i++) yin \u003e\u003e b[i]; for (int i = 1; i \u003c= n; i++) yin \u003e\u003e c[i]; S = 0, T = n + 1; for (int i = 1; i \u003c= n; i++) cnt[i] = prime(a[i]); for (int i = 1; i \u003c= n; i++) { if (cnt[i] \u0026 1) add(S, i, b[i], 0); else add(i, T, b[i], 0); } for (int i = 1; i \u003c= n; i++) { if (!(cnt[i] \u0026 1)) continue; for (int j = 1; j \u003c= n; j++) { if (cnt[i] == cnt[j] + 1 \u0026\u0026 a[i] % a[j] == 0) add(i, j, inf, 1ll * c[i] * c[j]); if (cnt[i] == cnt[j] - 1 \u0026\u0026 a[j] % a[i] == 0) add(i, j, inf, 1ll * c[i] * c[j]); } } // puts(\"!!!\"); while (bfs() \u0026\u0026 check()) ; yout \u003c\u003c ans \u003c\u003c endl; return 0; } ","date":"2020-09-22","objectID":"/posts/oi/problems/p4068/:0:0","series":null,"tags":["贪心",2016,"各省省选","网络流","山东","二分图","最大流","素数判断,质数,筛法","Notebooks/OI/OJ/Luogu"],"title":"P4068-[SDOI2016]数字配对","uri":"/posts/oi/problems/p4068/#"},{"categories":null,"content":"P2474-[SCOI2008]天平 题目: 题目描述: 你有 n 个砝码，均为 1 克，2 克或者 3 克。你并不清楚每个砝码的重量，但你知道其中一些砝码重量的大小关系。你把其中两个砝码 A 和 B 放在天平的左边，需要另外选出两个砝码放在天平的右边。问：有多少种选法使得天平的左边重(c1)、一样重(c2)、右边重(c3)？（只有结果保证惟一的选法才统计在内） 输入格式: 第一行包含三个正整数 n，A，B（1\u003c=A，B\u003c=N，A 和 B 不相等）。砝码编号 为 1~N。以下 n 行包含重量关系矩阵，其中第 i 行第 j 个字符为加号“+”表示砝 码 i 比砝码 j 重，减号“-”表示砝码 i 比砝码 j 轻，等号“=”表示砝码 i 和砝码 j 一样重，问号“?”表示二者的关系未知。存在一种情况符合该矩阵。 输出格式: 仅一行，包含三个整数，即 c1，c2 和 c3。 样例: 样例输入 1: 6 2 5 ?+???? -?+??? ?-???? ????+? ???-?+ ????-? 样例输出 1: 1 4 1 样例输入 2: 14 8 4 ?+???++?????++ -??=?=???????= ??????????=??? ?=??+?==?????? ???-???-???-?? -=???????????? -??=???=?-+??? ???=+?=??????? ?????????????? ??????+??????? ??=???-????-?? ????+?????+??? -????????????? -=???????????? 样例输出 2: 18 12 11 思路: 实现: #include \"ybwhead/ios.h\" int n, a, b; const int mxxn = 1e3 + 10; int mx[mxxn][mxxn]; int mi[mxxn][mxxn]; int main() { yin \u003e\u003e n \u003e\u003e a \u003e\u003e b; for (int i = 1; i \u003c= n; i++) { for (int j = 1; j \u003c= n; j++) { char c; yin \u003e\u003e c; if (c == '=' || i == j) { continue; } if (c == '-') { mx[i][j] = -1; mi[i][j] = -2; } if (c == '+') { mx[i][j] = 2; mi[i][j] = 1; } if (c == '?') { mx[i][j] = 2; mi[i][j] = -2; } } } for (int k = 1; k \u003c= n; k++) for (int i = 1; i \u003c= n; i++) for (int j = 1; j \u003c= n; j++) if (i != k \u0026\u0026 i != j \u0026\u0026 j != k) mx[i][j] = min(mx[i][j], mx[i][k] + mx[k][j]), mi[i][j] = max(mi[i][j], mi[i][k] + mi[k][j]); int tmp1, tmp2, tmp3; tmp1 = tmp2 = tmp3 = 0; for (int i = 1; i \u003c= n; i++) { if (i != a \u0026\u0026 i != b) { for (int j = 1; j \u003c i; j++) { if (j == a || j == b) continue; if (mi[a][i] \u003e mx[j][b] || mi[b][i] \u003e mx[j][a]) ++tmp1; if (mi[a][i] == mx[a][i] \u0026\u0026 mi[a][i] == mx[j][b] \u0026\u0026 mx[j][b] == mi[j][b]) { ++tmp2; continue; } if (mi[a][j] == mx[a][j] \u0026\u0026 mi[a][j] == mi[i][b] \u0026\u0026 mi[i][b] == mx[i][b]) ++tmp2; if (mi[i][a] \u003e mx[b][j] || mi[i][b] \u003e mx[a][j]) ++tmp3; } } } yout \u003c\u003c tmp1 \u003c\u003c ' ' \u003c\u003c tmp2 \u003c\u003c \" \" \u003c\u003c tmp3 \u003c\u003c endl; return 0; } ","date":"2020-09-21","objectID":"/posts/oi/problems/p2474/:0:0","series":null,"tags":[2008,"四川","各省省选","状态压缩,状压","差分约束","期望","高性能","Notebooks/OI/OJ/Luogu"],"title":"P2474-[SCOI2008]天平","uri":"/posts/oi/problems/p2474/#"},{"categories":null,"content":"CF505E-Mr. Kitayuta vs. Bamboos 题目: 题目描述: Mr. Kitayuta’s garden is planted with n n n bamboos. (Bamboos are tall, fast-growing tropical plants with hollow stems.) At the moment, the height of the i i i -th bamboo is hi h_{i} hi​ meters, and it grows ai a_{i} ai​ meters at the end of each day. Actually, Mr. Kitayuta hates these bamboos. He once attempted to cut them down, but failed because their stems are too hard. Mr. Kitayuta have not given up, however. He has crafted Magical Hammer with his intelligence to drive them into the ground. He can use Magical Hammer at most k k k times during each day, due to his limited Magic Power. Each time he beat a bamboo with Magical Hammer, its height decreases by p p p meters. If the height would become negative by this change, it will become 0 0 0 meters instead (it does not disappear). In other words, if a bamboo whose height is h h h meters is beaten with Magical Hammer, its new height will be max(0,h−p) max(0,h-p) max(0,h−p) meters. It is possible to beat the same bamboo more than once in a day. Mr. Kitayuta will fight the bamboos for m m m days, starting today. His purpose is to minimize the height of the tallest bamboo after m m m days (that is, m m m iterations of “Mr. Kitayuta beats the bamboos and then they grow”). Find the lowest possible height of the tallest bamboo after m m m days. 输入格式: The first line of the input contains four space-separated integers n n n , m m m , k k k and p p p ( 1\u003c=n\u003c=105,1\u003c=m\u003c=5000,1\u003c=k\u003c=10,1\u003c=p\u003c=109 1\u003c=n\u003c=10^{5},1\u003c=m\u003c=5000,1\u003c=k\u003c=10,1\u003c=p\u003c=10^{9} 1\u003c=n\u003c=105,1\u003c=m\u003c=5000,1\u003c=k\u003c=10,1\u003c=p\u003c=109 ). They represent the number of the bamboos in Mr. Kitayuta’s garden, the duration of Mr. Kitayuta’s fight in days, the maximum number of times that Mr. Kitayuta beat the bamboos during each day, and the power of Magic Hammer, respectively. The following n n n lines describe the properties of the bamboos. The i i i -th of them ( 1\u003c=i\u003c=n 1\u003c=i\u003c=n 1\u003c=i\u003c=n ) contains two space-separated integers hi h_{i} hi​ and ai a_{i} ai​ ( 0\u003c=hi\u003c=109,1\u003c=ai\u003c=109 0\u003c=h_{i}\u003c=10^{9},1\u003c=a_{i}\u003c=10^{9} 0\u003c=hi​\u003c=109,1\u003c=ai​\u003c=109 ), denoting the initial height and the growth rate of the i i i -th bamboo, respectively. 输出格式: Print the lowest possible height of the tallest bamboo after m m m days. 样例: 样例输入1: 3 1 2 5 10 10 10 10 15 2 样例输出1: 17 样例输入2: 2 10 10 1000000000 0 10 0 10 样例输出2: 10 样例输入3: 5 3 3 10 9 5 9 2 4 7 9 10 3 8 样例输出3: 14 思路: 实现: #include \"ybwhead/ios.h\" const int maxn = 2e5 + 10; int n, m, k, c[maxn]; long long a[maxn], p, h[maxn]; priority_queue\u003cpair\u003clong long, long long\u003e, vector\u003cpair\u003clong long, long long\u003e\u003e, greater\u003cpair\u003clong long, long long\u003e\u003e\u003e q; int check(long long x) { while (!q.empty()) q.pop(); memset(c, 0, sizeof(c)); for (int i = 1; i \u003c= n; i++) if (x - a[i] * m \u003c h[i]) q.push(make_pair(x / a[i], i)); for (int i = 1; !q.empty() \u0026\u0026 i \u003c= m; i++) { for (int j = 1; j \u003c= k \u0026\u0026 !q.empty(); j++) { pair\u003clong long, long long\u003e tmp = q.top(); q.pop(); if (tmp.first \u003c i) return 0; ++c[tmp.second]; if (x + c[tmp.second] * p - a[tmp.second] * m \u003c h[tmp.second]) { q.push(make_pair((x + c[tmp.second] * p) / a[tmp.second], tmp.second)); } } } return q.empty(); } int main() { long long l, r = 0; yin \u003e\u003e n \u003e\u003e m \u003e\u003e k \u003e\u003e p; for (int i = 1; i \u003c= n; i++) yin \u003e\u003e h[i] \u003e\u003e a[i], r = max(r, h[i] + a[i] * m); l = 0; r++; while (l \u003c r) { long long mid = l + r \u003e\u003e 1; if (check(mid)) r = mid; else l = mid + 1; } yout \u003c\u003c l \u003c\u003c endl; return 0; } ","date":"2020-09-03","objectID":"/posts/oi/problems/cf505e/:0:0","series":null,"tags":["模拟","二分答案","Notebooks/OI/OJ/Luogu"],"title":"CF505E-Mr. Kitayuta vs. Bamboos","uri":"/posts/oi/problems/cf505e/#"},{"categories":null,"content":"P3761-[TJOI2017]城市 题目: 题目描述: 从加里敦大学城市规划专业毕业的小明来到了一个地区城市规划局工作。这个地区一共有 nnn 座城市，n−1n-1n−1 条高速公路，保证了任意两运城市之间都可以通过高速公路相互可达，但是通过一条高速公路需要收取一定的交通费用。小明对这个地区深入研究后，觉得这个地区的交通费用太贵。 小明想彻底改造这个地区，但是由于上司给他的资源有限，因而小明现在只能对一条高速公路进行改造，改造的方式就是去掉一条高速公路，并且重新修建一条一样的高速公路（即交通费用一样），使得这个地区的两个城市之间的最大交通费用最小（即使得交通费用最大的两座城市之间的交通费用最小），并且保证修建完之后任意两座城市相互可达。如果你是小明，你怎么解决这个问题？ 输入格式: 输入数据的第一行为一个整数 nnn，代表城市个数。 接下来的 n−1n - 1n−1 行分别代表了最初的 n−1n-1n−1 条公路情况。每一行都有三个整数 u,v,du,v,du,v,d。u,vu,vu,v 代表这条公路的两端城市标号，ddd 代表这条公路的交通费用。 1≤u,v≤n1 \\leq u,v \\leq n1≤u,v≤n，1≤d≤20001\\leq d \\leq 20001≤d≤2000。 输出格式: 输出数据仅有一行，一个整数，表示进行了最优的改造之后，该地区两城市 之间最大交通费用。 样例: 样例输入1: 5 1 2 1 2 3 2 3 4 3 4 5 4 样例输出1: 7 思路: 实现: #include \u003cbits/stdc++.h\u003e using namespace std; struct bbbb { int to, nextt, xx; } b[10010]; int n, tail, dd[5010], dis[5010], vis[5010], ldd, rdd, diss[5010], ttll; struct llbb { int xxx, x; } lb[5010]; struct cccc { int zjcd, bjcd, zd; } cc1[5010], cc2[5010]; void jb(int x, int y, int z) { tail++; b[tail].nextt = dd[x]; b[tail].to = y; b[tail].xx = z; dd[x] = tail; return; } queue\u003cint\u003e q; void bfs(int x) { memset(vis, 0, sizeof(vis)); dis[x] = 0; vis[x] = 1; q.push(x); while (q.empty() == false) { int xx = q.front(); q.pop(); for (int i = dd[xx]; i != 0; i = b[i].nextt) { if (vis[b[i].to] == 0) { vis[b[i].to] = 1; dis[b[i].to] = dis[xx] + b[i].xx; q.push(b[i].to); } } } return; } bool dfs(int x, int mb) { if (x == mb) { ttll++; lb[ttll].x = x; return true; } for (int i = dd[x]; i != 0; i = b[i].nextt) { if (vis[b[i].to] == 0) { vis[b[i].to] = 1; if (dfs(b[i].to, mb) == true) { ttll++; lb[ttll].x = x; lb[ttll].xxx = b[i].xx; return true; } } } return false; } int bfs1(int x) { int maxx = 0; q.push(x); while (q.empty() == false) { int xx = q.front(); q.pop(); maxx = max(maxx, diss[xx]); for (int i = dd[xx]; i != 0; i = b[i].nextt) { if (vis[b[i].to] == 0) { vis[b[i].to] = 1; diss[b[i].to] = diss[xx] + b[i].xx; q.push(b[i].to); } } } return maxx; } int main() { scanf(\"%d\", \u0026n); for (int i = 1; i \u003c n; i++) { int x, y, z; scanf(\"%d%d%d\", \u0026x, \u0026y, \u0026z); jb(x, y, z); jb(y, x, z); } bfs(1); for (int i = 1; i \u003c= n; i++) { if (dis[ldd] \u003c= dis[i]) { ldd = i; } } bfs(ldd); for (int i = 1; i \u003c= n; i++) { if (dis[rdd] \u003c= dis[i]) { rdd = i; } } memset(vis, 0, sizeof(vis)); vis[ldd] = 1; dfs(ldd, rdd); memset(vis, 0, sizeof(vis)); for (int i = 1; i \u003c= ttll; i++) { vis[lb[i].x] = 1; } int zhongd = 1; for (int i = 2; i \u003c= ttll; i++) { diss[lb[i].x] = diss[lb[i - 1].x] + lb[i].xxx; int qwq = bfs1(lb[i].x); if (qwq \u003c= cc1[lb[i - 1].x].zjcd) { cc1[lb[i].x] = cc1[lb[i - 1].x]; } else { while (zhongd \u003c i \u0026\u0026 max(diss[lb[zhongd].x], qwq - diss[lb[zhongd].x]) \u003e max(diss[lb[zhongd + 1].x], qwq - diss[lb[zhongd + 1].x])) { zhongd++; } cc1[lb[i].x].zjcd = qwq; cc1[lb[i].x].bjcd = max(diss[lb[zhongd].x], qwq - diss[lb[zhongd].x]); } } memset(vis, 0, sizeof(vis)); memset(diss, 0, sizeof(diss)); for (int i = 1; i \u003c= ttll; i++) { vis[lb[i].x] = 1; } zhongd = ttll; for (int i = ttll - 1; i \u003e= 1; i--) { diss[lb[i].x] = diss[lb[i + 1].x] + lb[i + 1].xxx; int qwq = bfs1(lb[i].x); if (qwq \u003c= cc2[lb[i + 1].x].zjcd) { cc2[lb[i].x] = cc2[lb[i + 1].x]; } else { while (zhongd \u003e i \u0026\u0026 max(diss[lb[zhongd].x], qwq - diss[lb[zhongd].x]) \u003e max(diss[lb[zhongd - 1].x], qwq - diss[lb[zhongd - 1].x])) { zhongd--; } cc2[lb[i].x].zjcd = qwq; cc2[lb[i].x].bjcd = max(diss[lb[zhongd].x], qwq - diss[lb[zhongd].x]); } } int minn = 1e9; for (int i = 1; i \u003c ttll; i++) { minn = min(minn, max(cc1[lb[i].x].bjcd + cc2[lb[i + 1].x].bjcd + lb[i + 1].xxx, max(cc1[lb[i].x].zjcd, cc2[lb[i + 1].x].zjcd))); } printf(\"%d\", minn); return 0; } ","date":"2020-08-26","objectID":"/posts/oi/problems/p3761/:0:0","series":null,"tags":[2017,"各省省选","枚举,暴力","树的直径","高性能","天津","Notebooks/OI/OJ/Luogu"],"title":"P3761-[TJOI2017]城市","uri":"/posts/oi/problems/p3761/#"},{"categories":null,"content":"P4284-[SHOI2014]概率充电器 题目: 题目描述: 著名的电子产品品牌SHOI 刚刚发布了引领世界潮流的下一代电子产品—— 概率充电器： “采用全新纳米级加工技术，实现元件与导线能否通电完全由真随机数决 定！SHOI 概率充电器，您生活不可或缺的必需品！能充上电吗？现在就试试看 吧！” SHOI 概率充电器由n-1 条导线连通了n 个充电元件。进行充电时，每条导 线是否可以导电以概率决定，每一个充电元件自身是否直接进行充电也由概率 决定。随后电能可以从直接充电的元件经过通电的导线使得其他充电元件进行 间接充电。 作为SHOI 公司的忠实客户，你无法抑制自己购买SHOI 产品的冲动。在排 了一个星期的长队之后终于入手了最新型号的SHOI 概率充电器。你迫不及待 地将SHOI 概率充电器插入电源——这时你突然想知道，进入充电状态的元件 个数的期望是多少呢？ 输入格式: 第一行一个整数：n。概率充电器的充电元件个数。充电元件由1-n 编号。 之后的n-1 行每行三个整数a, b, p，描述了一根导线连接了编号为a 和b 的 充电元件，通电概率为p%。 第n+2 行n 个整数：qi。表示i 号元件直接充电的概率为qi%。 输出格式: 输出一行一个实数，为能进入充电状态的元件个数的期望，四舍五入到小 数点后6 位小数。 样例: 样例输入1: 3 1 2 50 1 3 50 50 0 0 样例输出1: 1.000000 样例输入2: 5 1 2 90 1 3 80 1 4 70 1 5 60 100 10 20 30 40 样例输出2: 4.300000 思路: 实现: #include \"ybwhead/ios.h\" int n; const int maxn = 500050; int head[maxn], tot; struct edge { int v, nxt; double w; } e[maxn \u003c\u003c 1]; void __ADD(int u, int v, double w) { e[++tot] = {v, head[u], w}; head[u] = tot; } void add(int u, int v, double w) { __ADD(u, v, w); __ADD(v, u, w); } double x[maxn]; double f[maxn]; double g[maxn]; void dfs1(int u, int fa) { f[u] = 1 - x[u]; for (int i = head[u]; i; i = e[i].nxt) { int v = e[i].v; if (v == fa) continue; dfs1(v, u); f[u] *= (1 - e[i].w + e[i].w * f[v]); } } void dfs2(int u, int fa) { for (int i = head[u]; i; i = e[i].nxt) { int v = e[i].v; if (v == fa) continue; double tmp = g[u] / (1 - e[i].w + e[i].w * f[v]); g[v] = f[v] * (1 - e[i].w + e[i].w * tmp); dfs2(v, u); } } int main() { yin \u003e\u003e n; for (int i = 1; i \u003c n; i++) { int x, y; double z; yin \u003e\u003e x \u003e\u003e y \u003e\u003e z; add(x, y, z / 100); } for (int i = 1; i \u003c= n; i++) { yin \u003e\u003e x[i]; x[i] /= 100; } dfs1(1, 0); g[1] = f[1]; dfs2(1, 0); double ans = 0; for (int i = 1; i \u003c= n; i++) ans += 1 - g[i]; yout \u003c\u003c ans \u003c\u003c endl; return 0; } ","date":"2020-08-26","objectID":"/posts/oi/problems/p4284/:0:0","series":null,"tags":[2014,"各省省选","上海","连通块","条件概率","期望","高斯消元","高性能","Notebooks/OI/OJ/Luogu"],"title":"P4284-[SHOI2014]概率充电器","uri":"/posts/oi/problems/p4284/#"},{"categories":null,"content":"CF979E-Kuro and Topological Parity 题目: 题目描述: Kuro has recently won the “Most intelligent cat ever” contest. The three friends then decided to go to Katie’s home to celebrate Kuro’s winning. After a big meal, they took a small break then started playing games. Kuro challenged Katie to create a game with only a white paper, a pencil, a pair of scissors and a lot of arrows (you can assume that the number of arrows is infinite). Immediately, Katie came up with the game called Topological Parity. The paper is divided into n n n pieces enumerated from 1 1 1 to n n n . Shiro has painted some pieces with some color. Specifically, the i i i -th piece has color ci c_{i} ci​ where ci=0 c_{i} = 0 ci​=0 defines black color, ci=1 c_{i} = 1 ci​=1 defines white color and ci=−1 c_{i} = -1 ci​=−1 means that the piece hasn’t been colored yet. The rules of the game is simple. Players must put some arrows between some pairs of different pieces in such a way that for each arrow, the number in the piece it starts from is less than the number of the piece it ends at. Also, two different pieces can only be connected by at most one arrow. After that the players must choose the color ( 0 0 0 or 1 1 1 ) for each of the unpainted pieces. The score of a valid way of putting the arrows and coloring pieces is defined as the number of paths of pieces of alternating colors. For example, [1→0→1→0] [1 \\to 0 \\to 1 \\to 0] [1→0→1→0] , [0→1→0→1] [0 \\to 1 \\to 0 \\to 1] [0→1→0→1] , [1] [1] [1] , [0] [0] [0] are valid paths and will be counted. You can only travel from piece x x x to piece y y y if and only if there is an arrow from x x x to y y y . But Kuro is not fun yet. He loves parity. Let’s call his favorite parity p p p where p=0 p = 0 p=0 stands for “even” and p=1 p = 1 p=1 stands for “odd”. He wants to put the arrows and choose colors in such a way that the score has the parity of p p p . It seems like there will be so many ways which satisfy Kuro. He wants to count the number of them but this could be a very large number. Let’s help him with his problem, but print it modulo 109+7 10^{9} + 7 109+7 . 输入格式: The first line contains two integers n n n and p p p ( 1≤n≤50 1 \\leq n \\leq 50 1≤n≤50 , 0≤p≤1 0 \\leq p \\leq 1 0≤p≤1 ) — the number of pieces and Kuro’s wanted parity. The second line contains n n n integers c1,c2,...,cn c_{1}, c_{2}, ..., c_{n} c1​,c2​,...,cn​ ( −1≤ci≤1 -1 \\leq c_{i} \\leq 1 −1≤ci​≤1 ) — the colors of the pieces. 输出格式: Print a single integer — the number of ways to put the arrows and choose colors so the number of valid paths of alternating colors has the parity of p p p . 样例: 样例输入1: 3 1 -1 0 1 样例输出1: 6 样例输入2: 2 1 1 0 样例输出2: 1 样例输入3: 1 1 -1 样例输出3: 2 思路: 实现: #include \"ybwhead/ios.h\" const int mod = 1e9 + 7; const int N = 60; int n, p, _2[N], a[N]; int f[N][2][2][2], ans; void add(int \u0026x, int y) { x += y; if (x \u003e= mod) x -= mod; } int main() { yin \u003e\u003e n \u003e\u003e p; for (int i = 1; i \u003c= n; i++) yin \u003e\u003e a[i]; _2[0] = 1; for (int i = 1; i \u003c= n; i++) _2[i] = (_2[i - 1] \u003c\u003c 1) % mod; f[0][0][0][0] = 1; for (int i = 1; i \u003c= n; i++) for (int _ = 0; _ \u003c= 1; _++) for (int ob = 0; ob \u003c= 1; ob++) for (int ow = 0; ow \u003c= 1; ow++) { int qwq = f[i - 1][_][ob][ow]; if (a[i] != 0) { //白点 if (ob) { //讨论有无奇黑 add(f[i][_][ob][ow], 1ll * qwq * _2[i - 2] % mod); add(f[i][_ ^ 1][ob][ow | 1], 1ll * qwq * _2[i - 2] % mod); } else add(f[i][_ ^ 1][ob][ow | 1], 1ll * qwq * _2[i - 1] % mod); } if (a[i] != 1) { if (ow) { add(f[i][_][ob][ow], 1ll * qwq * _2[i - 2] % mod); add(f[i][_ ^ 1][ob | 1][ow], 1ll * qwq * _2[i - 2] % mod); } else add(f[i][_ ^ 1][ob | 1][ow], 1ll * qwq * _2[i - 1] % mod); } } for (int ob = 0; ob \u003c= 1; ob++) for (int ow = 0; ow \u003c= 1; ow++) add(ans, f[n][p][ob][ow]); yout \u003c\u003c ans \u003c\u003c endl; } ","date":"2020-08-25","objectID":"/posts/oi/problems/cf979e/:0:0","series":null,"tags":["递推","排列组合","Notebooks/OI/OJ/Luogu"],"title":"CF979E-Kuro and Topological Parity","uri":"/posts/oi/problems/cf979e/#"},{"categories":null,"content":"P3177-[HAOI2015]树上染色 题目: 题目描述: 有一棵点数为 nnn 的树，树边有边权。给你一个在 0∼n0 \\sim n0∼n 之内的正整数 kkk ，你要在这棵树中选择 kkk 个点，将其染成黑色，并将其他 的 n−kn-kn−k 个点染成白色。将所有点染色后，你会获得黑点两两之间的距离加上白点两两之间的距离的和的受益。问受益最大值是多少。 输入格式: 第一行包含两个整数 n,kn, kn,k。 第二到 nnn 行每行三个正整数 fr,to,disfr, to, disfr,to,dis，表示该树中存在一条长度为 disdisdis 的边 (fr,to)(fr, to)(fr,to)。输入保证所有点之间是联通的。 输出格式: 输出一个正整数，表示收益的最大值。 样例: 样例输入 1: 3 1 1 2 1 1 3 2 样例输出 1: 3 思路: 实现: #include \"ybwhead/ios.h\" int n, k; const int maxn = 2e3 + 10; struct edge { int v, w, nxt; } e[maxn \u003c\u003c 1]; long long f[maxn][maxn]; int head[maxn], tot; void __ADD(int u, int v, int w) { e[++tot] = (edge){v, w, head[u]}; head[u] = tot; } void add(int u, int v, int w) { __ADD(u, v, w); __ADD(v, u, w); } int sz[maxn]; void dfs(int u, int fa) { sz[u] = 1; f[u][0] = f[u][1] = 0; for (int i = head[u]; i; i = e[i].nxt) { int v = e[i].v; if (v == fa) continue; dfs(v, u); sz[u] += sz[v]; long long w = e[i].w; for (int i = min(k, sz[u]); i \u003e= 0; i--) { for (int j = 0; j \u003c= min(i, sz[v]); j++) { if (f[u][i - j] != -1) { long long val = w * (long long)j * (k - j) + w * (long long)(sz[v] - j) * (n - k + j - sz[v]); f[u][i] = max(f[u][i], f[u][i - j] + f[v][j] + val); } } } } return; } int main() { yin \u003e\u003e n \u003e\u003e k; for (int i = 1; i \u003c n; i++) { int a, b, c; yin \u003e\u003e a \u003e\u003e b \u003e\u003e c; add(a, b, c); } memset(f, -1, sizeof(f)); dfs(1, 0); yout \u003c\u003c f[1][k] \u003c\u003c endl; return 0; } ","date":"2020-08-22","objectID":"/posts/oi/problems/p3177/:0:0","series":null,"tags":["dp",2015,"河南","树形动规","高性能","Notebooks/OI/OJ/Luogu"],"title":"P3177-[HAOI2015]树上染色","uri":"/posts/oi/problems/p3177/#"},{"categories":null,"content":"P2501-[HAOI2006]数字序列 题目: 题目描述: 现在我们有一个长度为 nnn 的整数序列 aaa。但是它太不好看了，于是我们希望把它变成一个单调严格上升的序列。但是不希望改变过多的数，也不希望改变的幅度太大。 输入格式: 第一行是一个整数，表示序列长度 nnn。 第二行有 nnn 个整数，第 iii 个整数表示序列的第 iii 项 aia_iai​。 输出格式: 第一行输出一个整数，表示最少需要改变多少个数。 第二行输出一个整数，表示在改变的数最少的情况下，每个数改变的绝对值之和的最小值。 样例: 样例输入 1: 4 5 2 3 5 样例输出 1: 1 4 思路: 实现: #include \"ybwhead/ios.h\" // #define rep(i, m, n) for (int i = m; i \u003c= n; ++i) // #define dop(i, m, n) for (int i = m; i \u003e= n; --i) // #define each(i, m, v) for (int i = head[m], v = e[i].to; i; i = e[i].next, v = e[i].to) // #define lowbit(x) (x \u0026 (-x)) // #define ll long long const long long INF = 1073741824; // #define re register // using namespace std; const int maxn = 35010; int n, a[maxn], c[maxn], dp[maxn], len, tmp, num, head[maxn]; long long f[maxn], sum1[maxn], sum2[maxn]; struct Edge { int to, nxt; } e[maxn]; void Add(int from, int to) { e[++num].to = to; e[num].nxt = head[from]; head[from] = num; } //邻接表 int main() { yin \u003e\u003e n; for (int i = 1; i \u003c= n; i++) yin \u003e\u003e a[i], a[i] = a[i] - i; for (int i = 1; i \u003c= n; i++) c[i] = INF; c[0] = -INF; dp[1] = 1; len = 1; a[++n] = INF; c[1] = a[1]; a[0] = -INF; for (int i = 2; i \u003c= n; i++) { tmp = upper_bound(c, c + 1 + len, a[i]) - c; len = max(len, tmp); dp[i] = tmp; c[tmp] = min(c[tmp], a[i]); } yout \u003c\u003c n - dp[n] \u003c\u003c endl; for (int i = n; i \u003e= 0; i--) Add(dp[i], i), f[i] = INF; f[0] = 0; for (int i = 1; i \u003c= n; i++) for (int j = head[dp[i] - 1], to = e[j].to; j; j = e[j].nxt, to = e[j].to) { if (to \u003e i) break; if (a[to] \u003e a[i]) continue; for (int k = to; k \u003c= i; k++) sum1[k] = abs(a[k] - a[to]), sum2[k] = abs(a[k] - a[i]); for (int k = to + 1; k \u003c= i; k++) sum1[k] += sum1[k - 1], sum2[k] += sum2[k - 1]; for (int k = to; k \u003c= i - 1; k++) f[i] = min(f[i], f[to] + sum1[k] - sum1[to] + sum2[i] - sum2[k]); } yout \u003c\u003c f[n] \u003c\u003c endl; return 0; } ","date":"2020-08-22","objectID":"/posts/oi/problems/p2501/:0:0","series":null,"tags":["dp","递推",2006,"河南","各省省选","枚举, 暴力","Notebooks/OI/OJ/Luogu"],"title":"P2501-[HAOI2006]数字序列","uri":"/posts/oi/problems/p2501/#"},{"categories":null,"content":"P2150-[NOI2015]寿司晚宴 题目: 题目描述: 为了庆祝 NOI 的成功开幕，主办方为大家准备了一场寿司晚宴。小 G 和小 W 作为参加 NOI 的选手，也被邀请参加了寿司晚宴。 在晚宴上，主办方为大家提供了 n−1n−1n−1 种不同的寿司，编号 1,2,3,…,n−11, 2, 3, \\ldots, n-11,2,3,…,n−1，其中第种寿司的美味度为 i+1i+1i+1。（即寿司的美味度为从 222 到 nnn） 现在小 G 和小 W 希望每人选一些寿司种类来品尝，他们规定一种品尝方案为不和谐的当且仅当：小 G 品尝的寿司种类中存在一种美味度为 xxx 的寿司，小 W 品尝的寿司中存在一种美味度为 yyy 的寿司，而 xxx 与 yyy 不互质。 现在小 G 和小 W 希望统计一共有多少种和谐的品尝寿司的方案（对给定的正整数 ppp 取模）。注意一个人可以不吃任何寿司。 输入格式: 输入文件的第 111 行包含 222 个正整数 n,pn, pn,p 中间用单个空格隔开，表示共有 nnn 种寿司，最终和谐的方案数要对 ppp 取模。 输出格式: 输出一行包含 111 个整数，表示所求的方案模 ppp 的结果。 样例: 样例输入1: 3 10000 样例输出1: 9 样例输入2: 4 10000 样例输出2: 21 样例输入3: 100 100000000 样例输出3: 3107203 思路: 实现: #include \"ybwhead/ios.h\" int n; long long mod; const int maxn = 5e2 + 10; // int a[maxn]; int p[10] = {0, 2, 3, 5, 7, 11, 13, 17, 19, 0}; struct node { int big, S; node() {} node(int vv) { int i, tmp = vv; big = -1; S = 0; for (i = 1; i \u003c= 8; i++) { if (tmp % p[i]) continue; S |= (1 \u003c\u003c (i - 1)); while (tmp % p[i] == 0) tmp /= p[i]; } if (tmp != 1) big = tmp; } friend bool operator\u003c(node a, node b) { return a.big \u003c b.big; } } a[maxn]; long long dp[maxn][maxn], f[maxn][maxn], g[maxn][maxn]; long long pl(long long x, long long y) { x += y; return x \u003e= mod ? x - mod : x; } int main() { yin \u003e\u003e n \u003e\u003e mod; for (int i = 2; i \u003c= n; i++) { a[i - 1] = (node){i}; } sort(a + 1, a + n); dp[0][0] = f[0][0] = g[0][0] = 1; for (int i = 1; i \u003c n; i++) { for (int j = 255; j \u003e= 0; j--) { for (int k = 255; k \u003e= 0; k--) { if (j \u0026 k) continue; if ((a[i].S \u0026 j) == 0) g[j][k | a[i].S] = pl(g[j][k | a[i].S], g[j][k]); if ((a[i].S \u0026 k) == 0) f[j | a[i].S][k] = pl(f[j | a[i].S][k], f[j][k]); } } if (i == n - 1 || a[i].big != a[i + 1].big || a[i].big == -1) { for (int j = 0; j \u003c 256; j++) for (int k = 0; k \u003c 256; k++) if ((j \u0026 k) == 0) dp[j][k] = pl(f[j][k], pl(g[j][k], mod - dp[j][k])); memcpy(f, dp, sizeof(f)); memcpy(g, dp, sizeof(g)); } } long long ans = 0; for (int j = 0; j \u003c 256; j++) for (int k = 0; k \u003c 256; k++) if ((j \u0026 k) == 0) ans = pl(ans, dp[j][k]); yout \u003c\u003c ans \u003c\u003c endl; return 0; } ","date":"2020-08-22","objectID":"/posts/oi/problems/p2150/:0:0","series":null,"tags":["dp","数论, 数学",2015,"NOI系列","状态压缩, 状压","素数判断, 质数, 筛法","高性能","Notebooks/OI/OJ/Luogu"],"title":"P2150-[NOI2015]寿司晚宴","uri":"/posts/oi/problems/p2150/#"},{"categories":null,"content":"P3523-[POI2011]DYN-Dynamite 题目: 题目描述: The Byteotian Cave is composed of nnn chambers and n−1n-1n−1 corridors that connect them. For every pair of chambers there is unique way to move from one of them to another without leaving the cave. Dynamite charges are set up in certain chambers. A fuse is laid along every corridor. In every chamber the fuses from the adjacent corridors meet at one point, and are further connected to the dynamite charge if there is one in the chamber. It takes exactly one unit of time for the fuse between two neighbouring chambers to burn, and the dynamite charge explodes in the instant that fire reaches the chamber it is inside. We would like to light the fuses in some mmm chambers (at the joints of fuses) in such a way that all the dynamite charges explode in the shortest time possible since the fuses are lit. Write a program that will determine the minimum such time possible. 给一棵树,书上有一些关键节点，要求你选m个点，使得关键节点到这些点中距离的最小值的最大值最小，求这个值 输入格式: The first line of the standard input holds two integers nnn and mmm(1≤m≤n≤300 0001\\le m\\le n\\le 300\\ 0001≤m≤n≤300 000), separated by a single space, that denote, respectively, the number of chambers in the cave and the number of chambers in which fire can be set to the fuses. The chambers are numbered from 1 to nnn. The next line contains nnn integers d1,d2,⋯ ,dnd_1,d_2,\\cdots,d_nd1​,d2​,⋯,dn​ (di∈{0,1}d_i\\in \\{0,1\\}di​∈{0,1}), separated by single spaces. If di=1d_i=1di​=1, then there is dynamite in the iii-th chamber, and if di=0d_i=0di​=0, there is none.The following n−1n-1n−1 lines specify the corridors of the cave. Each of them holds two integers a,ba,ba,b(1≤a\u003cb≤n1\\le a\u003cb\\le n1≤a\u003cb≤n), separated by a single space, denoting that there is a corridor connecting the chambers aaa and bbb. Every corridor appears exactly once in the description. You may assume that in tests worth 10% of the points it holds additionally that n≤10n\\le 10n≤10 , while in tests worth 40% of the points it holds that n≤1 000n\\le 1\\ 000n≤1 000 输出格式: The first and only line of the standard output should hold a single integer, equal to the minimum time it takes from lighting the fuses to the explosion of all the charges. 样例: 样例输入1: 7 2 1 0 1 1 0 1 1 1 3 2 3 3 4 4 5 5 6 5 7 样例输出1: 1 思路: 实现: #include \"ybwhead/ios.h\" int n, m; const int maxn = 3e5 + 10; int a[maxn]; struct edge { int v, nxt; } e[maxn \u003c\u003c 1]; int head[maxn], tot; void __ADD(int u, int v) { e[++tot] = {v, head[u]}; head[u] = tot; } void add(int u, int v) { __ADD(u, v); __ADD(v, u); } int ans; long long f[maxn]; long long g[maxn]; void dfs(int u, int fa, int len) { g[u] = INT_MAX; f[u] = -g[u]; for (int i = head[u]; i; i = e[i].nxt) { int v = e[i].v; if (v == fa) continue; dfs(v, u, len); f[u] = max(f[u], f[v] + 1); g[u] = min(g[u], g[v] + 1); } if (f[u] + g[u] \u003c= len) f[u] = -INT_MAX; if (g[u] \u003e len \u0026\u0026 a[u] == 1) f[u] = max(f[u], 0ll); if (f[u] == len) ++ans, g[u] = 0, f[u] = -INT_MAX; } int check(int x) { ans = 0; dfs(1, 0, x); if (f[1] \u003e= 0) ++ans; return ans \u003c= m; } int main() { yin \u003e\u003e n \u003e\u003e m; for (int i = 1; i \u003c= n; i++) { yin \u003e\u003e a[i]; } for (int i = 1; i \u003c n; i++) { int a, b; yin \u003e\u003e a \u003e\u003e b; add(a, b); } int l = 0, r = n + 1; while (l \u003c r) { int mid = (l + r) \u003e\u003e 1; if (check(mid)) { r = mid; } else { l = mid + 1; } } yout \u003c\u003c l \u003c\u003c endl; } ","date":"2020-08-22","objectID":"/posts/oi/problems/p3523/:0:0","series":null,"tags":["贪心",2011,"二分答案","POI","树形动规","高性能","Notebooks/OI/OJ/Luogu"],"title":"P3523-[POI2011]DYN-Dynamite","uri":"/posts/oi/problems/p3523/#"},{"categories":null,"content":"P3622-[APIO2007]动物园 题目: 题目描述: 新建的圆形动物园是亚太地区的骄傲。圆形动物园坐落于太平洋的一个小岛上，包含一大圈围栏，每个围栏里有一 种动物。如下图所示： 你是动物园的公共主管。你要做的是，让每个来动物园的人都尽可能高兴。今天有一群小朋友来动物园参观，你希望能让他们在动物园度过一段美好的时光。但这并不是一件容易的事——有的动物有一些小朋友喜欢，有的动物有一些小朋友害怕。如，Alex 喜欢可爱的猴子和考拉，而害怕拥牙齿锋利的狮子。而Polly 会因狮子有美丽的鬃毛而喜欢它，但害怕有臭味的考拉。你可以选择将一些动物从围栏中移走以使得小朋友不会害怕。但你不能移走所有的动物，否则小朋友们就没有动物可看了。每个小朋友站在大围栏圈的外面，可以看到连续的 555 个围栏。你得到了所有小朋友喜欢和害怕的动物信息。当下面两处情况之一发生时，小朋友就会高兴： 至少有一个他害怕的动物被移走 至少有一个他喜欢的动物没被移走 例如，考虑下图中的小朋友和动物： 假如你将围栏 444 和 121212 的动物移走。Alex 和 Ka-Shu 将很高兴，因为至少有一个他们害怕的动物被移走了。这也会使 Chaitanya 高兴，因为他喜欢的围栏 666 和 888 中的动物都保留了。但是，Polly 和 Hwan 将不高兴，因为他们看不到任何他们喜欢的动物，而他们害怕的动物都还在。这种安排方式使得三个小朋友高兴。 现在，换一种方法，如果你将围栏 444 和 666 中的动物移走，Alex 和 Polly 将很高兴，因为他们害怕的动物被移走了。Chaitanya 也会高兴，虽然他喜欢的动物 666 被移走了，他仍可以看到围栏 888 里面他喜欢的动物。同样的 Hwan 也会因可以看到自己喜欢的动物 121212 而高兴。唯一不高兴的只有 Ka-Shu。 如果你只移走围栏 131313 中的动物，Ka-Shu 将高兴，因为有一个他害怕的动物被移走了，Alex, Polly, Chaitanya 和 Hwan 也会高兴，因为他们都可以看到至少一个他们喜欢的动物。所以有 555 个小朋友会高兴。这种方法使得了最多的小朋友高兴。 输入格式: 输入的第一行包含两个整数 NNN，CCC，用空格分隔。 NNN 是围栏数（10≤N≤10410 \\le N \\le 10^410≤N≤104），CCC 是小朋友的个数（1≤C≤5×1041 \\le C \\le 5\\times 10^41≤C≤5×104）。 围栏按照顺时针的方向编号为 1,2,3,⋯ ,N1, 2, 3, \\cdots, N1,2,3,⋯,N。 接下来的 CCC 行，每行描述一个小朋友的信息，以下面的形式给出： E,F,L,X1,X2,⋯ ,XF,Y1,Y2,⋯ ,YLE, F, L , X_1, X_2 , \\cdots , X_F , Y_1 , Y2 , \\cdots , Y_LE,F,L,X1​,X2​,⋯,XF​,Y1​,Y2,⋯,YL​。 其中： EEE 表示这个小朋友可以看到的第一个围栏的编号（1≤E≤N1 \\le E \\le N1≤E≤N），换句话说，该小朋友可以看到的围栏为 EEE， E+1E+1E+1， E+2E+2E+2， E+3E+3E+3， E+4E+4E+4。 注意，如果编号超过 NNN 将继续从 111 开始算。 如：当 N=14N=14N=14，E=13 E=13E=13 时，这个小朋友可以看到的围栏为 13,14,1,213, 14, 1, 213,14,1,2 和 333。 FFF 表示该小朋友害怕的动物数。 LLL 表示该小朋友喜欢的动物数。 围栏 X1,X2,⋯ ,XFX_1, X_2, \\cdots, X_FX1​,X2​,⋯,XF​ 中包含该小朋友害怕的动物。 围栏 Y1,Y2,⋯ ,YLY1, Y2, \\cdots, Y_LY1,Y2,⋯,YL​ 中包含该小朋友喜欢的动物。 X1,X2,⋯ ,XF,Y1,Y2,⋯ ,YLX_1, X_2, \\cdots, X_F, Y_1, Y_2, \\cdots, Y_LX1​,X2​,⋯,XF​,Y1​,Y2​,⋯,YL​ 是两两不同的整数，而且所表示的围栏都是该小朋友可以看到的。 小朋友已经按照他们可以看到的第一个围栏的编号从小到大的顺序排好了（这样最小的 EEE 对应的小朋友排在第一个，最大的 EEE 对应的小朋友排在最后一个）。 注意可能有多于一个小朋友对应的 EEE 是相同的。 输出格式: 仅输出一个数，表示最多可以让多少个小朋友高兴。 样例: 样例输入1: 14 5 2 1 2 4 2 6 3 1 1 6 4 6 1 2 9 6 8 8 1 1 9 12 12 3 0 12 13 2 样例输出1: 5 样例输入2: 12 7 1 1 1 1 5 5 1 1 5 7 5 0 3 5 7 9 7 1 1 7 9 9 1 1 9 11 9 3 0 9 11 1 11 1 1 11 1 样例输出2: 6 思路: 实现: #include \"ybwhead/ios.h\" int n, c; const int maxn = 2e5 + 10; int num[maxn][40]; int f[maxn][40]; int main() { yin \u003e\u003e c \u003e\u003e n; for (int i = 1; i \u003c= n; i++) { int e, f, l, a, b; yin \u003e\u003e e \u003e\u003e f \u003e\u003e l; a = b = 0; for (int j = 1; j \u003c= f; j++) { int x; yin \u003e\u003e x; x = (x - e + c) % c; a |= 1 \u003c\u003c x; } for (int j = 1; j \u003c= l; j++) { int x; yin \u003e\u003e x; x = (x - e + c) % c; b |= 1 \u003c\u003c x; } for (int j = 0; j \u003c 32; j++) { if ((j \u0026 a) || (~j \u0026 b)) num[e][j]++; } } int ans = 0; memset(f[0], 128, sizeof(f[0])); for (int S = 0; S \u003c 32; S++) { f[0][S] = 0; for (int i = 1; i \u003c= c; i++) for (int S1 = 0; S1 \u003c 32; S1++) f[i][S1] = max(f[i - 1][(S1 \u0026 15) \u003c\u003c 1], f[i - 1][(S1 \u0026 15) \u003c\u003c 1 | 1]) + num[i][S1]; if (f[c][S] \u003e ans) ans = f[c][S]; f[0][S] = INT_MIN / 2; } yout \u003c\u003c ans \u003c\u003c endl; return 0; } ","date":"2020-08-22","objectID":"/posts/oi/problems/p3622/:0:0","series":null,"tags":["dp",2007,"APIO","枚举, 暴力","深度优先搜索, DFS","状态压缩, 状压","高性能","Notebooks/OI/OJ/Luogu"],"title":"P3622-[APIO2007]动物园","uri":"/posts/oi/problems/p3622/#"},{"categories":null,"content":"P2048-[NOI2010]超级钢琴 题目: 题目描述: 小 Z 是一个小有名气的钢琴家，最近 C 博士送给了小 Z 一架超级钢琴，小 Z 希望能够用这架钢琴创作出世界上最美妙的音乐。 这架超级钢琴可以弹奏出 nnn 个音符，编号为 111 至 nnn。第 iii 个音符的美妙度为 AiA_iAi​，其中 AiA_iAi​ 可正可负。 一个“超级和弦”由若干个编号连续的音符组成，包含的音符个数不少于 LLL 且不多于 RRR。我们定义超级和弦的美妙度为其包含的所有音符的美妙度之和。两个超级和弦被认为是相同的，当且仅当这两个超级和弦所包含的音符集合是相同的。 小 Z 决定创作一首由 kkk 个超级和弦组成的乐曲，为了使得乐曲更加动听，小 Z 要求该乐曲由 kkk 个不同的超级和弦组成。我们定义一首乐曲的美妙度为其所包含的所有超级和弦的美妙度之和。小 Z 想知道他能够创作出来的乐曲美妙度最大值是多少。 输入格式: 输入第一行包含四个正整数 n,k,L,Rn, k, L, Rn,k,L,R。其中 nnn 为音符的个数，kkk 为乐曲所包含的超级和弦个数，LLL 和 RRR 分别是超级和弦所包含音符个数的下限和上限。 接下来 nnn 行，每行包含一个整数 AiA_iAi​，表示按编号从小到大每个音符的美妙度。 输出格式: 输出只有一个整数，表示乐曲美妙度的最大值。 样例: 样例输入 1: 4 3 2 3 3 2 -6 8 样例输出 1: 11 思路: 实现: #include \"ybwhead/ios.h\" int n, k, l, r; const int maxn = 5e5 + 10; int s[maxn]; int f[maxn][20]; int qq(int l, int r) { int k = log2(r - l + 1); int x = f[l][k], y = f[r - (1 \u003c\u003c k) + 1][k]; return s[x] \u003e s[y] ? x : y; } struct node { int o, l, r, t; node() {} node(int oo, int ll, int rr) : o(oo), l(ll), r(rr), t(qq(l, r)) {} friend bool operator\u003c(const node \u0026a, const node \u0026b) { return s[a.t] - s[a.o - 1] \u003c s[b.t] - s[b.o - 1]; } }; priority_queue\u003cnode\u003e q; int main() { yin \u003e\u003e n \u003e\u003e k \u003e\u003e l \u003e\u003e r; for (int i = 1; i \u003c= n; i++) { yin \u003e\u003e s[i]; s[i] += s[i - 1]; f[i][0] = i; } for (int j = 1; j \u003c= 18; j++) { for (int i = 1; i \u003c= n - (1 \u003c\u003c j) + 1; i++) { int x = f[i][j - 1], y = f[i + (1 \u003c\u003c (j - 1))][j - 1]; if (s[x] \u003e s[y]) f[i][j] = x; else f[i][j] = y; } } for (int i = 1; i \u003c= n - l + 1; i++) q.push((node){i, i + l - 1, min(n, i + r - 1)}); long long ans = 0; while (k--) { node x = q.top(); q.pop(); ans += s[x.t] - s[x.o - 1]; if (x.l != x.t) q.push(node(x.o, x.l, x.t - 1)); if (x.r != x.t) q.push(node(x.o, x.t + 1, x.r)); } yout \u003c\u003c ans \u003c\u003c endl; return 0; } ","date":"2020-08-21","objectID":"/posts/oi/problems/p2048/:0:0","series":null,"tags":["贪心",2010,"二叉堆","NOI系列","O2优化","RMQ","前缀和","st表,稀疏表","Notebooks/OI/OJ/Luogu"],"title":"P2048-[NOI2010]超级钢琴","uri":"/posts/oi/problems/p2048/#"},{"categories":null,"content":"P5774-[JSOI2016]病毒感染 题目: 题目描述: JOSI 的边陲小镇爆发了严重的 Jebola 病毒疫情，大批群众感染生命垂危。计算机科学家 JYY 采用最新的算法紧急研制出了 Jebola 疫苗，并火速前往灾区救治患者。 一共有 NNN 个小镇爆发了 Jebola 疫情。这些小镇由于地处边陲，仅仅通过一条长直公路连接。方便起见我们将这些小镇按照公路连接顺序由 111 编号到 NNN。JYY 会在第一天一早抵达 111 号小镇。 一开始在 iii 号小镇，有 aia_iai​ 名患者感染了 Jebola 病毒。 每一天 JYY 可以选择： 花费一天时间彻底治愈 JYY 目前所在的村庄的所有 Jebola 患者。这一天不会有任何患者死去； 花费一天的时间前往一个相邻的村庄。 当一天开始时，如果一个村庄里有 kkk 个 Jebola 患者，那么这一天结束时，这 kkk 个患者会感染另外 kkk 个这个村子里的健康村民并死去。所以对于 iii 号村庄，只要这个村庄没有被 JYY 彻底消灭疫情，那么每一天都会有 aia_iai​ 个村民死去。 JYY 希望采用措施使得疫情被整体消灭时，总共死去的村民数量尽量少。 为了达成这一目标，JYY 有时会选择抵达一个村庄但是并不对村民进行施救。这样的行为如果不加限制，往往会造成更加严重的后果。 试想这样的情形：假设当 JYY 第一次抵达村庄 iii，未作救治并直接前往了另一个村庄。那么由于 iii 村庄的人们求生心切，一旦当 JYY 朝向靠近 iii 村庄的方向前行时，iii 村庄的村民就会以为 JYY 是来救他们了，而产生巨大的期望。之后倘若 JYY 再次掉头朝着远离 iii 村庄的方向行进，那么 iii 村庄的村民就会因为巨大的失落而产生绝望的情绪。 为了避免这种情况，JYY 对他的行程做了如下规定： 假设 JYY 进入 iii 村庄并在第二天立即离开（村庄 iii 的疫情并未治愈）。如果在之后的某一天，JYY 从村庄 jjj 前往村庄 kkk，并满足 ∣k−i∣\u003c∣k−j∣|k-i| \\lt |k-j|∣k−i∣\u003c∣k−j∣。那么在之后的日子里 JYY 只能朝着 iii 村庄前进直到抵达 iii 村庄并立即治愈该村的患者。在前往 iii 村庄的过程中，JYY 可以选择将途经村庄的疫情治愈。 比如，如果 JYY 有如下行程： 第一天：从村庄 111 前往村庄 222； 第二天：从村庄 222 前往村庄 333； 第三天：治愈村庄 333； 第四天：前往村庄 222。 此时 JYY 对于之后三天的行程只有唯一一种选择： 第五天：治愈村庄 222； 第六天：前往村庄 111； 第七天：治愈村庄 111。 JYY 想知道在治愈所有村庄之前，至少会有多少村民因 Jebola 死去。 输入格式: 输入第一行包含一个正整数 NNN； 接下来一行包含 NNN 个整数，分别为 a1,a2,...,aNa_1,a_2,...,a_Na1​,a2​,...,aN​。 输出格式: 输出一行一个整数，表示最优行程安排下会死去的村民数量。 样例: 样例输入 1: 6 40 200 1 300 2 10 样例输出 1: 1950 思路: 实现: #include \"ybwhead/ios.h\" long long n, dp[3005][3005], dp2[3005], sum[3005], a[3005]; int main() { yin \u003e\u003e n; for (long long i = 1; i \u003c= n; ++i) yin \u003e\u003e a[i], sum[i] = sum[i - 1] + a[i]; for (long long i = 1; i \u003c= n - 1; ++i) for (long long j = 1; j \u003c= n - i; ++j) dp[j][i + j] = dp[j + 1][i + j] + min((sum[i + j] - sum[j]) * 2, a[j] * i * 3 + sum[i + j] - sum[j]); memset(dp2, 0x3f, sizeof dp2); dp2[0] = 0; for (long long i = 1; i \u003c= n; ++i) for (long long j = 0; j \u003c i; ++j) dp2[i] = min(dp2[i], dp2[j] + dp[j + 1][i] + (4 * i - 4 * j - 2) * (sum[n] - sum[i])); printf(\"%lld\", dp2[n]); return 0; } ","date":"2020-08-21","objectID":"/posts/oi/problems/p5774/:0:0","series":null,"tags":[2016,"各省省选","江苏","Notebooks/OI/OJ/Luogu"],"title":"P5774-[JSOI2016]病毒感染","uri":"/posts/oi/problems/p5774/#"},{"categories":null,"content":"P3647-[APIO2014]连珠线 题目: 题目描述: 在达芬奇时代，有一个流行的儿童游戏称为连珠线。当然，这个游戏是关于珠子和线的。线是红色或蓝色的，珠子被编号为 111 到 nnn。这个游戏从一个珠子开始，每次会用如下方式添加一个新的珠子： Append(w, v)：一个新的珠子 www 和一个已经添加的珠子 vvv 用红线连接起来。 Insert(w, u, v)：一个新的珠子 www 插入到用红线连起来的两个珠子 u,vu, vu,v 之间。具体过程是删去 u,vu, vu,v 之间红线，分别用蓝线连接 u,wu, wu,w 和 w,vw, vw,v。 每条线都有一个长度。游戏结束后，你的最终得分为蓝线长度之和。 给你连珠线游戏结束后的游戏局面，只告诉了你珠子和链的连接方式以及每条线的长度，没有告诉你每条线分别是什么颜色。 你需要写一个程序来找出最大可能得分。即，在所有以给出的最终局面结束的连珠线游戏中找出那个得分最大的，然后输出最大可能得分。 输入格式: 第一行一个正整数 nnn，表示珠子的数量。珠子从 111 到 nnn 编号。 接下来 n−1n - 1n−1 行每行三个整数 ai,bi,cia_i, b_i, c_iai​,bi​,ci​。保证 1≤ai\u003cbi≤n1 \\leq a_i \u003c b_i \\leq n1≤ai​\u003cbi​≤n。1≤ci≤100001 \\leq c_i \\leq 100001≤ci​≤10000。表示 aia_iai​ 号珠子和 bib_ibi​ 号珠子间连了长度为 cic_ici​ 的线。 输出格式: 输出一个整数，表示最大可能得分。 样例: 样例输入 1: 5 1 2 10 1 3 40 1 4 15 1 5 20 样例输出 1: 60 样例输入 2: 10 4 10 2 1 2 21 1 3 13 6 7 1 7 9 5 2 4 3 2 5 8 1 6 55 6 8 34 样例输出 2: 140 思路: 实现: #include \"ybwhead/ios.h\" const int maxn = 5e5 + 10; #define INF 0x3f3f3f3f #define c(x) (f[x][0] + cost[i] - max(f[x][0], f[x][1] + len[x])) using namespace std; int n, cnt; int head[maxn], vet[maxn], Next[maxn], cost[maxn]; void add(int x, int y, int w) { cnt++; Next[cnt] = head[x]; head[x] = cnt; vet[cnt] = y; cost[cnt] = w; } int par[maxn], len[maxn]; int f[maxn][2]; vector\u003cint\u003e son[maxn], dp[maxn][2], mx[maxn]; void dfs(int x, int fa) { f[x][0] = 0, f[x][1] = -INF; int mx1 = -INF, mx2 = -INF; for (int i = head[x]; i; i = Next[i]) { int v = vet[i]; if (v == fa) continue; len[v] = cost[i], par[v] = x; son[x].push_back(v); dfs(v, x); f[x][0] += max(f[v][0], f[v][1] + cost[i]); if (c(v) \u003e mx1) mx2 = mx1, mx1 = c(v); else if (c(v) \u003e mx2) mx2 = c(v); } f[x][1] = f[x][0] + mx1; for (int i = head[x]; i; i = Next[i]) { int v = vet[i]; if (v == fa) continue; dp[x][0].push_back(f[x][0] - max(f[v][0], f[v][1] + cost[i])); if (c(v) == mx1) { dp[x][1].push_back(dp[x][0].back() + mx2); mx[x].push_back(mx2); } else { dp[x][1].push_back(dp[x][0].back() + mx1); mx[x].push_back(mx1); } } } int ans = 0; void solve(int x) { for (int i = 0; i \u003c son[x].size(); i++) { f[x][0] = dp[x][0][i], f[x][1] = dp[x][1][i]; if (par[x]) { f[x][0] += max(f[par[x]][0], f[par[x]][1] + len[x]); f[x][1] = f[x][0] + max(mx[x][i], f[par[x]][0] + len[x] - max(f[par[x]][0], f[par[x]][1] + len[x])); } ans = max(ans, f[son[x][i]][0] + max(f[x][0], f[x][1] + len[son[x][i]])); solve(son[x][i]); } } int main() { yin \u003e\u003e n; int x, y, w; for (int i = 1; i \u003c n; i++) { yin \u003e\u003e x \u003e\u003e y \u003e\u003e w; add(x, y, w); add(y, x, w); } dfs(1, 0); solve(1); yout \u003c\u003c ans \u003c\u003c endl; return 0; } ","date":"2020-08-21","objectID":"/posts/oi/problems/p3647/:0:0","series":null,"tags":["dp",2014,"APIO","枚举, 暴力","高性能","Notebooks/OI/OJ/Luogu"],"title":"P3647-[APIO2014]连珠线","uri":"/posts/oi/problems/p3647/#"},{"categories":null,"content":"P6419-[COCI2014-2015#1] Kamp 题目: 题目描述: 一颗树 nnn 个点，n−1n-1n−1 条边，经过每条边都要花费一定的时间，任意两个点都是联通的。 有 KKK 个人（分布在 KKK 个不同的点）要集中到一个点举行聚会。 聚会结束后需要一辆车从举行聚会的这点出发，把这 KKK 个人分别送回去。 请你回答，对于 i=1∼ni=1 \\sim ni=1∼n ，如果在第 iii 个点举行聚会，司机最少需要多少时间把 KKK 个人都送回家。 输入格式: 第一行两个整数 n,Kn, Kn,K 。 接下来 n−1n-1n−1 行，每行三个数 x,y,zx, y, zx,y,z 表示 xxx 到 yyy 之间有一条需要花费 zzz 时间的边。 接下来 KKK 行，每行一个数，表示 KKK 个人的分布。 输出格式: 输出 nnn 个数。 第 iii 行的数表示：如果在第 iii 个点举行聚会，司机需要的最少时间。 样例: 样例输入 1: 7 2 1 2 4 1 3 1 2 5 1 2 4 2 4 7 3 4 6 2 3 7 样例输出 1: 11 15 10 13 16 15 10 样例输入 2: 5 2 2 5 1 2 4 1 1 2 2 1 3 2 4 5 样例输出 2: 5 3 7 2 2 思路: 实现: #include \"ybwhead/ios.h\" #define int long long int n, k; const int maxn = 5e5 + 10; struct Edge_node { int v, w, nxt; } e[maxn \u003c\u003c 1]; int head[maxn], tot; void __ADD(int u, int v, int w) { e[++tot] = (Edge_node{v, w, head[u]}); head[u] = tot; } void add(int u, int v, int w) { __ADD(u, v, w); __ADD(v, u, w); } int c[maxn], sz[maxn], dp[maxn], len[maxn], len1[maxn], id[maxn]; void dp1(int u, int f) { for (int i = head[u]; i; i = e[i].nxt) { int v = e[i].v; if (v == f) continue; dp1(v, u); if (sz[v]) { sz[u] += sz[v]; dp[u] += dp[v] + 2 * e[i].w; int now = len[v] + e[i].w; if (now \u003e= len[u]) { len1[u] = len[u]; len[u] = now; id[u] = v; } else { len1[u] = max(len1[u], now); } } } } int f[maxn]; void dp2(int u, int fa) { for (int i = head[u]; i; i = e[i].nxt) { int v = e[i].v; if (v == fa) continue; if (!sz[v]) f[v] = f[u] + 2 * e[i].w, len[v] = len[u] + e[i].w; else if (k - sz[v]) { f[v] = f[u]; if (id[u] != v \u0026\u0026 len[v] \u003c len[u] + e[i].w) len1[v] = len[v], len[v] = len[u] + e[i].w, id[v] = u; else if (len[v] \u003c len1[u] + e[i].w) len1[v] = len[v], len[v] = len1[u] + e[i].w, id[v] = 1; else if (len1[v] \u003c len[u] + e[i].w \u0026\u0026 id[u] != v) len1[v] = len[u] + e[i].w; else if (len1[v] \u003c len1[u] + e[i].w) len1[v] = len1[u] + e[i].w; } else f[v] = dp[v]; dp2(v, u); } } signed main() { yin \u003e\u003e n \u003e\u003e k; for (int i = 1; i \u003c n; i++) { int x, y, z; yin \u003e\u003e x \u003e\u003e y \u003e\u003e z; add(x, y, z); } for (int i = 1; i \u003c= k; i++) yin \u003e\u003e c[i], sz[c[i]]++; dp1(1, 0); f[1] = dp[1]; dp2(1, 0); for (int i = 1; i \u003c= n; i++) yout \u003c\u003c f[i] - len[i] \u003c\u003c endl; return 0; } ","date":"2020-08-21","objectID":"/posts/oi/problems/p6419/:0:0","series":null,"tags":["dp","搜索",2014,"树形动规","COCI","Notebooks/OI/OJ/Luogu"],"title":"P6419-[COCI2014-2015#1] Kamp","uri":"/posts/oi/problems/p6419/#"},{"categories":null,"content":"P3354-[IOI2005]Riv 河流 题目: 题目描述: 几乎整个 Byteland 王国都被森林和河流所覆盖。小点的河汇聚到一起，形成了稍大点的河。就这样，所有的河水都汇聚并流进了一条大河，最后这条大河流进了大海。这条大河的入海口处有一个村庄——名叫 Bytetown。 在 Byteland 国，有 nnn 个伐木的村庄，这些村庄都座落在河边。目前在 Bytetown，有一个巨大的伐木场，它处理着全国砍下的所有木料。木料被砍下后，顺着河流而被运到 Bytetown 的伐木场。Byteland 的国王决定，为了减少运输木料的费用，再额外地建造 kkk 个伐木场。这 kkk 个伐木场将被建在其他村庄里。这些伐木场建造后，木料就不用都被送到 Bytetown 了，它们可以在运输过程中第一个碰到的新伐木场被处理。显然，如果伐木场座落的那个村子就不用再付运送木料的费用了。它们可以直接被本村的伐木场处理。 注：所有的河流都不会分叉，形成一棵树，根结点是 Bytetown。 国王的大臣计算出了每个村子每年要产多少木料，你的任务是决定在哪些村子建设伐木场能获得最小的运费。其中运费的计算方法为：每一吨木料每千米 111 分钱。 输入格式: 第一行包括两个整数 n,kn, kn,k。nnn 为村庄数，kkk 为要建的伐木场的数目。除了 Bytetown 外，每个村子依次被命名为 1,2,3…n1, 2, 3\\ldots n1,2,3…n，Bytetown 被命名为 000。 第 222 到第 (n+1)(n + 1)(n+1) 行，每行 333 个整数，第 (i+1)(i + 1)(i+1) 行的整数分别代表，分别表示每年 iii 村子产的木料的块数 wiw_iwi​，离 iii 村子下游最近的村子 viv_ivi​（即 iii 村子的父结点），viv_ivi​ 到 iii 的距离 did_idi​（千米）。 输出格式: 输出最小花费，单位为分。 样例: 样例输入 1: 4 2 1 0 1 1 1 10 10 2 5 1 2 3 样例输出 1: 4 思路: 实现: #include \"ybwhead/ios.h\" const int maxn = 110; int son[maxn], bro[maxn], w[maxn], v[maxn], d[maxn], dis[maxn][maxn], n, k, f[maxn][maxn][maxn]; void dfs(int u, int liml) { int s = son[u]; int b = bro[u]; for (int l = 1; l \u003c= liml; l++) dis[u][l] = dis[v[u]][l - 1] + d[u]; if (s != 0) dfs(s, liml + 1); if (b != 0) dfs(b, liml); for (int i = 0; i \u003c= n; i++) for (int j = 0; j \u003c= n - i; j++) for (int l = 1; l \u003c= liml; l++) { f[u][i + j][l] = min(f[u][i + j][l], f[s][i][l + 1] + f[b][j][l] + w[u] * dis[u][l]); f[u][i + j + 1][l] = min(f[u][i + j + 1][l], f[s][i][1] + f[b][j][l]); } } int main() { cin \u003e\u003e n \u003e\u003e k; for (int i = 1; i \u003c= n; i++) { cin \u003e\u003e w[i] \u003e\u003e v[i] \u003e\u003e d[i]; bro[i] = son[v[i]]; son[v[i]] = i; } memset(f, 0x7f, sizeof(f)); for (int i = 0; i \u003c= n; i++) for (int j = 0; j \u003c= n; j++) f[0][i][j] = 0; dfs(son[0], 1); cout \u003c\u003c f[son[0]][k][1] \u003c\u003c endl; } ","date":"2020-08-21","objectID":"/posts/oi/problems/p3354/:0:0","series":null,"tags":["dp",2005,"IOI","Notebooks/OI/OJ/Luogu"],"title":"P3354-[IOI2005]Riv 河流","uri":"/posts/oi/problems/p3354/#"},{"categories":null,"content":"CF980D-Perfect Groups 题目: 题目描述: SaMer has written the greatest test case of all time for one of his problems. For a given array of integers, the problem asks to find the minimum number of groups the array can be divided into, such that the product of any pair of integers in the same group is a perfect square. Each integer must be in exactly one group. However, integers in a group do not necessarily have to be contiguous in the array. SaMer wishes to create more cases from the test case he already has. His test case has an array A A A of n n n integers, and he needs to find the number of contiguous subarrays of A A A that have an answer to the problem equal to k k k for each integer k k k between 1 1 1 and n n n (inclusive). 输入格式: The first line of input contains a single integer n n n ( 1≤n≤5000 1 \\leq n \\leq 5000 1≤n≤5000 ), the size of the array. The second line contains n n n integers a1 a_1 a1​ , a2 a_2 a2​ , … \\dots … , an a_n an​ ( −108≤ai≤108 -10^8 \\leq a_i \\leq 10^8 −108≤ai​≤108 ), the values of the array. 输出格式: Output n n n space-separated integers, the k k k -th integer should be the number of contiguous subarrays of A A A that have an answer to the problem equal to k k k . 样例: 样例输入 1: 2 5 5 样例输出 1: 3 0 样例输入 2: 5 5 -4 2 1 8 样例输出 2: 5 5 3 2 0 样例输入 3: 1 0 样例输出 3: 1 思路: 实现: #include \"ybwhead/ios.h\" const int maxn = 10010; int n, k; map\u003cint, int\u003e m; int p[maxn]; int visp[maxn], coun[maxn], ans[maxn]; void iszhi(int x) { int count = 0; for (int i = 2; i \u003c= x; i++) { if (!visp[i]) { p[count++] = i; } for (int j = 0;; j++) { int temp = p[j] * i; if (temp \u003e= maxn) break; visp[temp] = 1; if (i % p[j] == 0) { break; } } } } int makeit(int x) { if (!x) return x; for (int i = 0; p[i]; i++) { while (x % p[i] == 0) x /= p[i]; } return x; } int main() { yin \u003e\u003e n; iszhi(maxn - 1); for (int i = 0; p[i]; i++) p[i] *= p[i]; for (int i = 1; i \u003c= n; i++) { yin \u003e\u003e k; k = makeit(k); int temp = m[k]; m[k] = i; int temp0 = m[0]; for (int j = i; j; j--) { if (j \u003e temp) coun[j]++; if (j \u003e temp0 || coun[j] == 1) ans[coun[j]]++; else ans[coun[j] - 1]++; } } for (int i = 1; i \u003c= n; i++) yout \u003c\u003c ans[i] \u003c\u003c ' '; return 0; } ","date":"2020-08-20","objectID":"/posts/oi/problems/cf980d/:0:0","series":null,"tags":["数论,数学","素数判断,质数,筛法","概率论,统计","Notebooks/OI/OJ/Luogu"],"title":"CF980D-Perfect Groups","uri":"/posts/oi/problems/cf980d/#"},{"categories":null,"content":"CF1285E-Delete a Segment 题目: 题目描述: There are n n n segments on a Ox Ox Ox axis [l1,r1] [l_1, r_1] [l1​,r1​] , [l2,r2] [l_2, r_2] [l2​,r2​] , …, [ln,rn] [l_n, r_n] [ln​,rn​] . Segment [l,r] [l, r] [l,r] covers all points from l l l to r r r inclusive, so all x x x such that l≤x≤r l \\le x \\le r l≤x≤r . Segments can be placed arbitrarily — be inside each other, coincide and so on. Segments can degenerate into points, that is li=ri l_i=r_i li​=ri​ is possible. Union of the set of segments is such a set of segments which covers exactly the same set of points as the original set. For example: if n=3 n=3 n=3 and there are segments [3,6] [3, 6] [3,6] , [100,100] [100, 100] [100,100] , [5,8] [5, 8] [5,8] then their union is 2 2 2 segments: [3,8] [3, 8] [3,8] and [100,100] [100, 100] [100,100] ; if n=5 n=5 n=5 and there are segments [1,2] [1, 2] [1,2] , [2,3] [2, 3] [2,3] , [4,5] [4, 5] [4,5] , [4,6] [4, 6] [4,6] , [6,6] [6, 6] [6,6] then their union is 2 2 2 segments: [1,3] [1, 3] [1,3] and [4,6] [4, 6] [4,6] . Obviously, union is a set of pairwise non-intersecting segments. You are asked to erase exactly one segment of the given n n n so that the number of segments in the union of the rest n−1 n-1 n−1 segments is maximum possible. For example, if n=4 n=4 n=4 and there are segments [1,4] [1, 4] [1,4] , [2,3] [2, 3] [2,3] , [3,6] [3, 6] [3,6] , [5,7] [5, 7] [5,7] , then: erasing the first segment will lead to [2,3] [2, 3] [2,3] , [3,6] [3, 6] [3,6] , [5,7] [5, 7] [5,7] remaining, which have 1 1 1 segment in their union; erasing the second segment will lead to [1,4] [1, 4] [1,4] , [3,6] [3, 6] [3,6] , [5,7] [5, 7] [5,7] remaining, which have 1 1 1 segment in their union; erasing the third segment will lead to [1,4] [1, 4] [1,4] , [2,3] [2, 3] [2,3] , [5,7] [5, 7] [5,7] remaining, which have 2 2 2 segments in their union; erasing the fourth segment will lead to [1,4] [1, 4] [1,4] , [2,3] [2, 3] [2,3] , [3,6] [3, 6] [3,6] remaining, which have 1 1 1 segment in their union. Thus, you are required to erase the third segment to get answer 2 2 2 . Write a program that will find the maximum number of segments in the union of n−1 n-1 n−1 segments if you erase any of the given n n n segments. Note that if there are multiple equal segments in the given set, then you can erase only one of them anyway. So the set after erasing will have exactly n−1 n-1 n−1 segments. 输入格式: The first line contains one integer t t t ( 1≤t≤104 1 \\le t \\le 10^4 1≤t≤104 ) — the number of test cases in the test. Then the descriptions of t t t test cases follow. The first of each test case contains a single integer n n n ( 2≤n≤2⋅105 2 \\le n \\le 2\\cdot10^5 2≤n≤2⋅105 ) — the number of segments in the given set. Then n n n lines follow, each contains a description of a segment — a pair of integers li l_i li​ , ri r_i ri​ ( −109≤li≤ri≤109 -10^9 \\le l_i \\le r_i \\le 10^9 −109≤li​≤ri​≤109 ), where li l_i li​ and ri r_i ri​ are the coordinates of the left and right borders of the i i i -th segment, respectively. The segments are given in an arbitrary order. It is guaranteed that the sum of n n n over all test cases does not exceed 2⋅105 2\\cdot10^5 2⋅105 . 输出格式: Print t t t integers — the answers to the t t t given test cases in the order of input. The answer is the maximum number of segments in the union of n−1 n-1 n−1 segments if you erase any of the given n n n segments. 样例: 样例输入1: 3 4 1 4 2 3 3 6 5 7 3 5 5 5 5 5 5 6 3 3 1 1 5 5 1 5 2 2 4 4 样例输出1: 2 1 5 思路: 实现: #include \"ybwhead/ios.h\" const int MaxN = 1e6 + 10; std::map\u003cint, int\u003e m1, m2; int n, cnt, l[MaxN], r[MaxN], a[MaxN], s[MaxN]; inline void prework() { m1.clear(), m2.clear(); for (int i = 1; i \u003c= n; i++) m1[l[i]] = m1[r[i]] = 1; cnt = 0; for (std::map\u003cint, int\u003e::iterator it = m1.begin(); it != m1.end(); it++) m2[it-\u003efirst] = ++cnt; for (int i = 1; i \u003c= n; i++) l[i] = m2[l[i]] * 2 - 1, r[i] = m2[r[i]] * 2 - 1; } int main() { int T; yin \u003e\u003e T; while (T--) { yin \u003e\u003e n; cnt = 0; for (int i = 1; i \u003c= n; i++) yin \u003e\u003e l[i] \u003e\u003e r[i]; ","date":"2020-08-20","objectID":"/posts/oi/problems/cf1285e/:0:0","series":null,"tags":["Notebooks/OI/OJ/Luogu"],"title":"CF1285E-Delete a Segment","uri":"/posts/oi/problems/cf1285e/#"},{"categories":null,"content":"CF1304F2-Animal Observation (hard version) 题目: 题目描述: The only difference between easy and hard versions is the constraint on k k k . Gildong loves observing animals, so he bought two cameras to take videos of wild animals in a forest. The color of one camera is red, and the other one’s color is blue. Gildong is going to take videos for n n n days, starting from day 1 1 1 to day n n n . The forest can be divided into m m m areas, numbered from 1 1 1 to m m m . He’ll use the cameras in the following way: On every odd day ( 1 1 1 -st, 3 3 3 -rd, 5 5 5 -th, …), bring the red camera to the forest and record a video for 2 2 2 days. On every even day ( 2 2 2 -nd, 4 4 4 -th, 6 6 6 -th, …), bring the blue camera to the forest and record a video for 2 2 2 days. If he starts recording on the n n n -th day with one of the cameras, the camera records for only one day. Each camera can observe k k k consecutive areas of the forest. For example, if m=5 m=5 m=5 and k=3 k=3 k=3 , he can put a camera to observe one of these three ranges of areas for two days: [1,3] [1,3] [1,3] , [2,4] [2,4] [2,4] , and [3,5] [3,5] [3,5] . Gildong got information about how many animals will be seen in each area on each day. Since he would like to observe as many animals as possible, he wants you to find the best way to place the two cameras for n n n days. Note that if the two cameras are observing the same area on the same day, the animals observed in that area are counted only once. 输入格式: The first line contains three integers n n n , m m m , and k k k ( 1≤n≤50 1 \\le n \\le 50 1≤n≤50 , 1≤m≤2⋅104 1 \\le m \\le 2 \\cdot 10^4 1≤m≤2⋅104 , 1≤k≤m 1 \\le k \\le m 1≤k≤m ) – the number of days Gildong is going to record, the number of areas of the forest, and the range of the cameras, respectively. Next n n n lines contain m m m integers each. The j j j -th integer in the i+1 i+1 i+1 -st line is the number of animals that can be seen on the i i i -th day in the j j j -th area. Each number of animals is between 0 0 0 and 1000 1000 1000 , inclusive. 输出格式: Print one integer – the maximum number of animals that can be observed. 样例: 样例输入 1: 4 5 2 0 2 1 1 0 0 0 3 1 2 1 0 4 3 1 3 3 0 0 4 样例输出 1: 25 样例输入 2: 3 3 1 1 2 3 4 5 6 7 8 9 样例输出 2: 31 样例输入 3: 3 3 2 1 2 3 4 5 6 7 8 9 样例输出 3: 44 样例输入 4: 3 3 3 1 2 3 4 5 6 7 8 9 样例输出 4: 45 思路: 实现: #include \"ybwhead/ios.h\" #define ll long long #define lc x \u003c\u003c 1 #define rc x \u003c\u003c 1 | 1 #define mid ((l + r) \u003e\u003e 1) using namespace std; struct Tree //线段树 { ll maxv[80005]; void pushup(int x) { maxv[x] = max(maxv[lc], maxv[rc]); } void update(int x, int l, int r, int p, ll v) { if (l == r) { maxv[x] = v; return; } if (p \u003c= mid) update(lc, l, mid, p, v); else update(rc, mid + 1, r, p, v); pushup(x); } ll ask(int x, int l, int r, int from, int to) { if (from \u003e to) return -1e12; if (l \u003e= from \u0026\u0026 r \u003c= to) return maxv[x]; ll ans = -1e12; if (from \u003c= mid) ans = max(ans, ask(lc, l, mid, from, to)); if (to \u003e mid) ans = max(ans, ask(rc, mid + 1, r, from, to)); return ans; } }; Tree t1, t2, t3; //t1,t2,t3分别维护f,x,y int n, m, l; ll a[55][20005], s[55][20005], f[20005]; int main() { yin \u003e\u003e n \u003e\u003e m \u003e\u003e l; for (int i = 1; i \u003c= n; i++) for (int j = 1; j \u003c= m; j++) yin \u003e\u003e a[i][j]; for (int i = 1; i \u003c= n; i++) for (int j = 1; j \u003c= m; j++) s[i][j] = s[i][j - 1] + a[i][j]; for (int i = 1; i \u003c= 80000; i++) t1.maxv[i] = t2.maxv[i] = t3.maxv[i] = -1e12; for (int i = 1; i \u003c= n; i++) { for (int j = 1; j + l - 1 \u003c= m; j++) { f[j] = max(t1.ask(1, 1, m, 1, j - l), t1.ask(1, 1, m, j + l, m)); f[j] = max(f[j], t2.ask(1, 1, m, j - l + 1, j) + s[i][j - 1]); f[j] = max(f[j], t3.ask(1, 1, m, j + 1, j + l) - s[i][j + l - 1]); f[j] = max(f[j], 0ll); } for (int j = 1; j + l - 1 \u003c= m; j++) { f[j] = f[j] + s[i][j + l - 1] - s[i][j - 1] + s[i + 1][j + l - 1] - s[i + 1][j - 1]; t1.update(1, 1, m, j, f[j]); t2.update(1, 1, m, j, f[j] - s[i + 1][j + l - 1]); t3.update(1, 1, m, j, f[j] + s[i + 1][j - 1]); } } yout \u003c\u003c t1.ask(1, 1, n, 1, n) \u003c\u003c endl; return 0; } ","date":"2020-08-20","objectID":"/posts/oi/problems/cf1304f2/:0:0","series":null,"tags":["Notebooks/OI/OJ/Luogu"],"title":"CF1304F2-Animal Observation (hard version)","uri":"/posts/oi/problems/cf1304f2/#"},{"categories":null,"content":"CF1384B2-Koa and the Beach (Hard Version) 题目: 题目描述: The only difference between easy and hard versions is on constraints. In this version constraints are higher. You can make hacks only if all versions of the problem are solved. Koa the Koala is at the beach! The beach consists (from left to right) of a shore, n+1 n+1 n+1 meters of sea and an island at n+1 n+1 n+1 meters from the shore. She measured the depth of the sea at 1,2,…,n 1, 2, \\dots, n 1,2,…,n meters from the shore and saved them in array d d d . di d_i di​ denotes the depth of the sea at i i i meters from the shore for 1≤i≤n 1 \\le i \\le n 1≤i≤n . Like any beach this one has tide, the intensity of the tide is measured by parameter k k k and affects all depths from the beginning at time t=0 t=0 t=0 in the following way: For a total of k k k seconds, each second, tide increases all depths by 1 1 1 . Then, for a total of k k k seconds, each second, tide decreases all depths by 1 1 1 . This process repeats again and again (ie. depths increase for k k k seconds then decrease for k k k seconds and so on …). Formally, let’s define 0 0 0 -indexed array p=[0,1,2,…,k−2,k−1,k,k−1,k−2,…,2,1] p = [0, 1, 2, \\ldots, k - 2, k - 1, k, k - 1, k - 2, \\ldots, 2, 1] p=[0,1,2,…,k−2,k−1,k,k−1,k−2,…,2,1] of length 2k 2k 2k . At time t t t ( 0≤t 0 \\le t 0≤t ) depth at i i i meters from the shore equals di+p[t mod 2k] d_i + p[t \\bmod 2k] di​+p[tmod2k] ( t mod 2k t \\bmod 2k tmod2k denotes the remainder of the division of t t t by 2k 2k 2k ). Note that the changes occur instantaneously after each second, see the notes for better understanding. At time t=0 t=0 t=0 Koa is standing at the shore and wants to get to the island. Suppose that at some time t t t ( 0≤t 0 \\le t 0≤t ) she is at x x x ( 0≤x≤n 0 \\le x \\le n 0≤x≤n ) meters from the shore: In one second Koa can swim 1 1 1 meter further from the shore ( x x x changes to x+1 x+1 x+1 ) or not swim at all ( x x x stays the same), in both cases t t t changes to t+1 t+1 t+1 . As Koa is a bad swimmer, the depth of the sea at the point where she is can’t exceed l l l at integer points of time (or she will drown). More formally, if Koa is at x x x ( 1≤x≤n 1 \\le x \\le n 1≤x≤n ) meters from the shore at the moment t t t (for some integer t≥0 t\\ge 0 t≥0 ), the depth of the sea at this point — dx+p[t mod 2k] d_x + p[t \\bmod 2k] dx​+p[tmod2k] — can’t exceed l l l . In other words, dx+p[t mod 2k]≤l d_x + p[t \\bmod 2k] \\le l dx​+p[tmod2k]≤l must hold always. Once Koa reaches the island at n+1 n+1 n+1 meters from the shore, she stops and can rest. Note that while Koa swims tide doesn’t have effect on her (ie. she can’t drown while swimming). Note that Koa can choose to stay on the shore for as long as she needs and neither the shore or the island are affected by the tide (they are solid ground and she won’t drown there). Koa wants to know whether she can go from the shore to the island. Help her! 输入格式: The first line of the input contains one integer t t t ( 1≤t≤104 1 \\le t \\le 10^4 1≤t≤104 ) — the number of test cases. Description of the test cases follows. The first line of each test case contains three integers n n n , k k k and l l l ( 1≤n≤3⋅105;1≤k≤109;1≤l≤109 1 \\le n \\le 3 \\cdot 10^5; 1 \\le k \\le 10^9; 1 \\le l \\le 10^9 1≤n≤3⋅105;1≤k≤109;1≤l≤109 ) — the number of meters of sea Koa measured and parameters k k k and l l l . The second line of each test case contains n n n integers d1,d2,…,dn d_1, d_2, \\ldots, d_n d1​,d2​,…,dn​ ( 0≤di≤109 0 \\le d_i \\le 10^9 0≤di​≤109 ) — the depths of each meter of sea Koa measured. It is guaranteed that the sum of n n n over all test cases does not exceed 3⋅105 3 \\cdot 10^5 3⋅105 . 输出格式: For each test case: Print Yes if Koa can get from the shore to the island, and No otherwise. You may print each letter in any case (upper or lower). 样例: 样例输入 1: 7 2 1 1 1 0 5 2 3 1 2 3 2 2 4 3 4 0 2 4 3 2 3 5 3 0 7 2 3 3 0 2 1 3 0 1 7 1 4 4 4 3 0 2 4 2 5 2 3 1 2 3 2 2 样例输出 1: Yes No Yes Yes Yes No No 思路: 实现: #include \"ybwhead/ios.h\" int n,","date":"2020-08-17","objectID":"/posts/oi/problems/cf1384b2/:0:0","series":null,"tags":["Notebooks/OI/OJ/Luogu"],"title":"CF1384B2-Koa and the Beach (Hard Version)","uri":"/posts/oi/problems/cf1384b2/#"},{"categories":null,"content":"CF1399F-Yet Another Segments Subset 题目: 题目描述: You are given n n n segments on a coordinate axis OX OX OX . The i i i -th segment has borders [li;ri] [l_i; r_i] [li​;ri​] . All points x x x , for which li≤x≤ri l_i \\le x \\le r_i li​≤x≤ri​ holds, belong to the i i i -th segment. Your task is to choose the maximum by size (the number of segments) subset of the given set of segments such that each pair of segments in this subset either non-intersecting or one of them lies inside the other one. Two segments [li;ri] [l_i; r_i] [li​;ri​] and [lj;rj] [l_j; r_j] [lj​;rj​] are non-intersecting if they have no common points. For example, segments [1;2] [1; 2] [1;2] and [3;4] [3; 4] [3;4] , [1;3] [1; 3] [1;3] and [5;5] [5; 5] [5;5] are non-intersecting, while segments [1;2] [1; 2] [1;2] and [2;3] [2; 3] [2;3] , [1;2] [1; 2] [1;2] and [2;2] [2; 2] [2;2] are intersecting. The segment [li;ri] [l_i; r_i] [li​;ri​] lies inside the segment [lj;rj] [l_j; r_j] [lj​;rj​] if lj≤li l_j \\le l_i lj​≤li​ and ri≤rj r_i \\le r_j ri​≤rj​ . For example, segments [2;2] [2; 2] [2;2] , [2,3] [2, 3] [2,3] , [3;4] [3; 4] [3;4] and [2;4] [2; 4] [2;4] lie inside the segment [2;4] [2; 4] [2;4] , while [2;5] [2; 5] [2;5] and [1;4] [1; 4] [1;4] are not. You have to answer t t t independent test cases. 输入格式: The first line of the input contains one integer t t t ( 1≤t≤1000 1 \\le t \\le 1000 1≤t≤1000 ) — the number of test cases. Then t t t test cases follow. The first line of the test case contains one integer n n n ( 1≤n≤3000 1 \\le n \\le 3000 1≤n≤3000 ) — the number of segments. The next n n n lines describe segments. The i i i -th segment is given as two integers li l_i li​ and ri r_i ri​ ( 1≤li≤ri≤2⋅105 1 \\le l_i \\le r_i \\le 2 \\cdot 10^5 1≤li​≤ri​≤2⋅105 ), where li l_i li​ is the left border of the i i i -th segment and ri r_i ri​ is the right border of the i i i -th segment. Additional constraint on the input: there are no duplicates in the list of segments. It is guaranteed that the sum of n n n does not exceed 3000 3000 3000 ( ∑n≤3000 \\sum n \\le 3000 ∑n≤3000 ). 输出格式: For each test case, print the answer: the maximum possible size of the subset of the given set of segments such that each pair of segments in this subset either non-intersecting or one of them lies inside the other one. 样例: 样例输入1: 4 4 1 5 2 4 2 3 3 4 5 1 5 2 3 2 5 3 5 2 2 3 1 3 2 4 2 3 7 1 10 2 8 2 5 3 4 4 4 6 8 7 7 样例输出1: 3 4 2 7 思路: 实现: #include \"ybwhead/ios.h\" // map\u003cpair\u003cint, int\u003e, int\u003e x; int f[6010][6010]; int n; int a[6010]; vector\u003cint\u003e e[6010]; int l[3010], r[3010]; int main() { int TTT; yin \u003e\u003e TTT; while (TTT--) { yin \u003e\u003e n; // x.clear(); for (int i = 1; i \u003c= n; i++) { yin \u003e\u003e l[i] \u003e\u003e r[i]; a[2 * i - 1] = l[i]; a[2 * i] = r[i]; } sort(a + 1, a + n * 2 + 1); int tot = unique(a + 1, a + n * 2 + 1) - a - 1; for (int i = 1; i \u003c= tot; i++) e[i].clear(); for (int i = 1; i \u003c= n; i++) e[lower_bound(a + 1, a + tot + 1, l[i]) - a].push_back(lower_bound(a + 1, a + tot + 1, r[i]) - a); for (int i = 1; i \u003c= tot; i++) sort(e[i].begin(), e[i].end()); for (int l = 1; l \u003c= tot; l++) { for (int j = l; j \u003c= tot; j++) { int i = j - l + 1; int xx = count(e[i].begin(), e[i].end(), j); f[i][j] = 0; f[i][j] = max(f[i][j], xx + f[i + 1][j]); for (int k = 0; k \u003c e[i].size(); k++) { int nr = e[i][k]; if (nr \u003e= j) break; f[i][j] = max(f[i][j], xx + f[i][nr] + f[nr + 1][j]); } } } yout \u003c\u003c f[1][tot] \u003c\u003c endl; } return 0; } ","date":"2020-08-17","objectID":"/posts/oi/problems/cf1399f/:0:0","series":null,"tags":["Notebooks/OI/OJ/Luogu"],"title":"CF1399F-Yet Another Segments Subset","uri":"/posts/oi/problems/cf1399f/#"},{"categories":null,"content":"P3648-[APIO2014]序列分割 题目: 题目描述: 你正在玩一个关于长度为 nnn 的非负整数序列的游戏。这个游戏中你需要把序列分成 k+1k + 1k+1 个非空的块。为了得到 k+1k + 1k+1 块，你需要重复下面的操作 kkk 次： 选择一个有超过一个元素的块（初始时你只有一块，即整个序列） 选择两个相邻元素把这个块从中间分开，得到两个非空的块。 每次操作后你将获得那两个新产生的块的元素和的乘积的分数。你想要最大化最后的总得分。 输入格式: 第一行包含两个整数 nnn 和 kkk。保证 k+1≤nk + 1 \\leq nk+1≤n。 第二行包含 nnn 个非负整数 a1,a2,⋯ ,ana_1, a_2, \\cdots, a_na1​,a2​,⋯,an​ (0≤ai≤104)(0 \\leq a_i \\leq 10^4)(0≤ai​≤104)，表示前文所述的序列。 输出格式: 第一行输出你能获得的最大总得分。 第二行输出 kkk 个介于 111 到 n−1n - 1n−1 之间的整数，表示为了使得总得分最大，你每次操作中分开两个块的位置。第 iii 个整数 sis_isi​ 表示第 iii 次操作将在 sis_isi​ 和 si+1s_{i + 1}si+1​ 之间把块分开。 如果有多种方案使得总得分最大，输出任意一种方案即可。 样例: 样例输入 1: 7 3 4 1 3 4 0 2 3 样例输出 1: 108 1 3 5 思路: 实现: #include \"ybwhead/ios.h\" const int maxn = 5e5 + 10; long long a[maxn], sum[maxn]; long long g[maxn], f[maxn]; #define Y(x) (g[x] - sum[x] * sum[x]) #define X(x) (-sum[x]) double slope(int x, int y) { if (sum[x] == sum[y]) return -1e18; return (double)(Y(y) - Y(x)) / (X(y) - X(x)); } int nxt[maxn][200]; int n, k; int q[maxn]; int main() { yin \u003e\u003e n \u003e\u003e k; for (int i = 1; i \u003c= n; i++) yin \u003e\u003e a[i], sum[i] = a[i] + sum[i - 1]; int l, r; for (int xx = 1; xx \u003c= k; xx++) { for (int i = 1; i \u003c= n; i++) g[i] = f[i]; l = 1; r = 0; for (int i = 1; i \u003c= n; i++) { while (l \u003c r \u0026\u0026 slope(q[l], q[l + 1]) \u003c= sum[i]) ++l; f[i] = 0; if (l \u003c= r) { int tmp = q[l]; nxt[i][xx] = tmp; f[i] = g[tmp] + sum[tmp] * (sum[i] - sum[tmp]); // yout \u003c\u003c g[tmp] \u003c\u003c endl; } while (l \u003c r \u0026\u0026 slope(q[r - 1], q[r]) \u003e= slope(q[r], i)) --r; q[++r] = i; } } yout \u003c\u003c f[n] \u003c\u003c endl; int tmp = n, kk = k; while (kk) { tmp = nxt[tmp][kk]; yout \u003c\u003c tmp \u003c\u003c ' '; kk--; } } ","date":"2020-08-17","objectID":"/posts/oi/problems/p3648/:0:0","series":null,"tags":[2014,"APIO","Special Judge","枚举,暴力","斜率优化","前缀和","Notebooks/OI/OJ/Luogu"],"title":"P3648-[APIO2014]序列分割","uri":"/posts/oi/problems/p3648/#"},{"categories":null,"content":"CF1392C-Omkar and Waterslide 题目: 题目描述: Omkar is building a waterslide in his water park, and he needs your help to ensure that he does it as efficiently as possible. Omkar currently has n n n supports arranged in a line, the i i i -th of which has height ai a_i ai​ . Omkar wants to build his waterslide from the right to the left, so his supports must be nondecreasing in height in order to support the waterslide. In 1 1 1 operation, Omkar can do the following: take any contiguous subsegment of supports which is nondecreasing by heights and add 1 1 1 to each of their heights. Help Omkar find the minimum number of operations he needs to perform to make his supports able to support his waterslide! An array b b b is a subsegment of an array c c c if b b b can be obtained from c c c by deletion of several (possibly zero or all) elements from the beginning and several (possibly zero or all) elements from the end. An array b1,b2,…,bn b_1, b_2, \\dots, b_n b1​,b2​,…,bn​ is called nondecreasing if bi≤bi+1 b_i\\le b_{i+1} bi​≤bi+1​ for every i i i from 1 1 1 to n−1 n-1 n−1 . 输入格式: Each test contains multiple test cases. The first line contains the number of test cases t t t ( 1≤t≤100 1 \\leq t \\leq 100 1≤t≤100 ). Description of the test cases follows. The first line of each test case contains an integer n n n ( 1≤n≤2⋅105 1 \\leq n \\leq 2 \\cdot 10^5 1≤n≤2⋅105 ) — the number of supports Omkar has. The second line of each test case contains n n n integers a1,a2,...,an a_{1},a_{2},...,a_{n} a1​,a2​,...,an​ (0≤ai≤109) (0 \\leq a_{i} \\leq 10^9) (0≤ai​≤109) — the heights of the supports. It is guaranteed that the sum of n n n over all test cases does not exceed 2⋅105 2 \\cdot 10^5 2⋅105 . 输出格式: For each test case, output a single integer — the minimum number of operations Omkar needs to perform to make his supports able to support his waterslide. 样例: 样例输入1: 3 4 5 3 2 5 5 1 2 3 5 3 3 1 1 1 样例输出1: 3 2 0 思路: 实现: #include \"ybwhead/ios.h\" int n, TTT; int main() { yin \u003e\u003e TTT; while (TTT--) { yin \u003e\u003e n; int la = 0; long long ans = 0; for (int i = 1; i \u003c= n; i++) { int x; yin \u003e\u003e x; if (i \u003e= 2) ans += max(0, la - x); la = x; } yout \u003c\u003c ans \u003c\u003c endl; } } ","date":"2020-08-17","objectID":"/posts/oi/problems/cf1392c/:0:0","series":null,"tags":["Notebooks/OI/OJ/Luogu"],"title":"CF1392C-Omkar and Waterslide","uri":"/posts/oi/problems/cf1392c/#"},{"categories":null,"content":"CF1392B-Omkar and Infinity Clock 题目: 题目描述: Being stuck at home, Ray became extremely bored. To pass time, he asks Lord Omkar to use his time bending power: Infinity Clock! However, Lord Omkar will only listen to mortals who can solve the following problem: You are given an array a a a of n n n integers. You are also given an integer k k k . Lord Omkar wants you to do k k k operations with this array. Define one operation as the following: Set d d d to be the maximum value of your array. For every i i i from 1 1 1 to n n n , replace ai a_{i} ai​ with d−ai d-a_{i} d−ai​ . The goal is to predict the contents in the array after k k k operations. Please help Ray determine what the final sequence will look like! 输入格式: Each test contains multiple test cases. The first line contains the number of cases t t t ( 1≤t≤100 1 \\le t \\le 100 1≤t≤100 ). Description of the test cases follows. The first line of each test case contains two integers n n n and k k k ( 1≤n≤2⋅105,1≤k≤1018 1 \\leq n \\leq 2 \\cdot 10^5, 1 \\leq k \\leq 10^{18} 1≤n≤2⋅105,1≤k≤1018 ) – the length of your array and the number of operations to perform. The second line of each test case contains n n n integers a1,a2,...,an a_{1},a_{2},...,a_{n} a1​,a2​,...,an​ (−109≤ai≤109) (-10^9 \\leq a_{i} \\leq 10^9) (−109≤ai​≤109) – the initial contents of your array. It is guaranteed that the sum of n n n over all test cases does not exceed 2⋅105 2 \\cdot 10^5 2⋅105 . 输出格式: For each case, print the final version of array a a a after k k k operations described above. 样例: 样例输入1: 3 2 1 -199 192 5 19 5 -1 4 2 0 1 2 69 样例输出1: 391 0 0 6 1 3 5 0 思路: 实现: #include \"ybwhead/ios.h\" int TTT; int n, k; const int maxn = 2e5 + 10; int a[maxn]; int main() { yin \u003e\u003e TTT; while (TTT--) { yin \u003e\u003e n \u003e\u003e k; int mx = INT_MIN, mi = INT_MAX; for (int i = 1; i \u003c= n; i++) { yin \u003e\u003e a[i]; mx = max(mx, a[i]), mi = min(mi, a[i]); } // sort(a + 1, a + n + 1); if (k \u0026 1) { for (int i = 1; i \u003c= n; i++) { yout \u003c\u003c mx - a[i] \u003c\u003c \" \"; } } else { for (int i = 1; i \u003c= n; i++) { yout \u003c\u003c a[i] - mi \u003c\u003c \" \"; } } yout \u003c\u003c endl; } } ","date":"2020-08-17","objectID":"/posts/oi/problems/cf1392b/:0:0","series":null,"tags":["Notebooks/OI/OJ/Luogu"],"title":"CF1392B-Omkar and Infinity Clock","uri":"/posts/oi/problems/cf1392b/#"},{"categories":null,"content":"CF1392A-Omkar and Password 题目: 题目描述: Lord Omkar has permitted you to enter the Holy Church of Omkar! To test your worthiness, Omkar gives you a password which you must interpret! A password is an array a a a of n n n positive integers. You apply the following operation to the array: pick any two adjacent numbers that are not equal to each other and replace them with their sum. Formally, choose an index i i i such that 1≤i\u003cn 1 \\leq i \u003c n 1≤i\u003cn and ai≠ai+1 a_{i} \\neq a_{i+1} ai​=ai+1​ , delete both ai a_i ai​ and ai+1 a_{i+1} ai+1​ from the array and put ai+ai+1 a_{i}+a_{i+1} ai​+ai+1​ in their place. For example, for array [7,4,3,7] [7, 4, 3, 7] [7,4,3,7] you can choose i=2 i = 2 i=2 and the array will become [7,4+3,7]=[7,7,7] [7, 4+3, 7] = [7, 7, 7] [7,4+3,7]=[7,7,7] . Note that in this array you can’t apply this operation anymore. Notice that one operation will decrease the size of the password by 1 1 1 . What is the shortest possible length of the password after some number (possibly 0 0 0 ) of operations? 输入格式: Each test contains multiple test cases. The first line contains the number of test cases t t t ( 1≤t≤100 1 \\le t \\le 100 1≤t≤100 ). Description of the test cases follows. The first line of each test case contains an integer n n n ( 1≤n≤2⋅105 1 \\leq n \\leq 2 \\cdot 10^5 1≤n≤2⋅105 ) — the length of the password. The second line of each test case contains n n n integers a1,a2,…,an a_{1},a_{2},\\dots,a_{n} a1​,a2​,…,an​ ( 1≤ai≤109 1 \\leq a_{i} \\leq 10^9 1≤ai​≤109 ) — the initial contents of your password. The sum of n n n over all test cases will not exceed 2⋅105 2 \\cdot 10^5 2⋅105 . 输出格式: For each password, print one integer: the shortest possible length of the password after some number of operations. 样例: 样例输入1: 2 4 2 1 3 1 2 420 420 样例输出1: 1 2 思路: 实现: #include \"ybwhead/ios.h\" int n, TTT; int main() { yin \u003e\u003e TTT; while (TTT--) { yin \u003e\u003e n; int mx = INT_MIN, mi = INT_MAX; for (int i = 1; i \u003c= n; i++) { int x; yin \u003e\u003e x; mx = max(mx, x), mi = min(mi, x); } if (mx == mi) yout \u003c\u003c n \u003c\u003c endl; else yout \u003c\u003c 1 \u003c\u003c endl; } } ","date":"2020-08-17","objectID":"/posts/oi/problems/cf1392a/:0:0","series":null,"tags":["Notebooks/OI/OJ/Luogu"],"title":"CF1392A-Omkar and Password","uri":"/posts/oi/problems/cf1392a/#"},{"categories":null,"content":"P3287-[SCOI2014]方伯伯的玉米田 题目: 题目描述: 方伯伯在自己的农田边散步，他突然发现田里的一排玉米非常的不美。这排玉米一共有 N 株，它们的高度参差不齐。方伯伯认为单调不下降序列很美，所以他决定先把一些玉米拔高，再把破坏美感的玉米拔除掉，使得剩下的玉米的高度构成一个单调不下降序列。方伯伯可以选择一个区间，把这个区间的玉米全部拔高 1 单位高度，他可以进行最多 K 次这样的操作。拔玉米则可以随意选择一个集合的玉米拔掉。问能最多剩多少株玉米，来构成一排美丽的玉米。 输入格式: 第 1 行包含 2 个整数 n，K，分别表示这排玉米的数目以及最多可进行多少次操作。第 2 行包含 n 个整数，第 i 个数表示这排玉米，从左到右第 i 株玉米的高度 ai。 输出格式: 输出 1 个整数，最多剩下的玉米数。 样例: 样例输入 1: 3 1 2 1 3 样例输出 1: 3 思路: 实现: #include \"ybwhead/ios.h\" int n, k; const int maxn = 5e3 + 510; const int maxm = 5e2 + 10; int c[maxm][maxn], d[maxn][maxm]; #define lowbit(x) x \u0026 -x int q(int c[], int pos) { int ans = 0; for (; pos; pos -= lowbit(pos)) ans = max(ans, c[pos]); return ans; } void add(int c[], int pos, int v, int tt) { int ans = 0; for (; pos \u003c= tt; pos += lowbit(pos)) c[pos] = max(c[pos], v); } int main() { yin \u003e\u003e n \u003e\u003e k; int ans = 0; for (int i = 1; i \u003c= n; i++) { int x; yin \u003e\u003e x; for (int j = 0; j \u003c= k; j++) { int y = max(q(c[j + 1], x + j), q(d[x + j], j + 1)) + 1; ans = max(ans, y); add(c[j + 1], x + j, y, maxn - 2); add(d[x + j], j + 1, y, maxm - 2); } } yout \u003c\u003c ans \u003c\u003c endl; } ","date":"2020-08-16","objectID":"/posts/oi/problems/p3287/:0:0","series":null,"tags":["dp",2014,"四川","树状数组","O2优化","高性能","Notebooks/OI/OJ/Luogu"],"title":"P3287-[SCOI2014]方伯伯的玉米田","uri":"/posts/oi/problems/p3287/#"},{"categories":null,"content":"P5665-划分 题目: 题目描述: 2048 年，第三十届 CSP 认证的考场上，作为选手的小明打开了第一题。这个题的样例有 nnn 组数据，数据从 1∼n1 \\sim n1∼n 编号，iii 号数据的规模为 aia_iai​。 小明对该题设计出了一个暴力程序，对于一组规模为 uuu 的数据，该程序的运行时间为 u2u^2u2。然而这个程序运行完一组规模为 uuu 的数据之后，它将在任何一组规模小于 uuu 的数据上运行错误。样例中的 aia_iai​ 不一定递增，但小明又想在不修改程序的情况下正确运行样例，于是小明决定使用一种非常原始的解决方案：将所有数据划分成若干个数据段，段内数据编号连续，接着将同一段内的数据合并成新数据，其规模等于段内原数据的规模之和，小明将让新数据的规模能够递增。 也就是说，小明需要找到一些分界点 1≤k1\u003ck2\u003c⋯\u003ckp\u003cn1 \\leq k_1 \\lt k_2 \\lt \\cdots \\lt k_p \\lt n1≤k1​\u003ck2​\u003c⋯\u003ckp​\u003cn，使得 ∑i=1k1ai≤∑i=k1+1k2ai≤⋯≤∑i=kp+1nai \\sum_{i=1}^{k_1} a_i \\leq \\sum_{i=k_1+1}^{k_2} a_i \\leq \\cdots \\leq \\sum_{i=k_p+1}^{n} a_i i=1∑k1​​ai​≤i=k1​+1∑k2​​ai​≤⋯≤i=kp​+1∑n​ai​注意 ppp 可以为 000 且此时 k0=0k_0 = 0k0​=0，也就是小明可以将所有数据合并在一起运行。 小明希望他的程序在正确运行样例情况下，运行时间也能尽量小，也就是最小化 (∑i=1k1ai)2+(∑i=k1+1k2ai)2+⋯+(∑i=kp+1nai)2 (\\sum_{i=1}^{k_1} a_i)^2 + (\\sum_{i=k_1+1}^{k_2} a_i)^2 + \\cdots + (\\sum_{i=k_p+1}^{n} a_i)^2 (i=1∑k1​​ai​)2+(i=k1​+1∑k2​​ai​)2+⋯+(i=kp​+1∑n​ai​)2小明觉得这个问题非常有趣，并向你请教：给定 nnn 和 aia_iai​，请你求出最优划分方案下，小明的程序的最小运行时间。 输入格式: 由于本题的数据范围较大，部分测试点的 aia_iai​ 将在程序内生成。 第一行两个整数 n,typen, typen,type。nnn 的意义见题目描述，typetypetype 表示输入方式。 若 type=0type = 0type=0，则该测试点的 aia_iai​ 直接给出。输入文件接下来：第二行 nnn 个以空格分隔的整数 aia_iai​，表示每组数据的规模。 若 type=1type = 1type=1，则该测试点的 aia_iai​ 将特殊生成，生成方式见后文。输入文件接下来：第二行六个以空格分隔的整数 x,y,z,b1,b2,mx, y, z, b_1, b_2, mx,y,z,b1​,b2​,m。接下来 mmm 行中，第 i(1≤i≤m)i (1 \\leq i \\leq m)i(1≤i≤m) 行包含三个以空格分隔的正整数 pi,li,rip_i, l_i, r_ipi​,li​,ri​。 对于 type=1type = 1type=1 的 23~25 号测试点，aia_iai​ 的生成方式如下： 给定整数 x,y,z,b1,b2,mx, y, z, b_1, b_2, mx,y,z,b1​,b2​,m，以及 mmm 个三元组 (pi,li,ri)(p_i, l_i, r_i)(pi​,li​,ri​)。 保证 n≥2n \\geq 2n≥2。若 n\u003e2n \\gt 2n\u003e2，则 ∀3≤i≤n,bi=(x×bi−1+y×bi−2+z)mod 230\\forall 3 \\leq i \\leq n, b_i = (x \\times b_{i−1} + y \\times b_{i−2} + z) \\mod 2^{30}∀3≤i≤n,bi​=(x×bi−1​+y×bi−2​+z)mod230。 保证 1≤pi≤n,pm=n1 \\leq p_i \\leq n, p_m = n1≤pi​≤n,pm​=n。令 p0=0p_0 = 0p0​=0，则 pip_ipi​ 还满足 ∀0≤i\u003cm\\forall 0 \\leq i \\lt m∀0≤i\u003cm 有 pi\u003cpi+1p_i \\lt p_{i+1}pi​\u003cpi+1​。 对于所有 1≤j≤m1 \\leq j \\leq m1≤j≤m，若下标值 i(1≤i≤n)i (1 \\leq i \\leq n)i(1≤i≤n)满足 pj−1\u003ci≤pjp_{j−1} \\lt i \\leq p_jpj−1​\u003ci≤pj​，则有 ai=(bimod (rj−lj+1))+lja_i = \\left(b_i \\mod \\left( r_j − l_j + 1 \\right) \\right) + l_jai​=(bi​mod(rj​−lj​+1))+lj​上述数据生成方式仅是为了减少输入量大小，标准算法不依赖于该生成方式。 输出格式: 输出一行一个整数，表示答案。 样例: 样例输入 1: 5 0 5 1 7 9 9 样例输出 1: 247 样例输入 2: 10 0 5 6 7 7 4 6 2 13 19 9 样例输出 2: 1256 样例输入 3: 10000000 1 123 456 789 12345 6789 3 2000000 123456789 987654321 7000000 234567891 876543219 10000000 456789123 567891234 样例输出 3: 4972194419293431240859891640 思路: 实现: #include \"ybwhead/ios.h\" int n, type, x, y, z, m; const int maxn = 4e7 + 10; const int maxm = 1e5 + 10; int a[maxn], b[maxn], p[maxm], l[maxm], r[maxm], q[maxn], pre[maxn]; long long sum[maxn]; const int mod = (1 \u003c\u003c 30); long long d(int x) { return sum[x] + sum[x] - sum[pre[x]]; } int main() { yin \u003e\u003e n \u003e\u003e type; if (type) { yin \u003e\u003e x \u003e\u003e y \u003e\u003e z \u003e\u003e b[1] \u003e\u003e b[2] \u003e\u003e m; for (register int i = 1; i \u003c= m; i++) { yin \u003e\u003e p[i] \u003e\u003e l[i] \u003e\u003e r[i]; } for (register int i = 3; i \u003c= n; i++) { b[i] = (0ll + 1ll * b[i - 1] * x + 1ll * b[i - 2] * y + z) % mod; } for (register int i = 1; i \u003c= m; i++) for (register int j = p[i - 1] + 1; j \u003c= p[i]; j++) { a[j] = (b[j] % (r[i] - l[i] + 1)) + l[i]; sum[j] = sum[j - 1] + a[j]; } } else { for (register int i = 1; i \u003c= n; i++) { yin \u003e\u003e a[i]; sum[i] = sum[i - 1] + a[i]; } } int l, r; l = r = 0; for (register int i = 1; i \u003c= n; i++) { while (l \u003c r \u0026\u0026 d(q[l + 1]) \u003c= sum[i]) ++l; pre[i] = q[l]; while (l \u003c r \u0026\u0026 d(q[r]) \u003e= d(i)) --r; q[++r] = i; } __int128 ans = 0, tmp; int now = n; while (now) { tmp = d(now) - sum[now]; tmp = tmp * tmp; ans += tmp; now = pre[now]; } yout \u003c\u003c ans \u003c\u003c endl; } ","date":"2020-08-16","objectID":"/posts/oi/problems/p5665/:0:0","series":null,"tags":["贪心",2019,"单调队列","NOIp提高组","Notebooks/OI/OJ/Luogu"],"title":"P5665-划分","uri":"/posts/oi/problems/p5665/#"},{"categories":null,"content":"P2607-[ZJOI2008]骑士 题目: 题目描述: Z 国的骑士团是一个很有势力的组织，帮会中汇聚了来自各地的精英。他们劫富济贫，惩恶扬善，受到社会各界的赞扬。 最近发生了一件可怕的事情，邪恶的 Y 国发动了一场针对 Z 国的侵略战争。战火绵延五百里，在和平环境中安逸了数百年的 Z 国又怎能抵挡的住 Y 国的军队。于是人们把所有的希望都寄托在了骑士团的身上，就像期待有一个真龙天子的降生，带领正义打败邪恶。 骑士团是肯定具有打败邪恶势力的能力的，但是骑士们互相之间往往有一些矛盾。每个骑士都有且仅有一个自己最厌恶的骑士（当然不是他自己），他是绝对不会与自己最厌恶的人一同出征的。 战火绵延，人民生灵涂炭，组织起一个骑士军团加入战斗刻不容缓！国王交给了你一个艰巨的任务，从所有的骑士中选出一个骑士军团，使得军团内没有矛盾的两人（不存在一个骑士与他最痛恨的人一同被选入骑士军团的情况），并且，使得这支骑士军团最具有战斗力。 为了描述战斗力，我们将骑士按照 111 至 nnn 编号，给每名骑士一个战斗力的估计，一个军团的战斗力为所有骑士的战斗力总和。 输入格式: 第一行包含一个整数 nnn，描述骑士团的人数。 接下来 nnn 行，每行两个整数，按顺序描述每一名骑士的战斗力和他最痛恨的骑士。 输出格式: 应输出一行，包含一个整数，表示你所选出的骑士军团的战斗力。 样例: 样例输入 1: 3 10 2 20 3 30 1 样例输出 1: 30 思路: 实现: #include \"ybwhead/ios.h\" long long ans; int n; const int maxn = 1e6 + 10; int vis[maxn]; int w[maxn], p[maxn]; struct edge { int v, nxt; } e[maxn \u003c\u003c 1]; int head[maxn], tot; void add(int u, int v) { e[++tot].v = v; e[tot].nxt = head[u]; head[u] = tot; } long long f[maxn][2]; int rt; void dp(int u) { vis[u] = 1; f[u][0] = 0; f[u][1] = w[u]; for (int i = head[u]; i; i = e[i].nxt) { int v = e[i].v; if (v == rt) { f[v][1] = -INT_MAX; } else { dp(v); f[u][0] += max(f[v][0], f[v][1]); f[u][1] += f[v][0]; } } } void fc(int x) { vis[x] = 1; while (!vis[p[x]]) x = p[x], vis[x] = 1; rt = x; dp(x); long long tmp = max(f[x][0], f[x][1]); rt = p[x]; dp(rt); ans += max(tmp, max(f[rt][0], f[rt][1])); } int main() { yin \u003e\u003e n; for (int i = 1; i \u003c= n; i++) { yin \u003e\u003e w[i] \u003e\u003e p[i]; add(p[i], i); } for (int i = 1; i \u003c= n; i++) { if (!vis[i]) { fc(i); } } yout \u003c\u003c ans \u003c\u003c endl; } ","date":"2020-08-16","objectID":"/posts/oi/problems/p2607/:0:0","series":null,"tags":["dp","搜索",2008,"各省省选","浙江","树形动规","高性能","环套树","Notebooks/OI/OJ/Luogu"],"title":"P2607-[ZJOI2008]骑士","uri":"/posts/oi/problems/p2607/#"},{"categories":null,"content":"CF1398F-Controversial Rounds 题目: 题目描述: Alice and Bob play a game. The game consists of several sets, and each set consists of several rounds. Each round is won either by Alice or by Bob, and the set ends when one of the players has won x x x rounds in a row. For example, if Bob won five rounds in a row and x=2 x = 2 x=2 , then two sets ends. You know that Alice and Bob have already played n n n rounds, and you know the results of some rounds. For each x x x from 1 1 1 to n n n , calculate the maximum possible number of sets that could have already finished if each set lasts until one of the players wins x x x rounds in a row. It is possible that the last set is still not finished — in that case, you should not count it in the answer. 输入格式: The first line contains one integer n n n ( 1≤n≤106 1 \\le n \\le 10^6 1≤n≤106 ) — the number of rounds. The second line contains one string s s s of length n n n — the descriptions of rounds. If the i i i -th element of the string is 0, then Alice won the i i i -th round; if it is 1, then Bob won the i i i -th round, and if it is ?, then you don’t know who won the i i i -th round. 输出格式: In the only line print n n n integers. The i i i -th integer should be equal to the maximum possible number of sets that could have already finished if each set lasts until one of the players wins i i i rounds in a row. 样例: 样例输入 1: 6 11?000 样例输出 1: 6 3 2 1 0 0 样例输入 2: 5 01?01 样例输出 2: 5 1 0 0 0 样例输入 3: 12 ???1??????1? 样例输出 3: 12 6 4 3 2 2 1 1 1 1 1 1 思路: 实现: /* *User: ybw051114 *Time: 2020.08.14 22:35:09 */ #include \u003cbits/stdc++.h\u003e using namespace std; #ifndef use_ios11 #define use_ios11 using namespace std; struct ins { int ans; ins() { ans = 1; } #define endl '\\n' void read() { } void read1(char \u0026s) { char c = getchar(); for (; !isprint(c) || c == ' ' || c == '\\n' || c == '\\t'; c = getchar()) ; s = c; if (c == EOF) ans = 0; } void read1(string \u0026s) { s = \"\"; char c = getchar(); for (; !isprint(c) || c == ' ' || c == '\\n' || c == '\\t'; c = getchar()) ; for (; isprint(c) \u0026\u0026 c != ' ' \u0026\u0026 c != '\\n' \u0026\u0026 c != '\\t'; c = getchar()) s += c; if (c == EOF) ans = 0; } template \u003ctypename T\u003e void read1(T \u0026n) { T x = 0; int f = 1; char c = getchar(); for (; !isdigit(c); c = getchar()) { if (c == '-') f = -1; if (c == EOF) { ans = 0; return; } } for (; isdigit(c); c = getchar()) x = x * 10 + c - 48; n = x * f; if (c == EOF) ans = 0; if (c != '.') return; T l = 0.1; while ((c = getchar()) \u003c= '9' \u0026\u0026 c \u003e= '0') x = x + (c \u0026 15) * l, l *= 0.1; n = x * f; if (c == EOF) ans = 0; } void write() {} void write1(string s) { int n = s.size(); for (int i = 0; i \u003c n; i++) putchar(s[i]); } void write1(const char *s) { int n = strlen(s); for (int i = 0; i \u003c n; i++) putchar(s[i]); } void write1(char s) { putchar(s); } void write1(float s, int x = 6) { char y[10001]; sprintf(y, \"%%.%df\", x); printf(y, s); } void write1(double s, int x = 6) { char y[10001]; sprintf(y, \"%%.%dlf\", x); printf(y, s); } void write1(long double s, int x = 6) { char y[10001]; sprintf(y, \"%%.%dLf\", x); printf(y, s); } template \u003ctypename T\u003e void write1(T n) { if (n \u003c 0) n = -n, putchar('-'); if (n \u003e 9) write1(n / 10); putchar('0' + n % 10); } template \u003ctypename T\u003e friend ins operator\u003e\u003e(ins x, T \u0026n); template \u003ctypename T\u003e friend ins operator\u003c\u003c(ins x, T n); operator bool() { return ans; } }; template \u003ctypename T\u003e ins operator\u003e\u003e(ins x, T \u0026n) { if (!x.ans) return x; x.read1(n); return x; } template \u003ctypename T\u003e ins operator\u003c\u003c(ins x, T n) { x.write1(n); return x; } ins yin; ins yout; #endif #include \u003cbits/stdc++.h\u003e using namespace std; const int maxn = int(1e6) + 99; const int INF = int(1e9) + 99; int n; string s; vector\u003cint\u003e p[2][maxn]; int nxt[2][maxn]; int ptr[2]; char buf[maxn]; int main() { yin \u003e\u003e n \u003e\u003e s; for (int i = n - 1; i \u003e= 0; --i) { if (s[i] != '0') nxt[0][i] = 1 + nxt[0][i + 1]; if (s[i] != '1') nxt[1][i] = 1 + nxt[1][i + 1]; } for (int b = 0; b \u003c= 1; ++b) { int l = 0; while (l \u003c n) { if (s[l] == char('0' + b)) { ++l; continue; } int r = l + 1; while (r \u003c n \u0026\u0026 s[r","date":"2020-08-16","objectID":"/posts/oi/problems/cf1398f/:0:0","series":null,"tags":["Notebooks/OI/OJ/Luogu"],"title":"CF1398F-Controversial Rounds","uri":"/posts/oi/problems/cf1398f/#"},{"categories":null,"content":"P4725-【模板】多项式对数函数（多项式 ln） 题目: 题目描述: 给出 n−1n-1n−1 次多项式 A(x)A(x)A(x)，求一个 mod xn\\bmod{\\:x^n}modxn 下的多项式 B(x)B(x)B(x)，满足 B(x)≡ln⁡A(x)B(x) \\equiv \\ln A(x)B(x)≡lnA(x). 在 mod 998244353\\text{mod } 998244353mod 998244353 下进行，且 ai∈[0,998244353)∩Za_i \\in [0, 998244353) \\cap \\mathbb{Z}ai​∈[0,998244353)∩Z 输入格式: 第一行一个整数 nnn. 下一行有 nnn 个整数，依次表示多项式的系数 a0,a1,⋯ ,an−1a_0, a_1, \\cdots, a_{n-1}a0​,a1​,⋯,an−1​. 保证 a0=1a_0 = 1a0​=1. 输出格式: 输出 nnn 个整数，表示答案多项式中的系数 a0,a1,⋯ ,an−1a_0, a_1, \\cdots, a_{n-1}a0​,a1​,⋯,an−1​. 样例: 样例输入 1: 6 1 927384623 878326372 3882 273455637 998233543 样例输出 1: 0 927384623 817976920 427326948 149643566 610586717 思路: 实现: #include \"ybwhead/ios.h\" int n, lim, l; const int maxn = 1e6 + 10; long long a[maxn], b[maxn]; int r[maxn]; const int mod = 998244353; long long c[maxn]; long long d[maxn]; long long ksm(long long a, int n) { long long ans = 1; while (n) { if (n \u0026 1) ans = ans * a % mod; a = a * a % mod; n \u003e\u003e= 1; } return ans; } const int g = 3, gi = 332748118; void ntt(long long a[], long long x) { for (int i = 0; i \u003c lim; i++) if (i \u003c r[i]) swap(a[i], a[r[i]]); for (int o = 2, k = 1; o \u003c= lim; o \u003c\u003c= 1, k \u003c\u003c= 1) { long long wn = ksm(x, (mod - 1) / (o)); for (int i = 0; i \u003c lim; i += o) { long long w = 1; for (int j = 0; j \u003c k; j++, w = w * wn % mod) { long long x = a[i + j], y = a[i + j + k] * w % mod; a[j + i] = (x + y) % mod; a[j + k + i] = (x - y + mod) % mod; } } } } void calc(int n, long long b[]) { if (n == 1) { b[0] = ksm(a[0], mod - 2); // yout\u003c\u003ca[0] return; } calc((n + 1) \u003e\u003e 1, b); lim = 1; l = 0; while (lim \u003c (n \u003c\u003c 1)) lim \u003c\u003c= 1, ++l; // yout\u003c\u003clim\u003c\u003c\" \"\u003c\u003ca[1]\u003c\u003cendl; for (int i = 0; i \u003c lim; i++) r[i] = (r[i \u003e\u003e 1] \u003e\u003e 1) | ((i \u0026 1) \u003c\u003c (l - 1)); for (int i = 0; i \u003c n; i++) c[i] = a[i]; for (int i = n; i \u003c lim; i++) c[i] = 0; ntt(c, g); ntt(b, g); for (int i = 0; i \u003c lim; i++) { b[i] = (2 - c[i] * b[i] % mod + mod) % mod * b[i] % mod; // yout\u003c\u003cb[i]\u003c\u003cendl; } ntt(b, gi); long long inv = ksm(lim, mod - 2); for (int i = 0; i \u003c n; i++) b[i] = (b[i] * inv) % mod; for (int i = n; i \u003c lim; i++) b[i] = 0; } void dao() { for (int i = 1; i \u003c lim; i++) d[i - 1] = d[i] * i % mod; d[n - 1] = 0; } void jf() { for (int i = lim - 1; i \u003e= 1; i--) d[i] = d[i - 1] * ksm(i, mod - 2) % mod; d[0] = 0; } int main() { yin \u003e\u003e n; for (int i = 0; i \u003c n; i++) yin \u003e\u003e a[i]; for (int i = 0; i \u003c n; i++) d[i] = a[i]; lim = 1, l = 0; while (lim \u003c= (n)) lim \u003c\u003c= 1, ++l; dao(); calc(lim, b); lim = 1, l = 0; while (lim \u003c (n \u003c\u003c 1)) lim \u003c\u003c= 1, ++l; for (int i = 0; i \u003c lim; i++) r[i] = (r[i \u003e\u003e 1] \u003e\u003e 1) | ((i \u0026 1) \u003c\u003c (l - 1)); ntt(d, g); ntt(b, g); for (int i = 0; i \u003c lim; i++) d[i] = (d[i] * b[i]) % mod; ntt(d, gi); long long inv = ksm(lim, mod - 2); for (int i = 0; i \u003c lim; i++) d[i] = (d[i] * inv) % mod; jf(); for (int i = 0; i \u003c n; i++) yout \u003c\u003c d[i] \u003c\u003c \" \"; yout \u003c\u003c endl; return 0; } ","date":"2020-08-16","objectID":"/posts/oi/problems/p4725/:0:0","series":null,"tags":["数论,数学","洛谷原创","O2优化","导数","积分","快速傅里叶变换,DFT,FFT","快速数论变换NTT","Notebooks/OI/OJ/Luogu"],"title":"P4725-【模板】多项式对数函数（多项式 ln）","uri":"/posts/oi/problems/p4725/#"},{"categories":null,"content":"P4148-简单题 题目: 题目描述: 你有一个N×NN \\times NN×N的棋盘，每个格子内有一个整数，初始时的时候全部为 0，现在需要维护两种操作： 1 x y A 1≤x,y≤N1\\le x,y\\le N1≤x,y≤N，A 是正整数。将格子x,y里的数字加上AAA 2 x1 y1 x2 y2 1≤x1≤x2≤N1 \\le x_1 \\le x_2 \\le N1≤x1​≤x2​≤N，1≤y1≤y2≤N1 \\le y_1\\le y_2 \\le N1≤y1​≤y2​≤N。输出x1,y1,x2,y2x_1, y_1, x_2, y_2x1​,y1​,x2​,y2​这个矩形内的数字和 3 无 终止程序 输入格式: 输入文件第一行一个正整数 N。 接下来每行一个操作。每条命令除第一个数字之外，均要异或上一次输出的答案last_ans，初始时last_ans=0。 输出格式: 对于每个 2 操作，输出一个对应的答案。 样例: 样例输入 1: 4 1 2 3 3 2 1 1 3 3 1 1 1 1 2 1 1 0 7 3 样例输出 1: 3 5 思路: 实现: #include \"ybwhead/ios.h\" using namespace std; const int N = 200005; struct point { int x[2], w; } p[N]; struct node { int mi[2], mx[2], sum, ls, rs, sz; point tp; } tr[N]; int n, ans, rt, WD, top, cur, rub[N]; int operator\u003c(point a, point b) { return a.x[WD] \u003c b.x[WD]; } int newnode() { if (top) return rub[top--]; else return ++cur; } void up(int k) { int l = tr[k].ls, r = tr[k].rs; for (int i = 0; i \u003c= 1; ++i) { tr[k].mi[i] = tr[k].mx[i] = tr[k].tp.x[i]; if (l) tr[k].mi[i] = min(tr[k].mi[i], tr[l].mi[i]); if (r) tr[k].mi[i] = min(tr[k].mi[i], tr[r].mi[i]); if (l) tr[k].mx[i] = max(tr[k].mx[i], tr[l].mx[i]); if (r) tr[k].mx[i] = max(tr[k].mx[i], tr[r].mx[i]); } tr[k].sum = tr[l].sum + tr[r].sum + tr[k].tp.w, tr[k].sz = tr[l].sz + tr[r].sz + 1; } int build(int l, int r, int wd) { if (l \u003e r) return 0; int mid = (l + r) \u003e\u003e 1, k = newnode(); WD = wd, nth_element(p + l, p + mid, p + r + 1), tr[k].tp = p[mid]; tr[k].ls = build(l, mid - 1, wd ^ 1), tr[k].rs = build(mid + 1, r, wd ^ 1); up(k); return k; } void pia(int k, int num) { if (tr[k].ls) pia(tr[k].ls, num); p[tr[tr[k].ls].sz + num + 1] = tr[k].tp, rub[++top] = k; if (tr[k].rs) pia(tr[k].rs, num + tr[tr[k].ls].sz + 1); } void check(int \u0026k, int wd) { if (tr[k].sz * 0.75 \u003c tr[tr[k].ls].sz || tr[k].sz * 0.75 \u003c tr[tr[k].rs].sz) pia(k, 0), k = build(1, tr[k].sz, wd); } void ins(int \u0026k, point tmp, int wd) { if (!k) { k = newnode(), tr[k].ls = tr[k].rs = 0, tr[k].tp = tmp, up(k); return; } if (tmp.x[wd] \u003c= tr[k].tp.x[wd]) ins(tr[k].ls, tmp, wd ^ 1); else ins(tr[k].rs, tmp, wd ^ 1); up(k), check(k, wd); } int in(int x1, int y1, int x2, int y2, int X1, int Y1, int X2, int Y2) { return (X1 \u003e= x1 \u0026\u0026 X2 \u003c= x2 \u0026\u0026 Y1 \u003e= y1 \u0026\u0026 Y2 \u003c= y2); } int out(int x1, int y1, int x2, int y2, int X1, int Y1, int X2, int Y2) { return (x1 \u003e X2 || x2 \u003c X1 || y1 \u003e Y2 || y2 \u003c Y1); } int query(int k, int x1, int y1, int x2, int y2) { if (!k) return 0; int re = 0; if (in(x1, y1, x2, y2, tr[k].mi[0], tr[k].mi[1], tr[k].mx[0], tr[k].mx[1])) return tr[k].sum; if (out(x1, y1, x2, y2, tr[k].mi[0], tr[k].mi[1], tr[k].mx[0], tr[k].mx[1])) return 0; if (in(x1, y1, x2, y2, tr[k].tp.x[0], tr[k].tp.x[1], tr[k].tp.x[0], tr[k].tp.x[1])) re += tr[k].tp.w; re += query(tr[k].ls, x1, y1, x2, y2) + query(tr[k].rs, x1, y1, x2, y2); return re; } int main() { int bj, x1, y1, x2, y2; yin \u003e\u003e n; while (1) { yin \u003e\u003e bj; if (bj == 3) break; yin \u003e\u003e x1 \u003e\u003e y1 \u003e\u003e x2; x1 ^= ans; y1 ^= ans; x2 ^= ans; if (bj == 1) ins(rt, (point){x1, y1, x2}, 0); else { yin \u003e\u003e y2; y2 ^= ans; ans = query(rt, x1, y1, x2, y2); yout \u003c\u003c ans \u003c\u003c endl; } } return 0; } ","date":"2020-08-15","objectID":"/posts/oi/problems/p4148/:0:0","series":null,"tags":["递归","概率论,统计","整体二分","K-D Tree","Notebooks/OI/OJ/Luogu"],"title":"P4148-简单题","uri":"/posts/oi/problems/p4148/#"},{"categories":null,"content":"CF1398E-Two Types of Spells 题目: 题目描述: Polycarp plays a computer game (yet again). In this game, he fights monsters using magic spells. There are two types of spells: fire spell of power x x x deals x x x damage to the monster, and lightning spell of power y y y deals y y y damage to the monster and doubles the damage of the next spell Polycarp casts. Each spell can be cast only once per battle, but Polycarp can cast them in any order. For example, suppose that Polycarp knows three spells: a fire spell of power 5 5 5 , a lightning spell of power 1 1 1 , and a lightning spell of power 8 8 8 . There are 6 6 6 ways to choose the order in which he casts the spells: first, second, third. This order deals 5+1+2⋅8=22 5 + 1 + 2 \\cdot 8 = 22 5+1+2⋅8=22 damage; first, third, second. This order deals 5+8+2⋅1=15 5 + 8 + 2 \\cdot 1 = 15 5+8+2⋅1=15 damage; second, first, third. This order deals 1+2⋅5+8=19 1 + 2 \\cdot 5 + 8 = 19 1+2⋅5+8=19 damage; second, third, first. This order deals 1+2⋅8+2⋅5=27 1 + 2 \\cdot 8 + 2 \\cdot 5 = 27 1+2⋅8+2⋅5=27 damage; third, first, second. This order deals 8+2⋅5+1=19 8 + 2 \\cdot 5 + 1 = 19 8+2⋅5+1=19 damage; third, second, first. This order deals 8+2⋅1+2⋅5=20 8 + 2 \\cdot 1 + 2 \\cdot 5 = 20 8+2⋅1+2⋅5=20 damage. Initially, Polycarp knows 0 0 0 spells. His spell set changes n n n times, each time he either learns a new spell or forgets an already known one. After each change, calculate the maximum possible damage Polycarp may deal using the spells he knows. 输入格式: The first line contains one integer n n n ( 1≤n≤2⋅105 1 \\le n \\le 2 \\cdot 10^5 1≤n≤2⋅105 ) — the number of changes to the spell set. Each of the next n n n lines contains two integers tp tp tp and d d d ( 0≤tpi≤1 0 \\le tp_i \\le 1 0≤tpi​≤1 ; −109≤d≤109 -10^9 \\le d \\le 10^9 −109≤d≤109 ; di≠0 d_i \\neq 0 di​=0 ) — the description of the change. If tpi tp_i tpi​ if equal to 0 0 0 , then Polycarp learns (or forgets) a fire spell, otherwise he learns (or forgets) a lightning spell. If di\u003e0 d_i \u003e 0 di​\u003e0 , then Polycarp learns a spell of power di d_i di​ . Otherwise, Polycarp forgets a spell with power −di -d_i −di​ , and it is guaranteed that he knew that spell before the change. It is guaranteed that the powers of all spells Polycarp knows after each change are different (Polycarp never knows two spells with the same power). 输出格式: After each change, print the maximum damage Polycarp can deal with his current set of spells. 样例: 样例输入 1: 6 1 5 0 10 1 -5 0 5 1 11 0 -10 样例输出 1: 5 25 10 15 36 21 思路: 实现: /* *User: ybw051114 *Time: 2020.08.14 22:35:09 */ #include \u003cbits/stdc++.h\u003e using namespace std; #ifndef use_ios11 #define use_ios11 using namespace std; struct ins { int ans; ins() { ans = 1; } #define endl '\\n' void read() { } void read1(char \u0026s) { char c = getchar(); for (; !isprint(c) || c == ' ' || c == '\\n' || c == '\\t'; c = getchar()) ; s = c; if (c == EOF) ans = 0; } void read1(string \u0026s) { s = \"\"; char c = getchar(); for (; !isprint(c) || c == ' ' || c == '\\n' || c == '\\t'; c = getchar()) ; for (; isprint(c) \u0026\u0026 c != ' ' \u0026\u0026 c != '\\n' \u0026\u0026 c != '\\t'; c = getchar()) s += c; if (c == EOF) ans = 0; } template \u003ctypename T\u003e void read1(T \u0026n) { T x = 0; int f = 1; char c = getchar(); for (; !isdigit(c); c = getchar()) { if (c == '-') f = -1; if (c == EOF) { ans = 0; return; } } for (; isdigit(c); c = getchar()) x = x * 10 + c - 48; n = x * f; if (c == EOF) ans = 0; if (c != '.') return; T l = 0.1; while ((c = getchar()) \u003c= '9' \u0026\u0026 c \u003e= '0') x = x + (c \u0026 15) * l, l *= 0.1; n = x * f; if (c == EOF) ans = 0; } void write() {} void write1(string s) { int n = s.size(); for (int i = 0; i \u003c n; i++) putchar(s[i]); } void write1(const char *s) { int n = strlen(s); for (int i = 0; i \u003c n; i++) putchar(s[i]); } void write1(char s) { putchar(s); } void write1(float s, int x = 6) { char y[10001]; sprintf(y, \"%%.%df\", x); printf(y, s); } void write1(double s, int x = 6) { char y[10001]; sprintf(y, \"%%.%dlf\", x); printf(y, s); } void write1(long double s, int x = 6) { char y[10001]; spri","date":"2020-08-15","objectID":"/posts/oi/problems/cf1398e/:0:0","series":null,"tags":["Notebooks/OI/OJ/Luogu"],"title":"CF1398E-Two Types of Spells","uri":"/posts/oi/problems/cf1398e/#"},{"categories":null,"content":"CF1398D-Colored Rectangles 题目: 题目描述: You are given three multisets of pairs of colored sticks: R R R pairs of red sticks, the first pair has length r1 r_1 r1​ , the second pair has length r2 r_2 r2​ , … \\dots … , the R R R -th pair has length rR r_R rR​ ; G G G pairs of green sticks, the first pair has length g1 g_1 g1​ , the second pair has length g2 g_2 g2​ , … \\dots … , the G G G -th pair has length gG g_G gG​ ; B B B pairs of blue sticks, the first pair has length b1 b_1 b1​ , the second pair has length b2 b_2 b2​ , … \\dots … , the B B B -th pair has length bB b_B bB​ ; You are constructing rectangles from these pairs of sticks with the following process: take a pair of sticks of one color; take a pair of sticks of another color different from the first one; add the area of the resulting rectangle to the total area. Thus, you get such rectangles that their opposite sides are the same color and their adjacent sides are not the same color. Each pair of sticks can be used at most once, some pairs can be left unused. You are not allowed to split a pair into independent sticks. What is the maximum area you can achieve? 输入格式: The first line contains three integers R R R , G G G , B B B ( 1≤R,G,B≤200 1 \\le R, G, B \\le 200 1≤R,G,B≤200 ) — the number of pairs of red sticks, the number of pairs of green sticks and the number of pairs of blue sticks. The second line contains R R R integers r1,r2,…,rR r_1, r_2, \\dots, r_R r1​,r2​,…,rR​ ( 1≤ri≤2000 1 \\le r_i \\le 2000 1≤ri​≤2000 ) — the lengths of sticks in each pair of red sticks. The third line contains G G G integers g1,g2,…,gG g_1, g_2, \\dots, g_G g1​,g2​,…,gG​ ( 1≤gi≤2000 1 \\le g_i \\le 2000 1≤gi​≤2000 ) — the lengths of sticks in each pair of green sticks. The fourth line contains B B B integers b1,b2,…,bB b_1, b_2, \\dots, b_B b1​,b2​,…,bB​ ( 1≤bi≤2000 1 \\le b_i \\le 2000 1≤bi​≤2000 ) — the lengths of sticks in each pair of blue sticks. 输出格式: Print the maximum possible total area of the constructed rectangles. 样例: 样例输入 1: 1 1 1 3 5 4 样例输出 1: 20 样例输入 2: 2 1 3 9 5 1 2 8 5 样例输出 2: 99 样例输入 3: 10 1 1 11 7 20 15 19 14 2 4 13 14 8 11 样例输出 3: 372 思路: 实现: /* *User: ybw051114 *Time: 2020.08.14 22:35:09 */ #include \u003cbits/stdc++.h\u003e using namespace std; #ifndef use_ios11 #define use_ios11 using namespace std; struct ins { int ans; ins() { ans = 1; } #define endl '\\n' void read() { } void read1(char \u0026s) { char c = getchar(); for (; !isprint(c) || c == ' ' || c == '\\n' || c == '\\t'; c = getchar()) ; s = c; if (c == EOF) ans = 0; } void read1(string \u0026s) { s = \"\"; char c = getchar(); for (; !isprint(c) || c == ' ' || c == '\\n' || c == '\\t'; c = getchar()) ; for (; isprint(c) \u0026\u0026 c != ' ' \u0026\u0026 c != '\\n' \u0026\u0026 c != '\\t'; c = getchar()) s += c; if (c == EOF) ans = 0; } template \u003ctypename T\u003e void read1(T \u0026n) { T x = 0; int f = 1; char c = getchar(); for (; !isdigit(c); c = getchar()) { if (c == '-') f = -1; if (c == EOF) { ans = 0; return; } } for (; isdigit(c); c = getchar()) x = x * 10 + c - 48; n = x * f; if (c == EOF) ans = 0; if (c != '.') return; T l = 0.1; while ((c = getchar()) \u003c= '9' \u0026\u0026 c \u003e= '0') x = x + (c \u0026 15) * l, l *= 0.1; n = x * f; if (c == EOF) ans = 0; } void write() {} void write1(string s) { int n = s.size(); for (int i = 0; i \u003c n; i++) putchar(s[i]); } void write1(const char *s) { int n = strlen(s); for (int i = 0; i \u003c n; i++) putchar(s[i]); } void write1(char s) { putchar(s); } void write1(float s, int x = 6) { char y[10001]; sprintf(y, \"%%.%df\", x); printf(y, s); } void write1(double s, int x = 6) { char y[10001]; sprintf(y, \"%%.%dlf\", x); printf(y, s); } void write1(long double s, int x = 6) { char y[10001]; sprintf(y, \"%%.%dLf\", x); printf(y, s); } template \u003ctypename T\u003e void write1(T n) { if (n \u003c 0) n = -n, putchar('-'); if (n \u003e 9) write1(n / 10); putchar('0' + n % 10); } template \u003ctypename T\u003e friend ins operator\u003e\u003e(ins x, T \u0026n); template \u003ctypename T\u003e friend ins operator\u003c\u003c(ins x, T n); operator bool() { return ans; } }; template \u003ctypename T\u003e ins operator\u003e\u003e(ins x, T \u0026n) { if (!x.ans) re","date":"2020-08-15","objectID":"/posts/oi/problems/cf1398d/:0:0","series":null,"tags":["Notebooks/OI/OJ/Luogu"],"title":"CF1398D-Colored Rectangles","uri":"/posts/oi/problems/cf1398d/#"},{"categories":null,"content":"CF1398C-Good Subarrays 题目: 题目描述: You are given an array a1,a2,…,an a_1, a_2, \\dots , a_n a1​,a2​,…,an​ consisting of integers from 0 0 0 to 9 9 9 . A subarray al,al+1,al+2,…,ar−1,ar a_l, a_{l+1}, a_{l+2}, \\dots , a_{r-1}, a_r al​,al+1​,al+2​,…,ar−1​,ar​ is good if the sum of elements of this subarray is equal to the length of this subarray ( ∑i=lrai=r−l+1 \\sum\\limits_{i=l}^{r} a_i = r - l + 1 i=l∑r​ai​=r−l+1 ). For example, if a=[1,2,0] a = [1, 2, 0] a=[1,2,0] , then there are 3 3 3 good subarrays: a1…1=[1],a2…3=[2,0] a_{1 \\dots 1} = [1], a_{2 \\dots 3} = [2, 0] a1…1​=[1],a2…3​=[2,0] and a1…3=[1,2,0] a_{1 \\dots 3} = [1, 2, 0] a1…3​=[1,2,0] . Calculate the number of good subarrays of the array a a a . 输入格式: The first line contains one integer t t t ( 1≤t≤1000 1 \\le t \\le 1000 1≤t≤1000 ) — the number of test cases. The first line of each test case contains one integer n n n ( 1≤n≤105 1 \\le n \\le 10^5 1≤n≤105 ) — the length of the array a a a . The second line of each test case contains a string consisting of n n n decimal digits, where the i i i -th digit is equal to the value of ai a_i ai​ . It is guaranteed that the sum of n n n over all test cases does not exceed 105 10^5 105 . 输出格式: For each test case print one integer — the number of good subarrays of the array a a a . 样例: 样例输入 1: 3 3 120 5 11011 6 600005 样例输出 1: 3 6 1 思路: 实现: /* *User: ybw051114 *Time: 2020.08.14 22:35:09 */ #include \u003cbits/stdc++.h\u003e using namespace std; #ifndef use_ios11 #define use_ios11 using namespace std; struct ins { int ans; ins() { ans = 1; } #define endl '\\n' void read() { } void read1(char \u0026s) { char c = getchar(); for (; !isprint(c) || c == ' ' || c == '\\n' || c == '\\t'; c = getchar()) ; s = c; if (c == EOF) ans = 0; } void read1(string \u0026s) { s = \"\"; char c = getchar(); for (; !isprint(c) || c == ' ' || c == '\\n' || c == '\\t'; c = getchar()) ; for (; isprint(c) \u0026\u0026 c != ' ' \u0026\u0026 c != '\\n' \u0026\u0026 c != '\\t'; c = getchar()) s += c; if (c == EOF) ans = 0; } template \u003ctypename T\u003e void read1(T \u0026n) { T x = 0; int f = 1; char c = getchar(); for (; !isdigit(c); c = getchar()) { if (c == '-') f = -1; if (c == EOF) { ans = 0; return; } } for (; isdigit(c); c = getchar()) x = x * 10 + c - 48; n = x * f; if (c == EOF) ans = 0; if (c != '.') return; T l = 0.1; while ((c = getchar()) \u003c= '9' \u0026\u0026 c \u003e= '0') x = x + (c \u0026 15) * l, l *= 0.1; n = x * f; if (c == EOF) ans = 0; } void write() {} void write1(string s) { int n = s.size(); for (int i = 0; i \u003c n; i++) putchar(s[i]); } void write1(const char *s) { int n = strlen(s); for (int i = 0; i \u003c n; i++) putchar(s[i]); } void write1(char s) { putchar(s); } void write1(float s, int x = 6) { char y[10001]; sprintf(y, \"%%.%df\", x); printf(y, s); } void write1(double s, int x = 6) { char y[10001]; sprintf(y, \"%%.%dlf\", x); printf(y, s); } void write1(long double s, int x = 6) { char y[10001]; sprintf(y, \"%%.%dLf\", x); printf(y, s); } template \u003ctypename T\u003e void write1(T n) { if (n \u003c 0) n = -n, putchar('-'); if (n \u003e 9) write1(n / 10); putchar('0' + n % 10); } template \u003ctypename T\u003e friend ins operator\u003e\u003e(ins x, T \u0026n); template \u003ctypename T\u003e friend ins operator\u003c\u003c(ins x, T n); operator bool() { return ans; } }; template \u003ctypename T\u003e ins operator\u003e\u003e(ins x, T \u0026n) { if (!x.ans) return x; x.read1(n); return x; } template \u003ctypename T\u003e ins operator\u003c\u003c(ins x, T n) { x.write1(n); return x; } ins yin; ins yout; #endif map\u003cint, int\u003e x; int sum[100010]; int main() { int TTT; yin \u003e\u003e TTT; while (TTT--) { string s; int n; yin \u003e\u003e n; yin \u003e\u003e s; x.clear(); long long ans = 0; x[0] = 1; for (int i = 0; i \u003c n; i++) { sum[i + 1] = sum[i] + s[i] - '0'; ans += x[(sum[i + 1] - i - 1)]; x[sum[i + 1] - i - 1]++; // yout \u003c\u003c ans \u003c\u003c endl; } yout \u003c\u003c ans \u003c\u003c endl; } return 0; } ","date":"2020-08-15","objectID":"/posts/oi/problems/cf1398c/:0:0","series":null,"tags":["Notebooks/OI/OJ/Luogu"],"title":"CF1398C-Good Subarrays","uri":"/posts/oi/problems/cf1398c/#"},{"categories":null,"content":"CF1398B-Substring Removal Game 题目: 题目描述: Alice and Bob play a game. They have a binary string s s s (a string such that each character in it is either 0 0 0 or 1 1 1 ). Alice moves first, then Bob, then Alice again, and so on. During their move, the player can choose any number (not less than one) of consecutive equal characters in s s s and delete them. For example, if the string is 10110 10110 10110 , there are 6 6 6 possible moves (deleted characters are bold): 10110→0110 \\textbf{1}0110 \\to 0110 10110→0110 ; 10110→1110 1\\textbf{0}110 \\to 1110 10110→1110 ; 10110→1010 10\\textbf{1}10 \\to 1010 10110→1010 ; 10110→1010 101\\textbf{1}0 \\to 1010 10110→1010 ; 10110→100 10\\textbf{11}0 \\to 100 10110→100 ; 10110→1011 1011\\textbf{0} \\to 1011 10110→1011 . After the characters are removed, the characters to the left and to the right of the removed block become adjacent. I. e. the following sequence of moves is valid: 10110→100→1 10\\textbf{11}0 \\to 1\\textbf{00} \\to 1 10110→100→1 . The game ends when the string becomes empty, and the score of each player is the number of 1 1 1 -characters deleted by them. Each player wants to maximize their score. Calculate the resulting score of Alice. 输入格式: The first line contains one integer T T T ( 1≤T≤500 1 \\le T \\le 500 1≤T≤500 ) — the number of test cases. Each test case contains exactly one line containing a binary string s s s ( 1≤∣s∣≤100 1 \\le |s| \\le 100 1≤∣s∣≤100 ). 输出格式: For each test case, print one integer — the resulting score of Alice (the number of 1 1 1 -characters deleted by her). 样例: 样例输入 1: 5 01111001 0000 111111 101010101 011011110111 样例输出 1: 4 0 6 3 6 思路: 实现: /* *User: ybw051114 *Time: 2020.08.14 22:35:09 */ #include \u003cbits/stdc++.h\u003e using namespace std; #ifndef use_ios11 #define use_ios11 using namespace std; struct ins { int ans; ins() { ans = 1; } #define endl '\\n' void read() { } void read1(char \u0026s) { char c = getchar(); for (; !isprint(c) || c == ' ' || c == '\\n' || c == '\\t'; c = getchar()) ; s = c; if (c == EOF) ans = 0; } void read1(string \u0026s) { s = \"\"; char c = getchar(); for (; !isprint(c) || c == ' ' || c == '\\n' || c == '\\t'; c = getchar()) ; for (; isprint(c) \u0026\u0026 c != ' ' \u0026\u0026 c != '\\n' \u0026\u0026 c != '\\t'; c = getchar()) s += c; if (c == EOF) ans = 0; } template \u003ctypename T\u003e void read1(T \u0026n) { T x = 0; int f = 1; char c = getchar(); for (; !isdigit(c); c = getchar()) { if (c == '-') f = -1; if (c == EOF) { ans = 0; return; } } for (; isdigit(c); c = getchar()) x = x * 10 + c - 48; n = x * f; if (c == EOF) ans = 0; if (c != '.') return; T l = 0.1; while ((c = getchar()) \u003c= '9' \u0026\u0026 c \u003e= '0') x = x + (c \u0026 15) * l, l *= 0.1; n = x * f; if (c == EOF) ans = 0; } void write() {} void write1(string s) { int n = s.size(); for (int i = 0; i \u003c n; i++) putchar(s[i]); } void write1(const char *s) { int n = strlen(s); for (int i = 0; i \u003c n; i++) putchar(s[i]); } void write1(char s) { putchar(s); } void write1(float s, int x = 6) { char y[10001]; sprintf(y, \"%%.%df\", x); printf(y, s); } void write1(double s, int x = 6) { char y[10001]; sprintf(y, \"%%.%dlf\", x); printf(y, s); } void write1(long double s, int x = 6) { char y[10001]; sprintf(y, \"%%.%dLf\", x); printf(y, s); } template \u003ctypename T\u003e void write1(T n) { if (n \u003c 0) n = -n, putchar('-'); if (n \u003e 9) write1(n / 10); putchar('0' + n % 10); } template \u003ctypename T\u003e friend ins operator\u003e\u003e(ins x, T \u0026n); template \u003ctypename T\u003e friend ins operator\u003c\u003c(ins x, T n); operator bool() { return ans; } }; template \u003ctypename T\u003e ins operator\u003e\u003e(ins x, T \u0026n) { if (!x.ans) return x; x.read1(n); return x; } template \u003ctypename T\u003e ins operator\u003c\u003c(ins x, T n) { x.write1(n); return x; } ins yin; ins yout; #endif int a[10001]; int main() { int TTT; yin \u003e\u003e TTT; while (TTT--) { string s; yin \u003e\u003e s; int tot, sum; tot = sum = 0; for (int i = 0; i \u003c s.size(); i++) { if (s[i] == '0') { if (sum) a[++tot] = sum; sum = 0; } else sum++; } if (sum) a[++tot] = sum; sort(a + 1, a + tot + 1); int ans = 0; for (int i = tot; i \u003e= 1; i -= 2) ans += a[i]; yout \u003c\u003c ans \u003c\u003c endl; } return 0; } ","date":"2020-08-15","objectID":"/posts/oi/problems/cf1398b/:0:0","series":null,"tags":["Notebooks/OI/OJ/Luogu"],"title":"CF1398B-Substring Removal Game","uri":"/posts/oi/problems/cf1398b/#"},{"categories":null,"content":"CF1398A-Bad Triangle 题目: 题目描述: You are given an array a1,a2,…,an a_1, a_2, \\dots , a_n a1​,a2​,…,an​ , which is sorted in non-decreasing order ( ai≤ai+1) a_i \\le a_{i + 1}) ai​≤ai+1​) . Find three indices i i i , j j j , k k k such that 1≤i\u003cj\u003ck≤n 1 \\le i \u003c j \u003c k \\le n 1≤i\u003cj\u003ck≤n and it is impossible to construct a non-degenerate triangle (a triangle with nonzero area) having sides equal to ai a_i ai​ , aj a_j aj​ and ak a_k ak​ (for example it is possible to construct a non-degenerate triangle with sides 3 3 3 , 4 4 4 and 5 5 5 but impossible with sides 3 3 3 , 4 4 4 and 7 7 7 ). If it is impossible to find such triple, report it. 输入格式: The first line contains one integer t t t ( 1≤t≤1000 1 \\le t \\le 1000 1≤t≤1000 ) — the number of test cases. The first line of each test case contains one integer n n n ( 3≤n≤5⋅104 3 \\le n \\le 5 \\cdot 10^4 3≤n≤5⋅104 ) — the length of the array a a a . The second line of each test case contains n n n integers a1,a2,…,an a_1, a_2, \\dots , a_n a1​,a2​,…,an​ ( 1≤ai≤109 1 \\le a_i \\le 10^9 1≤ai​≤109 ; ai−1≤ai a_{i - 1} \\le a_i ai−1​≤ai​ ) — the array a a a . It is guaranteed that the sum of n n n over all test cases does not exceed 105 10^5 105 . 输出格式: For each test case print the answer to it in one line. If there is a triple of indices i i i , j j j , k k k ( i\u003cj\u003ck i \u003c j \u003c k i\u003cj\u003ck ) such that it is impossible to construct a non-degenerate triangle having sides equal to ai a_i ai​ , aj a_j aj​ and ak a_k ak​ , print that three indices in ascending order. If there are multiple answers, print any of them. Otherwise, print -1. 样例: 样例输入 1: 3 7 4 6 11 11 15 18 20 4 10 10 10 11 3 1 1 1000000000 样例输出 1: 2 3 6 -1 1 2 3 思路: 实现: /* *User: ybw051114 *Time: 2020.08.14 22:35:09 */ #include \u003cbits/stdc++.h\u003e using namespace std; #ifndef use_ios11 #define use_ios11 using namespace std; struct ins { int ans; ins() { ans = 1; } #define endl '\\n' void read() { } void read1(char \u0026s) { char c = getchar(); for (; !isprint(c) || c == ' ' || c == '\\n' || c == '\\t'; c = getchar()) ; s = c; if (c == EOF) ans = 0; } void read1(string \u0026s) { s = \"\"; char c = getchar(); for (; !isprint(c) || c == ' ' || c == '\\n' || c == '\\t'; c = getchar()) ; for (; isprint(c) \u0026\u0026 c != ' ' \u0026\u0026 c != '\\n' \u0026\u0026 c != '\\t'; c = getchar()) s += c; if (c == EOF) ans = 0; } template \u003ctypename T\u003e void read1(T \u0026n) { T x = 0; int f = 1; char c = getchar(); for (; !isdigit(c); c = getchar()) { if (c == '-') f = -1; if (c == EOF) { ans = 0; return; } } for (; isdigit(c); c = getchar()) x = x * 10 + c - 48; n = x * f; if (c == EOF) ans = 0; if (c != '.') return; T l = 0.1; while ((c = getchar()) \u003c= '9' \u0026\u0026 c \u003e= '0') x = x + (c \u0026 15) * l, l *= 0.1; n = x * f; if (c == EOF) ans = 0; } void write() {} void write1(string s) { int n = s.size(); for (int i = 0; i \u003c n; i++) putchar(s[i]); } void write1(const char *s) { int n = strlen(s); for (int i = 0; i \u003c n; i++) putchar(s[i]); } void write1(char s) { putchar(s); } void write1(float s, int x = 6) { char y[10001]; sprintf(y, \"%%.%df\", x); printf(y, s); } void write1(double s, int x = 6) { char y[10001]; sprintf(y, \"%%.%dlf\", x); printf(y, s); } void write1(long double s, int x = 6) { char y[10001]; sprintf(y, \"%%.%dLf\", x); printf(y, s); } template \u003ctypename T\u003e void write1(T n) { if (n \u003c 0) n = -n, putchar('-'); if (n \u003e 9) write1(n / 10); putchar('0' + n % 10); } template \u003ctypename T\u003e friend ins operator\u003e\u003e(ins x, T \u0026n); template \u003ctypename T\u003e friend ins operator\u003c\u003c(ins x, T n); operator bool() { return ans; } }; template \u003ctypename T\u003e ins operator\u003e\u003e(ins x, T \u0026n) { if (!x.ans) return x; x.read1(n); return x; } template \u003ctypename T\u003e ins operator\u003c\u003c(ins x, T n) { x.write1(n); return x; } ins yin; ins yout; #endif int n; int a[100001]; int main() { int TTT; yin \u003e\u003e TTT; while (TTT--) { yin \u003e\u003e n; for (int i = 1; i \u003c= n; i++) yin \u003e\u003e a[i]; sort(a + 1, a + n + 1); if (a[1] + a[2] \u003c= a[n]) yout \u003c\u003c 1 \u003c\u003c \" \" \u003c\u003c 2 \u003c\u003c \" \" \u003c\u003c n \u003c\u003c endl; else yout \u003c\u003c -1 \u003c\u003c endl; } return 0; } ","date":"2020-08-15","objectID":"/posts/oi/problems/cf1398a/:0:0","series":null,"tags":["Notebooks/OI/OJ/Luogu"],"title":"CF1398A-Bad Triangle","uri":"/posts/oi/problems/cf1398a/#"},{"categories":null,"content":"P1527-[国家集训队]矩阵乘法 题目: 题目描述: 给你一个 n×nn \\times nn×n 的矩阵，不用算矩阵乘法，但是每次询问一个子矩形的第 kkk 小数。 输入格式: 第一行有两个整数，分别表示矩阵大小 nnn 和询问组数 qqq。 第 222 到第 (n+1)(n + 1)(n+1) 行，每行 nnn 个整数，表示这个矩阵。第 (i+1)(i + 1)(i+1) 行的第 jjj 个数表示矩阵第 iii 行第 jjj 列的数 ai,ja_{i, j}ai,j​。 接下来 qqq 行，每行五个整数 x1,y1,x2,y2,kx_1, y_1, x_2, y_2, kx1​,y1​,x2​,y2​,k，表示一组询问，要求找到以 (x1,y1)(x_1, y_1)(x1​,y1​) 为左上角，(x2,y2)(x_2, y_2)(x2​,y2​) 为右下角的子矩形中的第 kkk 小数。 输出格式: 对于每组询问，输出一行一个整数表示答案。 样例: 样例输入 1: 2 2 2 1 3 4 1 2 1 2 1 1 1 2 2 3 样例输出 1: 1 3 思路: 实现: #include \"ybwhead/ios.h\" using namespace std; int n; const int maxn = 5e2 + 10; struct node { int x, y, w; } ma[maxn * maxn]; int cnt; int cmp(node a, node b) { return a.w \u003c b.w; } struct query { int x1, y1, x2, y2, w, id, ans; } q[600000]; int tot; struct BIT { int n; int C[maxn][maxn]; BIT(int N = 0) { n = N; } inline int lowbit(int x) { return x \u0026 (-x); } inline void add(int x, int y, int v) { for (register int i = x; i \u003c= n; i += lowbit(i)) for (register int j = y; j \u003c= n; j += lowbit(j)) C[i][j] += v; } inline int pre(int x, int y) { int ans = 0; for (register int i = x; i \u003e 0; i -= lowbit(i)) for (register int j = y; j \u003e 0; j -= lowbit(j)) ans += C[i][j]; return ans; } inline int submat(int x1, int y1, int x2, int y2) { int ans = pre(x2, y2); ans -= pre(x1 - 1, y2) + pre(x2, y1 - 1); ans += pre(x1 - 1, y1 - 1); return ans; } } xx; int t1[maxn * 2000], t2[maxn * 2000]; void solve(int l, int r, int ll, int rr) { if (ll \u003e rr) return; if (l == r) { for (int i = ll; i \u003c= rr; i++) q[q[i].id].ans = ma[l].w; return; } int mid = (l + r) \u003e\u003e 1; for (int i = l; i \u003c= mid; i++) xx.add(ma[i].x, ma[i].y, 1); int cnt1, cnt2; cnt1 = cnt2 = 0; for (int i = ll; i \u003c= rr; i++) { int u = q[i].id; int s = xx.submat(q[u].x1, q[u].y1, q[u].x2, q[u].y2); if (s \u003e= q[u].w) t1[++cnt1] = u; else t2[++cnt2] = u; } for (int i = ll; i \u003c ll + cnt1; i++) q[i].id = t1[i - ll + 1]; for (int i = ll + cnt1; i \u003c= rr; i++) q[i].id = t2[i - ll - cnt1 + 1]; solve(mid + 1, r, ll + cnt1, rr); for (int i = l; i \u003c= mid; i++) xx.add(ma[i].x, ma[i].y, -1); solve(l, mid, ll, ll + cnt1 - 1); } int main() { int qq; yin \u003e\u003e n \u003e\u003e qq; xx.n = n; for (int i = 1; i \u003c= n; i++) { for (int j = 1; j \u003c= n; j++) { int x; yin \u003e\u003e x; ma[++cnt] = (node){i, j, x}; } } sort(ma + 1, ma + cnt + 1, cmp); for (int i = 1; i \u003c= qq; i++) { int x1, x2, y1, y2, k; yin \u003e\u003e x1 \u003e\u003e y1 \u003e\u003e x2 \u003e\u003e y2 \u003e\u003e k; q[++tot] = (query){x1, y1, x2, y2, k, i, 0}; } solve(1, cnt, 1, tot); for (int i = 1; i \u003c= tot; i++) yout \u003c\u003c q[i].ans \u003c\u003c endl; return 0; } ","date":"2020-08-14","objectID":"/posts/oi/problems/p1527/:0:0","series":null,"tags":["WC/CTSC/集训队","O2优化","整体二分","高性能","Notebooks/OI/OJ/Luogu"],"title":"P1527-[国家集训队]矩阵乘法","uri":"/posts/oi/problems/p1527/#"},{"categories":null,"content":"CF1394B-Boboniu Walks on Graph 题目: 题目描述: Boboniu has a directed graph with n n n vertices and m m m edges. The out-degree of each vertex is at most k k k . Each edge has an integer weight between 1 1 1 and m m m . No two edges have equal weights. Boboniu likes to walk on the graph with some specific rules, which is represented by a tuple (c1,c2,…,ck) (c_1,c_2,\\ldots,c_k) (c1​,c2​,…,ck​) . If he now stands on a vertex u u u with out-degree i i i , then he will go to the next vertex by the edge with the ci c_i ci​ -th (1≤ci≤i) (1\\le c_i\\le i) (1≤ci​≤i) smallest weight among all edges outgoing from u u u . Now Boboniu asks you to calculate the number of tuples (c1,c2,…,ck) (c_1,c_2,\\ldots,c_k) (c1​,c2​,…,ck​) such that 1≤ci≤i 1\\le c_i\\le i 1≤ci​≤i for all i i i ( 1≤i≤k 1\\le i\\le k 1≤i≤k ). Starting from any vertex u u u , it is possible to go back to u u u in finite time by walking on the graph under the described rules. 输入格式: The first line contains three integers n n n , m m m and k k k ( 2≤n≤2⋅105 2\\le n\\le 2\\cdot 10^5 2≤n≤2⋅105 , 2≤m≤min⁡(2⋅105,n(n−1)) 2\\le m\\le \\min(2\\cdot 10^5,n(n-1) ) 2≤m≤min(2⋅105,n(n−1)) , 1≤k≤9 1\\le k\\le 9 1≤k≤9 ). Each of the next m m m lines contains three integers u u u , v v v and w w w (1≤u,v≤n,u≠v,1≤w≤m) (1\\le u,v\\le n,u\\ne v,1\\le w\\le m) (1≤u,v≤n,u=v,1≤w≤m) , denoting an edge from u u u to v v v with weight w w w . It is guaranteed that there are no self-loops or multiple edges and each vertex has at least one edge starting from itself. It is guaranteed that the out-degree of each vertex is at most k k k and no two edges have equal weight. 输出格式: Print one integer: the number of tuples. 样例: 样例输入 1: 4 6 3 4 2 1 1 2 2 2 4 3 4 1 4 4 3 5 3 1 6 样例输出 1: 2 样例输入 2: 5 5 1 1 4 1 5 1 2 2 5 3 4 3 4 3 2 5 样例输出 2: 1 样例输入 3: 6 13 4 3 5 1 2 5 2 6 3 3 1 4 4 2 6 5 5 3 6 4 1 7 4 3 8 5 2 9 4 2 10 2 1 11 6 1 12 4 6 13 样例输出 3: 1 思路: 实现: #include \u003cbits/stdc++.h\u003e using namespace std; #define Set(a) memset(a, 0, sizeof(a)) #define F(i, a, b) for (register int i = a, i##end = b; i \u003c= i##end; ++i) #define UF(i, a, b) for (register int i = a, i##end = b; i \u003e= i##end; --i) #define openf(a) \\ freopen(#a \".in\", \"r\", stdin); \\ freopen(#a \".out\", \"w\", stdout) #define re register #define ri re int #define il inline typedef long long ll; typedef unsigned long long ull; template \u003ctypename T\u003e inline T rd(T \u0026x) { T f = 1; x = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) if (c == '-') f = -1; for (; isdigit(c); c = getchar()) x = (x \u003c\u003c 3) + (x \u003c\u003c 1) + (T)(c - '0'); x *= f; return x; } ll rd() { ll x; rd(x); return x; } const int inf = 1 \u003c\u003c 30; ll ok[50]; ll rem = 0; int change[10][10], x[50], y[50]; const int N = 200005; ll a[N]; int u[N], v[N], w[N]; vector\u003cpair\u003cint, int\u003e\u003e to[N]; int ans = 0, n, m, k; int chs[10]; void dfs(int pos) { if (pos \u003e k) { ++ans; //F(i,1,k) printf(\"%d \",chs[i]);puts(\"\"); return; } ll tmp = rem; F(i, 1, pos) { rem = tmp; if ((rem \u003e\u003e change[pos][i]) \u0026 1) continue; chs[pos] = i; rem |= ok[change[pos][i]]; dfs(pos + 1); } } vector\u003cint\u003e from[N]; int main() { F(i, 1, 9) F(j, 1, i) change[i][j] = i * (i - 1) / 2 + j, x[i * (i - 1) / 2 + j] = i, y[i * (i - 1) / 2 + j] = j; n = rd(); m = rd(); k = rd(); F(i, 1, m) { rd(u[i]); rd(v[i]); rd(w[i]); to[u[i]].push_back(make_pair(w[i], i)); } F(i, 1, n) sort(to[i].begin(), to[i].end()); //F(i,1,n) {printf(\"%d:\",i);F(j,0,to[i].size()-1) printf(\"%d \",v[to[i][j].second]);puts(\"\");} F(i, 1, n) F(j, 0, to[i].size() - 1) a[v[to[i][j].second]] |= (1ll \u003c\u003c change[to[i].size()][j + 1]), from[v[to[i][j].second]].push_back(change[to[i].size()][j + 1]); F(i, 1, n) sort(from[i].begin(), from[i].end()); F(i, 1, n) F(j, 1, (int)from[i].size() - 1) if (from[i][j - 1] == from[i][j]) rem |= 1ll \u003c\u003c from[i][j]; F(i, 1, n) F(j, 1, 45) if ((a[i] \u003e\u003e j) \u0026 1) ok[j] |= (a[i] ^ (1ll \u003c\u003c j)); dfs(1); printf(\"%d\\n\", ans); return 0; } ","date":"2020-08-13","objectID":"/posts/oi/problems/cf1394b/:0:0","series":null,"tags":["Notebooks/OI/OJ/Luogu"],"title":"CF1394B-Boboniu Walks on Graph","uri":"/posts/oi/problems/cf1394b/#"},{"categories":null,"content":"CF1394C-Boboniu and String 题目: 题目描述: Boboniu defines BN-string as a string s s s of characters ‘B’ and ‘N’. You can perform the following operations on the BN-string s s s : Remove a character of s s s . Remove a substring “BN” or “NB” of s s s . Add a character ‘B’ or ‘N’ to the end of s s s . Add a string “BN” or “NB” to the end of s s s . Note that a string a a a is a substring of a string b b b if a a a can be obtained from b b b by deletion of several (possibly, zero or all) characters from the beginning and several (possibly, zero or all) characters from the end. Boboniu thinks that BN-strings s s s and t t t are similar if and only if: ∣s∣=∣t∣ |s|=|t| ∣s∣=∣t∣ . There exists a permutation p1,p2,…,p∣s∣ p_1, p_2, \\ldots, p_{|s|} p1​,p2​,…,p∣s∣​ such that for all i i i ( 1≤i≤∣s∣ 1\\le i\\le |s| 1≤i≤∣s∣ ), spi=ti s_{p_i}=t_i spi​​=ti​ . Boboniu also defines dist(s,t) \\text{dist}(s,t) dist(s,t) , the distance between s s s and t t t , as the minimum number of operations that makes s s s similar to t t t . Now Boboniu gives you n n n non-empty BN-strings s1,s2,…,sn s_1,s_2,\\ldots, s_n s1​,s2​,…,sn​ and asks you to find a non-empty BN-string t t t such that the maximum distance to string s s s is minimized, i.e. you need to minimize max⁡i=1ndist(si,t) \\max_{i=1}^n \\text{dist}(s_i,t) maxi=1n​dist(si​,t) . 输入格式: The first line contains a single integer n n n ( 1≤n≤3⋅105 1\\le n\\le 3\\cdot 10^5 1≤n≤3⋅105 ). Each of the next n n n lines contains a string si s_i si​ ( 1≤∣si∣≤5⋅105 1\\le |s_i| \\le 5\\cdot 10^5 1≤∣si​∣≤5⋅105 ). It is guaranteed that si s_i si​ only contains ‘B’ and ‘N’. The sum of ∣si∣ |s_i| ∣si​∣ does not exceed 5⋅105 5\\cdot 10^5 5⋅105 . 输出格式: In the first line, print the minimum max⁡i=1ndist(si,t) \\max_{i=1}^n \\text{dist}(s_i,t) maxi=1n​dist(si​,t) . In the second line, print the suitable t t t . If there are several possible t t t ’s, you can print any. 样例: 样例输入 1: 3 B N BN 样例输出 1: 1 BN 样例输入 2: 10 N BBBBBB BNNNBBNBB NNNNBNBNNBNNNBBN NBNBN NNNNNN BNBNBNBBBBNNNNBBBBNNBBNBNBBNBBBBBBBB NNNNBN NBBBBBBBB NNNNNN 样例输出 2: 12 BBBBBBBBBBBBNNNNNNNNNNNN 样例输入 3: 8 NNN NNN BBNNBBBN NNNBNN B NNN NNNNBNN NNNNNNNNNNNNNNNBNNNNNNNBNB 样例输出 3: 12 BBBBNNNNNNNNNNNN 样例输入 4: 3 BNNNBNNNNBNBBNNNBBNNNNBBBBNNBBBBBBNBBBBBNBBBNNBBBNBNBBBN BBBNBBBBNNNNNBBNBBBNNNBB BBBBBBBBBBBBBBNBBBBBNBBBBBNBBBBNB 样例输出 4: 12 BBBBBBBBBBBBBBBBBBBBBBBBBBNNNNNNNNNNNN 思路: 实现: #include \u003cbits/stdc++.h\u003e using namespace std; #ifndef use_ios11 #define use_ios11 using namespace std; struct ins { int ans; ins() { ans = 1; } #define endl '\\n' void read() { } void read1(char \u0026s) { char c = getchar(); for (; !isprint(c) || c == ' ' || c == '\\n' || c == '\\t'; c = getchar()) ; s = c; if (c == EOF) ans = 0; } void read1(string \u0026s) { s = \"\"; char c = getchar(); for (; !isprint(c) || c == ' ' || c == '\\n' || c == '\\t'; c = getchar()) ; for (; isprint(c) \u0026\u0026 c != ' ' \u0026\u0026 c != '\\n' \u0026\u0026 c != '\\t'; c = getchar()) s += c; if (c == EOF) ans = 0; } template \u003ctypename T\u003e void read1(T \u0026n) { T x = 0; int f = 1; char c = getchar(); for (; !isdigit(c); c = getchar()) { if (c == '-') f = -1; if (c == EOF) { ans = 0; return; } } for (; isdigit(c); c = getchar()) x = x * 10 + c - 48; n = x * f; if (c == EOF) ans = 0; if (c != '.') return; T l = 0.1; while ((c = getchar()) \u003c= '9' \u0026\u0026 c \u003e= '0') x = x + (c \u0026 15) * l, l *= 0.1; n = x * f; if (c == EOF) ans = 0; } void write() {} void write1(string s) { int n = s.size(); for (int i = 0; i \u003c n; i++) putchar(s[i]); } void write1(const char *s) { int n = strlen(s); for (int i = 0; i \u003c n; i++) putchar(s[i]); } void write1(char s) { putchar(s); } void write1(float s, int x = 6) { char y[10001]; sprintf(y, \"%%.%df\", x); printf(y, s); } void write1(double s, int x = 6) { char y[10001]; sprintf(y, \"%%.%dlf\", x); printf(y, s); } void write1(long double s, int x = 6) { char y[10001]; sprintf(y, \"%%.%dLf\", x); printf(y, s); } template \u003ctypename T\u003e void write1(T n) { if (n \u003c 0) n = -n, putchar('-'); if (n \u003e 9) write1(n / 10); putchar('0' + n % 10); } template \u003ctypename T\u003e fr","date":"2020-08-13","objectID":"/posts/oi/problems/cf1394c/:0:0","series":null,"tags":["Notebooks/OI/OJ/Luogu"],"title":"CF1394C-Boboniu and String","uri":"/posts/oi/problems/cf1394c/#"},{"categories":null,"content":"CF1394A-Boboniu Chats with Du 题目: 题目描述: Have you ever used the chat application QQ? Well, in a chat group of QQ, administrators can muzzle a user for days. In Boboniu’s chat group, there’s a person called Du Yi who likes to make fun of Boboniu every day. Du will chat in the group for n n n days. On the i i i -th day: If Du can speak, he’ll make fun of Boboniu with fun factor ai a_i ai​ . But after that, he may be muzzled depending on Boboniu’s mood. Otherwise, Du won’t do anything. Boboniu’s mood is a constant m m m . On the i i i -th day: If Du can speak and ai\u003em a_i\u003em ai​\u003em , then Boboniu will be angry and muzzle him for d d d days, which means that Du won’t be able to speak on the i+1,i+2,⋯ ,min⁡(i+d,n) i+1, i+2, \\cdots, \\min(i+d,n) i+1,i+2,⋯,min(i+d,n) -th days. Otherwise, Boboniu won’t do anything. The total fun factor is the sum of the fun factors on the days when Du can speak. Du asked you to find the maximum total fun factor among all possible permutations of a a a . 输入格式: The first line contains three integers n n n , d d d and m m m ( 1≤d≤n≤105,0≤m≤109 1\\le d\\le n\\le 10^5,0\\le m\\le 10^9 1≤d≤n≤105,0≤m≤109 ). The next line contains n n n integers a1,a2,…,an a_1, a_2, \\ldots,a_n a1​,a2​,…,an​ ( 0≤ai≤109 0\\le a_i\\le 10^9 0≤ai​≤109 ). 输出格式: Print one integer: the maximum total fun factor among all permutations of a a a . 样例: 样例输入 1: 5 2 11 8 10 15 23 5 样例输出 1: 48 样例输入 2: 20 2 16 20 5 8 2 18 16 2 16 16 1 5 16 2 13 6 16 4 17 21 7 样例输出 2: 195 思路: 实现: #include \u003cbits/stdc++.h\u003e using namespace std; const int maxn = 2e5 + 10; long long a[maxn]; int n, d, m; int tot1, tot2; long long c[maxn], b[maxn]; long long sum[maxn \u003c\u003c 1], ans; priority_queue\u003cpair\u003clong long, long long\u003e\u003e q; int main() { cin \u003e\u003e n \u003e\u003e d \u003e\u003e m; for (int i = 1; i \u003c= n; i++) { cin \u003e\u003e a[i]; if (a[i] \u003c= m) ans += a[i], b[++tot1] = a[i]; else c[++tot2] = a[i]; } sort(b + 1, b + tot1 + 1); sort(c + 1, c + tot2 + 1); for (int i = 1; i \u003c= tot1; i++) { q.push(make_pair(-b[i], i)); } for (int i = 1; i \u003c= tot2; i++) q.push(make_pair(0, i)); ans += c[tot2]; q.pop(); for (int i = tot2 - 1; i \u003e= 1; i--) { if (q.size() \u003c d + 1) break; long long x = 0; for (int j = 1; j \u003c= d + 1; j++) x += q.top().first, q.pop(); // cout \u003c\u003c c[i] \u003c\u003c \" \" \u003c\u003c x \u003c\u003c endl; if (c[i] \u003e -x) ans += c[i] + x; } cout \u003c\u003c ans \u003c\u003c endl; return 0; } ","date":"2020-08-13","objectID":"/posts/oi/problems/cf1394a/:0:0","series":null,"tags":["Notebooks/OI/OJ/Luogu"],"title":"CF1394A-Boboniu Chats with Du","uri":"/posts/oi/problems/cf1394a/#"},{"categories":null,"content":"CF1395C-Boboniu and Bit Operations 题目: 题目描述: Boboniu likes bit operations. He wants to play a game with you. Boboniu gives you two sequences of non-negative integers a1,a2,…,an a_1,a_2,\\ldots,a_n a1​,a2​,…,an​ and b1,b2,…,bm b_1,b_2,\\ldots,b_m b1​,b2​,…,bm​ . For each i i i ( 1≤i≤n 1\\le i\\le n 1≤i≤n ), you’re asked to choose a j j j ( 1≤j≤m 1\\le j\\le m 1≤j≤m ) and let ci=ai\u0026bj c_i=a_i\\\u0026 b_j ci​=ai​\u0026bj​ , where \u0026 \\\u0026 \u0026 denotes the bitwise AND operation. Note that you can pick the same j j j for different i i i ’s. Find the minimum possible c1∣c2∣…∣cn c_1 | c_2 | \\ldots | c_n c1​∣c2​∣…∣cn​ , where ∣ | ∣ denotes the bitwise OR operation. 输入格式: The first line contains two integers n n n and m m m ( 1≤n,m≤200 1\\le n,m\\le 200 1≤n,m≤200 ). The next line contains n n n integers a1,a2,…,an a_1,a_2,\\ldots,a_n a1​,a2​,…,an​ ( 0≤ai\u003c29 0\\le a_i \u003c 2^9 0≤ai​\u003c29 ). The next line contains m m m integers b1,b2,…,bm b_1,b_2,\\ldots,b_m b1​,b2​,…,bm​ ( 0≤bi\u003c29 0\\le b_i \u003c 2^9 0≤bi​\u003c29 ). 输出格式: Print one integer: the minimum possible c1∣c2∣…∣cn c_1 | c_2 | \\ldots | c_n c1​∣c2​∣…∣cn​ . 样例: 样例输入 1: 4 2 2 6 4 0 2 4 样例输出 1: 2 样例输入 2: 7 6 1 9 1 9 8 1 0 1 1 4 5 1 4 样例输出 2: 0 样例输入 3: 8 5 179 261 432 162 82 43 10 38 379 357 202 184 197 样例输出 3: 147 思路: 实现: #include \u003cbits/stdc++.h\u003e using namespace std; int a[1001]; int b[1001]; int n, m; int main() { cin \u003e\u003e n \u003e\u003e m; for (int i = 1; i \u003c= n; i++) cin \u003e\u003e a[i]; for (int i = 1; i \u003c= m; i++) cin \u003e\u003e b[i]; int ans1 = (1 \u003c\u003c 9) - 1, ans2 = 0; for (int i = 8; i \u003e= 0; i--) { for (int j = 1; j \u003c= n; j++) { int ans = 1; for (int k = 1; k \u003c= m; k++) { if ((a[j] \u0026 b[k] \u0026 (ans1)) \u003e\u003e i == 0) { ans = 0; break; } } if (ans == 1) { ans1 = ans1 ^ (1 \u003c\u003c i); ans2 = ans2 | (1 \u003c\u003c i); } } } cout \u003c\u003c ans2 \u003c\u003c endl; } ","date":"2020-08-13","objectID":"/posts/oi/problems/cf1395c/:0:0","series":null,"tags":["Notebooks/OI/OJ/Luogu"],"title":"CF1395C-Boboniu and Bit Operations","uri":"/posts/oi/problems/cf1395c/#"},{"categories":null,"content":"CF1395B-Boboniu Plays Chess 题目: 题目描述: Boboniu likes playing chess with his employees. As we know, no employee can beat the boss in the chess game, so Boboniu has never lost in any round. You are a new applicant for his company. Boboniu will test you with the following chess question: Consider a n×m n\\times m n×m grid (rows are numbered from 1 1 1 to n n n , and columns are numbered from 1 1 1 to m m m ). You have a chess piece, and it stands at some cell (Sx,Sy) (S_x,S_y) (Sx​,Sy​) which is not on the border (i.e. 2≤Sx≤n−1 2 \\le S_x \\le n-1 2≤Sx​≤n−1 and 2≤Sy≤m−1 2 \\le S_y \\le m-1 2≤Sy​≤m−1 ). From the cell (x,y) (x,y) (x,y) , you can move your chess piece to (x,y′) (x,y') (x,y′) ( 1≤y′≤m,y′≠y 1\\le y'\\le m, y' \\neq y 1≤y′≤m,y′=y ) or (x′,y) (x',y) (x′,y) ( 1≤x′≤n,x′≠x 1\\le x'\\le n, x'\\neq x 1≤x′≤n,x′=x ). In other words, the chess piece moves as a rook. From the cell, you can move to any cell on the same row or column. Your goal is to visit each cell exactly once. Can you find a solution? Note that cells on the path between two adjacent cells in your route are not counted as visited, and it is not required to return to the starting point. 输入格式: The only line of the input contains four integers n n n , m m m , Sx S_x Sx​ and Sy S_y Sy​ ( 3≤n,m≤100 3\\le n,m\\le 100 3≤n,m≤100 , 2≤Sx≤n−1 2 \\le S_x \\le n-1 2≤Sx​≤n−1 , 2≤Sy≤m−1 2 \\le S_y \\le m-1 2≤Sy​≤m−1 ) — the number of rows, the number of columns, and the initial position of your chess piece, respectively. 输出格式: You should print n⋅m n\\cdot m n⋅m lines. The i i i -th line should contain two integers xi x_i xi​ and yi y_i yi​ ( 1≤xi≤n 1 \\leq x_i \\leq n 1≤xi​≤n , 1≤yi≤m 1 \\leq y_i \\leq m 1≤yi​≤m ), denoting the i i i -th cell that you visited. You should print exactly nm nm nm pairs (xi,yi) (x_i, y_i) (xi​,yi​) , they should cover all possible pairs (xi,yi) (x_i, y_i) (xi​,yi​) , such that 1≤xi≤n 1 \\leq x_i \\leq n 1≤xi​≤n , 1≤yi≤m 1 \\leq y_i \\leq m 1≤yi​≤m . We can show that under these constraints there always exists a solution. If there are multiple answers, print any. 样例: 样例输入 1: 3 3 2 2 样例输出 1: 2 2 1 2 1 3 2 3 3 3 3 2 3 1 2 1 1 1 样例输入 2: 3 4 2 2 样例输出 2: 2 2 2 1 2 3 2 4 1 4 3 4 3 3 3 2 3 1 1 1 1 2 1 3 思路: 实现: #include \u003cbits/stdc++.h\u003e using namespace std; int main() { int n, m, a, b; cin \u003e\u003e n \u003e\u003e m \u003e\u003e a \u003e\u003e b; for (int i = a; i \u003e= 1; i--) cout \u003c\u003c i \u003c\u003c \" \" \u003c\u003c b \u003c\u003c endl; for (int i = a + 1; i \u003c= n; i++) cout \u003c\u003c i \u003c\u003c \" \" \u003c\u003c b \u003c\u003c endl; // return 0; int kk = n; for (int i = b + 1; i \u003c= m; i++) { if (kk == n) { for (int j = n; j \u003e= 1; j--) { cout \u003c\u003c j \u003c\u003c \" \" \u003c\u003c i \u003c\u003c endl; // cout \u003c\u003c j \u003c\u003c endl; } } else { for (int j = 1; j \u003c= n; j++) { cout \u003c\u003c j \u003c\u003c ' ' \u003c\u003c i \u003c\u003c endl; // cout \u003c\u003c j \u003c\u003c endl; } } if (kk == n) kk = 1; else kk = n; } for (int i = b - 1; i \u003e= 1; i--) { if (kk == n) { for (int j = kk; j \u003e= 1; j--) { cout \u003c\u003c j \u003c\u003c \" \" \u003c\u003c i \u003c\u003c endl; } } else { for (int j = 1; j \u003c= n; j++) { cout \u003c\u003c j \u003c\u003c ' ' \u003c\u003c i \u003c\u003c endl; } } if (kk == n) kk = 1; else kk = n; } } ","date":"2020-08-13","objectID":"/posts/oi/problems/cf1395b/:0:0","series":null,"tags":["Notebooks/OI/OJ/Luogu"],"title":"CF1395B-Boboniu Plays Chess","uri":"/posts/oi/problems/cf1395b/#"},{"categories":null,"content":"CF1395A-Boboniu Likes to Color Balls 题目: 题目描述: Boboniu gives you r r r red balls, g g g green balls, b b b blue balls, w w w white balls. He allows you to do the following operation as many times as you want: Pick a red ball, a green ball, and a blue ball and then change their color to white. You should answer if it’s possible to arrange all the balls into a palindrome after several (possibly zero) number of described operations. 输入格式: The first line contains one integer T T T ( 1≤T≤100 1\\le T\\le 100 1≤T≤100 ) denoting the number of test cases. For each of the next T T T cases, the first line contains four integers r r r , g g g , b b b and w w w ( 0≤r,g,b,w≤109 0\\le r,g,b,w\\le 10^9 0≤r,g,b,w≤109 ). 输出格式: For each test case, print “Yes” if it’s possible to arrange all the balls into a palindrome after doing several (possibly zero) number of described operations. Otherwise, print “No”. 样例: 样例输入 1: 4 0 1 1 1 8 1 9 3 0 0 0 0 1000000000 1000000000 1000000000 1000000000 样例输出 1: No Yes Yes Yes 思路: 实现: #include \u003cbits/stdc++.h\u003e using namespace std; int main() { int n; cin \u003e\u003e n; while (n--) { int a, b, c, d; cin \u003e\u003e a \u003e\u003e b \u003e\u003e c \u003e\u003e d; if ((a \u0026 1) + (b \u0026 1) + (c \u0026 1) + (d \u0026 1) == 2) puts(\"No\"); else if (a == 0 || b == 0 || c == 0) { if ((a \u0026 1) + (b \u0026 1) + (c \u0026 1) + (d \u0026 1) == 3) puts(\"No\"); else puts(\"Yes\"); } else { puts(\"Yes\"); } } } ","date":"2020-08-13","objectID":"/posts/oi/problems/cf1395a/:0:0","series":null,"tags":["Notebooks/OI/OJ/Luogu"],"title":"CF1395A-Boboniu Likes to Color Balls","uri":"/posts/oi/problems/cf1395a/#"},{"categories":null,"content":"CF1299C-Water Balance 题目: 题目描述: There are n n n water tanks in a row, i i i -th of them contains ai a_i ai​ liters of water. The tanks are numbered from 1 1 1 to n n n from left to right. You can perform the following operation: choose some subsegment [l,r] [l, r] [l,r] ( 1≤l≤r≤n 1\\le l \\le r \\le n 1≤l≤r≤n ), and redistribute water in tanks l,l+1,…,r l, l+1, \\dots, r l,l+1,…,r evenly. In other words, replace each of al,al+1,…,ar a_l, a_{l+1}, \\dots, a_r al​,al+1​,…,ar​ by al+al+1+⋯+arr−l+1 \\frac{a_l + a_{l+1} + \\dots + a_r}{r-l+1} r−l+1al​+al+1​+⋯+ar​​ . For example, if for volumes [1,3,6,7] [1, 3, 6, 7] [1,3,6,7] you choose l=2,r=3 l = 2, r = 3 l=2,r=3 , new volumes of water will be [1,4.5,4.5,7] [1, 4.5, 4.5, 7] [1,4.5,4.5,7] . You can perform this operation any number of times. What is the lexicographically smallest sequence of volumes of water that you can achieve? As a reminder: A sequence a a a is lexicographically smaller than a sequence b b b of the same length if and only if the following holds: in the first (leftmost) position where a a a and b b b differ, the sequence a a a has a smaller element than the corresponding element in b b b . 输入格式: The first line contains an integer n n n ( 1≤n≤106 1 \\le n \\le 10^6 1≤n≤106 ) — the number of water tanks. The second line contains n n n integers a1,a2,…,an a_1, a_2, \\dots, a_n a1​,a2​,…,an​ ( 1≤ai≤106 1 \\le a_i \\le 10^6 1≤ai​≤106 ) — initial volumes of water in the water tanks, in liters. Because of large input, reading input as doubles is not recommended. 输出格式: Print the lexicographically smallest sequence you can get. In the i i i -th line print the final volume of water in the i i i -th tank. Your answer is considered correct if the absolute or relative error of each ai a_i ai​ does not exceed 10−9 10^{-9} 10−9 . Formally, let your answer be a1,a2,…,an a_1, a_2, \\dots, a_n a1​,a2​,…,an​ , and the jury’s answer be b1,b2,…,bn b_1, b_2, \\dots, b_n b1​,b2​,…,bn​ . Your answer is accepted if and only if ∣ai−bi∣max⁡(1,∣bi∣)≤10−9 \\frac{|a_i - b_i|}{\\max{(1, |b_i|)}} \\le 10^{-9} max(1,∣bi​∣)∣ai​−bi​∣​≤10−9 for each i i i . 样例: 样例输入 1: 4 7 5 5 7 样例输出 1: 5.666666667 5.666666667 5.666666667 7.000000000 样例输入 2: 5 7 8 8 10 12 样例输出 2: 7.000000000 8.000000000 8.000000000 10.000000000 12.000000000 样例输入 3: 10 3 9 5 5 1 7 5 3 8 7 样例输出 3: 3.000000000 5.000000000 5.000000000 5.000000000 5.000000000 5.000000000 5.000000000 5.000000000 7.500000000 7.500000000 思路: 实现: #include \"ybwhead/ios.h\" int l, r; const int maxn = 1e6 + 10; long long sum[maxn]; int q[maxn]; int main() { // int TTT; // yin \u003e\u003e TTT; // while (TTT--) { int n; yin \u003e\u003e n; for (int i = 1; i \u003c= n; i++) { int x; yin \u003e\u003e x; sum[i] = sum[i - 1] + x; } l = r = 0; for (int i = 1; i \u003c= n; i++) { while (l \u003c r \u0026\u0026 (sum[i] - sum[q[r]]) * (q[r] - q[r - 1]) \u003c= (sum[q[r]] - sum[q[r - 1]]) * (i - q[r])) r--; q[++r] = i; } for (int i = 1; i \u003c= r; i++) { double xx = (double)(sum[q[i]] - sum[q[i - 1]]) / (q[i] - q[i - 1]); for (int j = q[i - 1] + 1; j \u003c= q[i]; j++) printf(\"%.9lf\\n\", xx); } } return 0; } ","date":"2020-08-12","objectID":"/posts/oi/problems/cf1299c/:0:0","series":null,"tags":["Notebooks/OI/OJ/Luogu"],"title":"CF1299C-Water Balance","uri":"/posts/oi/problems/cf1299c/#"},{"categories":null,"content":"P4357-[CQOI2016]K 远点对 题目: 题目描述: 已知平面内 NNN 个点的坐标，求欧氏距离下的第 KKK 远点对。 两个点 P(x1,y1)P(x_1,y_1)P(x1​,y1​) 和 Q(x2,y2)Q(x_2,y_2)Q(x2​,y2​) 的欧氏距离定义为 (x1−x2)2+(y1−y2)2\\sqrt{(x_1-x_2)^2+(y_1-y_2)^2}(x1​−x2​)2+(y1​−y2​)2​ 输入格式: 输入文件第一行为用空格隔开的两个整数 N,KN,KN,K 。 接下来 NNN 行，每行两个整数 X,YX,YX,Y ，表示一个点的坐标。 输出格式: 输出文件第一行为一个整数，表示第 KKK 远点对的距离的平方（一定是个整数）。 样例: 样例输入 1: 10 5 0 0 0 1 1 0 1 1 2 0 2 1 1 2 0 2 3 0 3 1 样例输出 1: 9 思路: 实现: #include \"ybwhead/ios.h\" const int maxn = 1e5 + 10; struct node { int x, y; } a[maxn]; int opt; bool cmp(node a, node b) { if (opt) return a.y \u003c b.y; else return a.x \u003c b.x; } priority_queue\u003clong long, vector\u003clong long\u003e, greater\u003clong long\u003e\u003e q; struct Kd_tree { int root, cnt; struct nod { int ls, rs; node d; int mx[2], mi[2]; } x[maxn \u003c\u003c 2]; void build(int \u0026p, int l, int r) { if (l \u003e r) return; if (!p) p = ++cnt; int mid = l + r \u003e\u003e 1; nth_element(a + l, a + mid, a + r + 1, cmp); x[p].d = a[mid]; opt = !opt; build(x[p].ls, l, mid - 1); build(x[p].rs, mid + 1, r); x[p].mx[0] = x[p].mi[0] = x[p].d.x; x[p].mx[1] = x[p].mi[1] = x[p].d.y; if (x[p].ls) { x[p].mx[0] = max(x[p].mx[0], x[x[p].ls].mx[0]); x[p].mx[1] = max(x[p].mx[1], x[x[p].ls].mx[1]); x[p].mi[1] = min(x[p].mi[1], x[x[p].ls].mi[1]); x[p].mi[0] = min(x[p].mi[0], x[x[p].ls].mi[0]); } if (x[p].rs) { x[p].mx[0] = max(x[p].mx[0], x[x[p].rs].mx[0]); x[p].mx[1] = max(x[p].mx[1], x[x[p].rs].mx[1]); x[p].mi[1] = min(x[p].mi[1], x[x[p].rs].mi[1]); x[p].mi[0] = min(x[p].mi[0], x[x[p].rs].mi[0]); } opt = !opt; } void build(int l, int r) { build(root, l, r); } inline long long sqr(long long a) { return a * a; } inline long long dis(node a, node b) { return (sqr(a.x - b.x) + sqr(a.y - b.y)); } inline long long dis1(node a, int b) { return (sqr(max(abs(a.x - x[b].mi[0]), abs(a.x - x[b].mx[0]))) + sqr(max(abs(a.y - x[b].mi[1]), abs(a.y - x[b].mx[1])))); } #define inf LLONG_MAX / 10 void query(int p, node y) { long long dl = -inf, dr = -inf; if (x[p].ls) dl = dis1(y, x[p].ls); if (x[p].rs) dr = dis1(y, x[p].rs); long long di = dis(y, x[p].d); if (q.top() \u003c di) { q.pop(); q.push(di); } if (dl \u003e dr) { if (q.top() \u003c dl) query(x[p].ls, y); if (q.top() \u003c dr) query(x[p].rs, y); } else { if (q.top() \u003c dr) query(x[p].rs, y); if (q.top() \u003c dl) query(x[p].ls, y); } } } T; int n, k; int main() { yin \u003e\u003e n \u003e\u003e k; for (int i = 1; i \u003c= n; i++) yin \u003e\u003e a[i].x \u003e\u003e a[i].y; T.build(1, n); for (int i = 1; i \u003c= k \u003c\u003c 1; i++) q.push(0); for (int i = 1; i \u003c= n; i++) T.query(1, a[i]); yout \u003c\u003c q.top() \u003c\u003c endl; return 0; } ","date":"2020-08-12","objectID":"/posts/oi/problems/p4357/:0:0","series":null,"tags":[2016,"重庆","各省省选","K-D Tree","Notebooks/OI/OJ/Luogu"],"title":"P4357-[CQOI2016]K远点对","uri":"/posts/oi/problems/p4357/#"},{"categories":null,"content":"CF1389G-Directing Edges 题目: 题目描述: You are given an undirected connected graph consisting of n n n vertices and m m m edges. k k k vertices of this graph are special. You have to direct each edge of this graph or leave it undirected. If you leave the i i i -th edge undirected, you pay wi w_i wi​ coins, and if you direct it, you don’t have to pay for it. Let’s call a vertex saturated if it is reachable from each special vertex along the edges of the graph (if an edge is undirected, it can be traversed in both directions). After you direct the edges of the graph (possibly leaving some of them undirected), you receive ci c_i ci​ coins for each saturated vertex i i i . Thus, your total profit can be calculated as ∑i∈Sci−∑j∈Uwj \\sum \\limits_{i \\in S} c_i - \\sum \\limits_{j \\in U} w_j i∈S∑​ci​−j∈U∑​wj​ , where S S S is the set of saturated vertices, and U U U is the set of edges you leave undirected. For each vertex i i i , calculate the maximum possible profit you can get if you have to make the vertex i i i saturated. 输入格式: The first line contains three integers n n n , m m m and k k k ( 2≤n≤3⋅105 2 \\le n \\le 3 \\cdot 10^5 2≤n≤3⋅105 , n−1≤m≤min⁡(3⋅105,n(n−1)2) n - 1 \\le m \\le \\min(3 \\cdot 10^5, \\frac{n(n-1)}{2}) n−1≤m≤min(3⋅105,2n(n−1)​) , 1≤k≤n 1 \\le k \\le n 1≤k≤n ). The second line contains k k k pairwise distinct integers v1 v_1 v1​ , v2 v_2 v2​ , …, vk v_k vk​ ( 1≤vi≤n 1 \\le v_i \\le n 1≤vi​≤n ) — the indices of the special vertices. The third line contains n n n integers c1 c_1 c1​ , c2 c_2 c2​ , …, cn c_n cn​ ( 0≤ci≤109 0 \\le c_i \\le 10^9 0≤ci​≤109 ). The fourth line contains m m m integers w1 w_1 w1​ , w2 w_2 w2​ , …, wm w_m wm​ ( 0≤wi≤109 0 \\le w_i \\le 10^9 0≤wi​≤109 ). Then m m m lines follow, the i i i -th line contains two integers xi x_i xi​ and yi y_i yi​ ( 1≤xi,yi≤n 1 \\le x_i, y_i \\le n 1≤xi​,yi​≤n , xi≠yi x_i \\ne y_i xi​=yi​ ) — the endpoints of the i i i -th edge. There is at most one edge between each pair of vertices. 输出格式: Print n n n integers, where the i i i -th integer is the maximum profit you can get if you have to make the vertex i i i saturated. 样例: 样例输入 1: 3 2 2 1 3 11 1 5 10 10 1 2 2 3 样例输出 1: 11 2 5 样例输入 2: 4 4 4 1 2 3 4 1 5 7 8 100 100 100 100 1 2 2 3 3 4 1 4 样例输出 2: 21 21 21 21 思路: 实现: #include \"ybwhead/ios.h\" const int N = 300043; bool is_bridge[N]; int w[N]; int c[N]; int v[N]; vector\u003cpair\u003cint, int\u003e\u003e g[N]; vector\u003cpair\u003cint, int\u003e\u003e g2[N]; int comp[N]; long long sum[N]; long long dp[N]; int cnt[N]; int fup[N]; int tin[N]; int T = 0; long long ans[N]; int v1[N], v2[N]; int n, m, k; int dfs1(int x, int e) { tin[x] = T++; fup[x] = tin[x]; for (auto p : g[x]) { int y = p.first; int i = p.second; if (i == e) continue; if (tin[y] != -1) fup[x] = min(fup[x], tin[y]); else { fup[x] = min(fup[x], dfs1(y, i)); if (fup[y] \u003e tin[x]) is_bridge[i] = true; } } return fup[x]; } void dfs2(int x, int cc) { if (comp[x] != -1) return; comp[x] = cc; cnt[cc] += v[x]; sum[cc] += c[x]; for (auto y : g[x]) if (!is_bridge[y.second]) dfs2(y.first, cc); } void process_edge(int x, int y, int m, int weight) { long long add_dp = dp[y]; if (cnt[y] \u003e 0 \u0026\u0026 cnt[y] \u003c k) add_dp = max(0ll, add_dp - weight); cnt[x] += m * cnt[y]; dp[x] += m * add_dp; } void link(int x, int y, int weight) { process_edge(x, y, 1, weight); } void cut(int x, int y, int weight) { process_edge(x, y, -1, weight); } void dfs3(int x, int p) { dp[x] = sum[x]; for (auto e : g2[x]) { int i = e.second; int y = e.first; if (y == p) continue; dfs3(y, x); link(x, y, w[i]); } } void dfs4(int x, int p) { ans[x] = dp[x]; for (auto e : g2[x]) { int i = e.second; int y = e.first; if (y == p) continue; cut(x, y, w[i]); link(y, x, w[i]); dfs4(y, x); cut(y, x, w[i]); link(x, y, w[i]); } } int main() { yin \u003e\u003e n \u003e\u003e m \u003e\u003e k; for (int i = 0; i \u003c k; i++) { int x; yin \u003e\u003e x; --x; v[x] = 1; } for (int i = 0; i \u003c n; i++) yin \u003e\u003e c[i]; for (int i = 0; i \u003c m; i++) yin \u003e\u003e w[i]; for (int i = 0; i \u003c m; i++) { scanf(\"%d %d\", \u0026v1[i], \u0026v2[i]); --v1[i]; --v2[i]; g[v1[i]].push_back(make_pair(v2[i], i)); ","date":"2020-08-11","objectID":"/posts/oi/problems/cf1389g/:0:0","series":null,"tags":["Notebooks/OI/OJ/Luogu"],"title":"CF1389G-Directing Edges","uri":"/posts/oi/problems/cf1389g/#"},{"categories":null,"content":"CF1389F-Bicolored Segments 题目: 题目描述: You are given n n n segments [l1,r1],[l2,r2],…,[ln,rn] [l_1, r_1], [l_2, r_2], \\dots, [l_n, r_n] [l1​,r1​],[l2​,r2​],…,[ln​,rn​] . Each segment has one of two colors: the i i i -th segment’s color is ti t_i ti​ . Let’s call a pair of segments i i i and j j j bad if the following two conditions are met: ti≠tj t_i \\ne t_j ti​=tj​ ; the segments [li,ri] [l_i, r_i] [li​,ri​] and [lj,rj] [l_j, r_j] [lj​,rj​] intersect, embed or touch, i. e. there exists an integer x x x such that x∈[li,ri] x \\in [l_i, r_i] x∈[li​,ri​] and x∈[lj,rj] x \\in [l_j, r_j] x∈[lj​,rj​] . Calculate the maximum number of segments that can be selected from the given ones, so that there is no bad pair among the selected ones. 输入格式: The first line contains a single integer n n n ( 1≤n≤2⋅105 1 \\le n \\le 2 \\cdot 10^5 1≤n≤2⋅105 ) — number of segments. The next n n n lines contains three integers li,ri,ti l_i, r_i, t_i li​,ri​,ti​ ( 1≤li≤ri≤109;ti∈{1,2} 1 \\le l_i \\le r_i \\le 10^9; t_i \\in \\{1, 2\\} 1≤li​≤ri​≤109;ti​∈{1,2} ) — description of the i i i -th segment. 输出格式: Print the maximum number of segments that can be selected, so that there is no bad pair among the selected segments. 样例: 样例输入 1: 3 1 3 1 4 6 2 2 5 1 样例输出 1: 2 样例输入 2: 5 5 8 1 1 3 2 3 4 2 6 6 1 2 10 2 样例输出 2: 4 样例输入 3: 7 19 20 1 13 15 2 6 11 2 4 10 1 14 17 1 13 13 2 5 9 1 样例输出 3: 5 思路: 实现: #include \"ybwhead/ios.h\" int n; const int maxn = 3e5 + 10; int l[maxn], r[maxn], t[maxn]; vector\u003cpair\u003cint, pair\u003cint, int\u003e\u003e\u003e a; set\u003cpair\u003cint, int\u003e\u003e s[2]; int main() { yin \u003e\u003e n; for (int i = 1; i \u003c= n; i++) { yin \u003e\u003e l[i] \u003e\u003e r[i] \u003e\u003e t[i]; --t[i]; a.push_back(make_pair(l[i], make_pair(0, i))); a.push_back(make_pair(r[i], make_pair(1, i))); } sort(a.begin(), a.end()); int ans = 0; for (auto x : a) { int i = x.second.second; if (x.second.first) { int j = t[i]; int k = j ^ 1; // cout \u003c\u003c s[j].size() \u003c\u003c \" \" \u003c\u003c k \u003c\u003c endl; if (s[j].erase(make_pair(r[i], i)) \u0026\u0026 !s[k].empty()) { // cout \u003c\u003c i \u003c\u003c endl; ++ans; s[k].erase(s[k].begin()); } } else { s[t[i]].insert(make_pair(r[i], i)); } // puts(\"!!!\"); } yout \u003c\u003c n - ans \u003c\u003c endl; return 0; } ","date":"2020-08-11","objectID":"/posts/oi/problems/cf1389f/:0:0","series":null,"tags":["Notebooks/OI/OJ/Luogu"],"title":"CF1389F-Bicolored Segments","uri":"/posts/oi/problems/cf1389f/#"},{"categories":null,"content":"CF1389D-Segment Intersections 题目: 题目描述: You are given two lists of segments [al1,ar1],[al2,ar2],…,[aln,arn] [al_1, ar_1], [al_2, ar_2], \\dots, [al_n, ar_n] [al1​,ar1​],[al2​,ar2​],…,[aln​,arn​] and [bl1,br1],[bl2,br2],…,[bln,brn] [bl_1, br_1], [bl_2, br_2], \\dots, [bl_n, br_n] [bl1​,br1​],[bl2​,br2​],…,[bln​,brn​] . Initially, all segments [ali,ari] [al_i, ar_i] [ali​,ari​] are equal to [l1,r1] [l_1, r_1] [l1​,r1​] and all segments [bli,bri] [bl_i, br_i] [bli​,bri​] are equal to [l2,r2] [l_2, r_2] [l2​,r2​] . In one step, you can choose one segment (either from the first or from the second list) and extend it by 1 1 1 . In other words, suppose you’ve chosen segment [x,y] [x, y] [x,y] then you can transform it either into [x−1,y] [x - 1, y] [x−1,y] or into [x,y+1] [x, y + 1] [x,y+1] . Let’s define a total intersection I I I as the sum of lengths of intersections of the corresponding pairs of segments, i.e. \\sum\\limits_{i=1}^{n}{\\text{intersection_length}([al_i, ar_i], [bl_i, br_i])} . Empty intersection has length 0 0 0 and length of a segment [x,y] [x, y] [x,y] is equal to y−x y - x y−x . What is the minimum number of steps you need to make I I I greater or equal to k k k ? 输入格式: The first line contains the single integer t t t ( 1≤t≤1000 1 \\le t \\le 1000 1≤t≤1000 ) — the number of test cases. The first line of each test case contains two integers n n n and k k k ( 1≤n≤2⋅105 1 \\le n \\le 2 \\cdot 10^5 1≤n≤2⋅105 ; 1≤k≤109 1 \\le k \\le 10^9 1≤k≤109 ) — the length of lists and the minimum required total intersection. The second line of each test case contains two integers l1 l_1 l1​ and r1 r_1 r1​ ( 1≤l1≤r1≤109 1 \\le l_1 \\le r_1 \\le 10^9 1≤l1​≤r1​≤109 ) — the segment all [ali,ari] [al_i, ar_i] [ali​,ari​] are equal to initially. The third line of each test case contains two integers l2 l_2 l2​ and r2 r_2 r2​ ( 1≤l2≤r2≤109 1 \\le l_2 \\le r_2 \\le 10^9 1≤l2​≤r2​≤109 ) — the segment all [bli,bri] [bl_i, br_i] [bli​,bri​] are equal to initially. It’s guaranteed that the sum of n n n doesn’t exceed 2⋅105 2 \\cdot 10^5 2⋅105 . 输出格式: Print t t t integers — one per test case. For each test case, print the minimum number of step you need to make I I I greater or equal to k k k . 样例: 样例输入 1: 3 3 5 1 2 3 4 2 1000000000 1 1 999999999 999999999 10 3 5 10 7 8 样例输出 1: 7 2000000000 0 思路: 实现: #include \"ybwhead/ios.h\" int main() { int TTT; yin \u003e\u003e TTT; while (TTT--) { long long n, k, l1, l2, r1, r2, ans; yin \u003e\u003e n \u003e\u003e k \u003e\u003e l1 \u003e\u003e r1 \u003e\u003e l2 \u003e\u003e r2; if (max(l1, l2) \u003c= min(r1, r2)) { k = max(0ll, k - n * (min(r1, r2) - max(l1, l2))); long long x = n * (abs(l1 - l2) + abs(r1 - r2)); ans = min(k, x) + max(0ll, k - x) * 2; } else { long long x = max(l1, l2) - min(r1, r2); ans = 1e18; for (int i = 1; i \u003c= n; i++) { long long sum = x * i; long long y = (max(r1, r2) - min(l1, l2)) * i; sum += min(k, y) + max(0ll, k - y) * 2; ans = min(ans, sum); } } yout \u003c\u003c ans \u003c\u003c endl; } return 0; } ","date":"2020-08-11","objectID":"/posts/oi/problems/cf1389d/:0:0","series":null,"tags":["Notebooks/OI/OJ/Luogu"],"title":"CF1389D-Segment Intersections","uri":"/posts/oi/problems/cf1389d/#"},{"categories":null,"content":"CF1389E-Calendar Ambiguity 题目: 题目描述: Berland year consists of m m m months with d d d days each. Months are numbered from 1 1 1 to m m m . Berland week consists of w w w days. The first day of the year is also the first day of the week. Note that the last week of the year might be shorter than w w w days. A pair (x,y) (x, y) (x,y) such that x\u003cy x \u003c y x\u003cy is ambiguous if day x x x of month y y y is the same day of the week as day y y y of month x x x . Count the number of ambiguous pairs. 输入格式: The first line contains a single integer t t t ( 1≤t≤1000 1 \\le t \\le 1000 1≤t≤1000 ) — the number of testcases. Each of the next t t t lines contains three integers m m m , d d d and w w w ( 1≤m,d,w≤109 1 \\le m, d, w \\le 10^9 1≤m,d,w≤109 ) — the number of months in a year, the number of days in a month and the number of days in a week. 输出格式: Print t t t integers — for each testcase output the number of pairs (x,y) (x, y) (x,y) such that x\u003cy x \u003c y x\u003cy and day x x x of month y y y is the same day of the week as day y y y of month x x x . 样例: 样例输入 1: 5 6 7 4 10 7 12 12 30 7 1 1 1 3247834 10298779 625324 样例输出 1: 6 9 5 0 116461800 思路: 实现: #include \"ybwhead/ios.h\" long long gcd(long long a, long long b) { if (!b) return a; return gcd(b, a % b); } int main() { int TTT; yin \u003e\u003e TTT; while (TTT--) { long long m, d, w; yin \u003e\u003e m \u003e\u003e d \u003e\u003e w; w /= gcd(d - 1, w); long long x = min(m, d); yout \u003c\u003c (x / w) * (x / w + 1) * (x % w) / 2 + (x / w) * (x / w - 1) * (w - x % w) / 2 \u003c\u003c endl; // cout \u003c\u003c x / w \u003c\u003c ' ' \u003c\u003c x / w - 1 \u003c\u003c \" \" \u003c\u003c x - x % w \u003c\u003c endl; } return 0; } ","date":"2020-08-11","objectID":"/posts/oi/problems/cf1389e/:0:0","series":null,"tags":["Notebooks/OI/OJ/Luogu"],"title":"CF1389E-Calendar Ambiguity","uri":"/posts/oi/problems/cf1389e/#"},{"categories":null,"content":"CF1389C-Good String 题目: 题目描述: Let’s call left cyclic shift of some string t1t2t3…tn−1tn t_1 t_2 t_3 \\dots t_{n - 1} t_n t1​t2​t3​…tn−1​tn​ as string t2t3…tn−1tnt1 t_2 t_3 \\dots t_{n - 1} t_n t_1 t2​t3​…tn−1​tn​t1​ . Analogically, let’s call right cyclic shift of string t t t as string tnt1t2t3…tn−1 t_n t_1 t_2 t_3 \\dots t_{n - 1} tn​t1​t2​t3​…tn−1​ . Let’s say string t t t is good if its left cyclic shift is equal to its right cyclic shift. You are given string s s s which consists of digits 0–9. What is the minimum number of characters you need to erase from s s s to make it good? 输入格式: The first line contains single integer t t t ( 1≤t≤1000 1 \\le t \\le 1000 1≤t≤1000 ) — the number of test cases. Next t t t lines contains test cases — one per line. The first and only line of each test case contains string s s s ( 2≤∣s∣≤2⋅105 2 \\le |s| \\le 2 \\cdot 10^5 2≤∣s∣≤2⋅105 ). Each character si s_i si​ is digit 0–9. It’s guaranteed that the total length of strings doesn’t exceed 2⋅105 2 \\cdot 10^5 2⋅105 . 输出格式: For each test case, print the minimum number of characters you need to erase from s s s to make it good. 样例: 样例输入 1: 3 95831 100120013 252525252525 样例输出 1: 3 5 0 思路: 实现: #include \"ybwhead/ios.h\" string s; const int maxn = 2e5 + 10; int dp[maxn][10][10]; int main() { int TTT; yin \u003e\u003e TTT; while (TTT--) { yin \u003e\u003e s; int n = s.size(); if (n \u003c= 2) { cout \u003c\u003c 0 \u003c\u003c endl; continue; } for (int i = 1; i \u003c= n; i++) { for (int j = 0; j \u003c= 9; j++) { for (int k = 0; k \u003c= 9; k++) { dp[i][j][k] = dp[i - 1][j][k]; if (s[i - 1] == j + '0') dp[i][j][k] = max(dp[i][j][k], dp[i - 1][k][j] + 1); } } } int ans = n; for (int i = 0; i \u003c= 9; i++) ans = min(ans, n - dp[n][i][i]); for (int i = 0; i \u003c= 9; i++) for (int j = 0; j \u003c= 9; j++) if (dp[n][i][j] % 2 == 0) ans = min(ans, n - dp[n][i][j]); cout \u003c\u003c ans \u003c\u003c endl; } return 0; } ","date":"2020-08-11","objectID":"/posts/oi/problems/cf1389c/:0:0","series":null,"tags":["Notebooks/OI/OJ/Luogu"],"title":"CF1389C-Good String","uri":"/posts/oi/problems/cf1389c/#"},{"categories":null,"content":"CF1389B-Array Walk 题目: 题目描述: You are given an array a1,a2,…,an a_1, a_2, \\dots, a_n a1​,a2​,…,an​ , consisting of n n n positive integers. Initially you are standing at index 1 1 1 and have a score equal to a1 a_1 a1​ . You can perform two kinds of moves: move right — go from your current index x x x to x+1 x+1 x+1 and add ax+1 a_{x+1} ax+1​ to your score. This move can only be performed if x\u003cn x\u003cn x\u003cn . move left — go from your current index x x x to x−1 x-1 x−1 and add ax−1 a_{x-1} ax−1​ to your score. This move can only be performed if x\u003e1 x\u003e1 x\u003e1 . Also, you can’t perform two or more moves to the left in a row. You want to perform exactly k k k moves. Also, there should be no more than z z z moves to the left among them. What is the maximum score you can achieve? 输入格式: The first line contains a single integer t t t ( 1≤t≤104 1 \\le t \\le 10^4 1≤t≤104 ) — the number of testcases. The first line of each testcase contains three integers n,k n, k n,k and z z z ( 2≤n≤105 2 \\le n \\le 10^5 2≤n≤105 , 1≤k≤n−1 1 \\le k \\le n - 1 1≤k≤n−1 , 0≤z≤min(5,k) 0 \\le z \\le min(5, k) 0≤z≤min(5,k) ) — the number of elements in the array, the total number of moves you should perform and the maximum number of moves to the left you can perform. The second line of each testcase contains n n n integers a1,a2,…,an a_1, a_2, \\dots, a_n a1​,a2​,…,an​ ( 1≤ai≤104 1 \\le a_i \\le 10^4 1≤ai​≤104 ) — the given array. The sum of n n n over all testcases does not exceed 3⋅105 3 \\cdot 10^5 3⋅105 . 输出格式: Print t t t integers — for each testcase output the maximum score you can achieve if you make exactly k k k moves in total, no more than z z z of them are to the left and there are no two or more moves to the left in a row. 样例: 样例输入 1: 4 5 4 0 1 5 4 3 2 5 4 1 1 5 4 3 2 5 4 4 10 20 30 40 50 10 7 3 4 6 8 2 9 9 7 4 10 9 样例输出 1: 15 19 150 56 思路: 实现: #include \"ybwhead/ios.h\" int TTT; int n, k, z; const int maxn = 1e5 + 10; int ans; int a[maxn]; int dp[maxn][10]; int main() { yin \u003e\u003e TTT; while (TTT--) { yin \u003e\u003e n \u003e\u003e k \u003e\u003e z; ++k; ans = 0; for (int i = 1; i \u003c= n; i++) { yin \u003e\u003e a[i]; } for (int i = 1; i \u003c= k; i++) { for (int j = 0; j \u003c= z; j++) { dp[i][j] = dp[i - 1][j] + a[i]; if (!j) ans = max(ans, dp[i][j]); if (j * 2 + i \u003c= k \u0026\u0026 j) { dp[i][j] = max(dp[i][j], dp[i][j - 1] + a[i] + a[i - 1]); ans = max(ans, dp[i][j]); } if (j * 2 + i - 1 == k \u0026\u0026 j) { // dp[i][j] = max(dp[i][j], dp[i][j - 1] + a[i - 1]); ans = max(ans, dp[i][j - 1] + a[i - 1]); } } } cout \u003c\u003c ans \u003c\u003c endl; } return 0; } ","date":"2020-08-11","objectID":"/posts/oi/problems/cf1389b/:0:0","series":null,"tags":["Notebooks/OI/OJ/Luogu"],"title":"CF1389B-Array Walk","uri":"/posts/oi/problems/cf1389b/#"},{"categories":null,"content":"CF1389A-LCM Problem 题目: 题目描述: Let LCM(x,y) LCM(x, y) LCM(x,y) be the minimum positive integer that is divisible by both x x x and y y y . For example, LCM(13,37)=481 LCM(13, 37) = 481 LCM(13,37)=481 , LCM(9,6)=18 LCM(9, 6) = 18 LCM(9,6)=18 . You are given two integers l l l and r r r . Find two integers x x x and y y y such that l≤x\u003cy≤r l \\le x \u003c y \\le r l≤x\u003cy≤r and l≤LCM(x,y)≤r l \\le LCM(x, y) \\le r l≤LCM(x,y)≤r . 输入格式: The first line contains one integer t t t ( 1≤t≤10000 1 \\le t \\le 10000 1≤t≤10000 ) — the number of test cases. Each test case is represented by one line containing two integers l l l and r r r ( 1≤l\u003cr≤109 1 \\le l \u003c r \\le 10^9 1≤l\u003cr≤109 ). 输出格式: For each test case, print two integers: if it is impossible to find integers x x x and y y y meeting the constraints in the statement, print two integers equal to −1 -1 −1 ; otherwise, print the values of x x x and y y y (if there are multiple valid answers, you may print any of them). 样例: 样例输入 1: 4 1 1337 13 69 2 4 88 89 样例输出 1: 6 7 14 21 2 4 -1 -1 思路: 实现: #include \"ybwhead/ios.h\" int main() { int TTT; yin \u003e\u003e TTT; while (TTT--) { int l, r; yin \u003e\u003e l \u003e\u003e r; if (r \u003c 2 * l) yout \u003c\u003c -1 \u003c\u003c ' ' \u003c\u003c -1 \u003c\u003c endl; else yout \u003c\u003c l \u003c\u003c ' ' \u003c\u003c 2 * l \u003c\u003c endl; } return 0; } ","date":"2020-08-11","objectID":"/posts/oi/problems/cf1389a/:0:0","series":null,"tags":["Notebooks/OI/OJ/Luogu"],"title":"CF1389A-LCM Problem","uri":"/posts/oi/problems/cf1389a/#"},{"categories":null,"content":"CF1179D-Fedor Runs for President 题目: 题目描述: Fedor runs for president of Byteland! In the debates, he will be asked how to solve Byteland’s transport problem. It’s a really hard problem because of Byteland’s transport system is now a tree (connected graph without cycles). Fedor’s team has found out in the ministry of transport of Byteland that there is money in the budget only for one additional road. In the debates, he is going to say that he will build this road as a way to maximize the number of distinct simple paths in the country. A simple path is a path which goes through every vertex no more than once. Two simple paths are named distinct if sets of their edges are distinct. But Byteland’s science is deteriorated, so Fedor’s team hasn’t succeeded to find any scientists to answer how many distinct simple paths they can achieve after adding exactly one edge on the transport system? Help Fedor to solve it. An edge can be added between vertices that are already connected, but it can’t be a loop. In this problem, we consider only simple paths of length at least two. 输入格式: The first line contains one integer n n n ( 2≤n≤500 000 2 \\leq n \\leq 500\\ 000 2≤n≤500 000 ) — number of vertices in Byteland’s transport system. Each of the following n−1 n - 1 n−1 lines contains two integers vi v_i vi​ and ui u_i ui​ ( 1≤vi,ui≤n 1 \\leq v_i, u_i \\leq n 1≤vi​,ui​≤n ). It’s guaranteed that the graph is tree. 输出格式: Print exactly one integer — a maximal number of simple paths that can be achieved after adding one edge. 样例: 样例输入 1: 2 1 2 样例输出 1: 2 样例输入 2: 4 1 2 1 3 1 4 样例输出 2: 11 样例输入 3: 6 1 2 1 3 3 4 3 5 4 6 样例输出 3: 29 思路: 这是一道斜率优化 dp 题，所以我们不用斜率优化做。/kk 首先我们肯定是先一条链加上一条边形成一个环。 将答案容斥变成n∗(n−1)−∑i=1Lsai×(sai−1)2n*(n-1)-\\sum\\limits_{i=1}^{L}\\frac{s_{a_i}\\times (s_{a_i}-1)}{2}n∗(n−1)−i=1∑L​2sai​​×(sai​​−1)​ 我们要让答案最大即最小化∑i=1Lsai×(sai−1)2\\sum\\limits_{i=1}^{L}\\frac{s_{a_i}\\times (s_{a_i}-1)}{2}i=1∑L​2sai​​×(sai​​−1)​ 之前有一位大佬在题解中提到了一个性质，即我们像求直径一样求就行了。但似乎没有给出证明。所以我自己YY了一个。 考虑两个点xxx,yyy 在以1为根dfs时xxx比yyy优，则不存在一个点zzz使得(y,z)(y,z)(y,z)是我们要找的那条连。 显然xxx,yyy是两个叶子节点。 令l=lca(x,y)l=lca(x,y)l=lca(x,y)，很显然 当zzz不在以lll为根的子树内时(x,z)(x,z)(x,z)比(y,z)(y,z)(y,z)要优。 当z在以lll为根的子树内时(x,y)(x,y)(x,y)比(y,z)(y,z)(y,z)更优。 所以不存在一个zzz使得(y,z)(y,z)(y,z)是最优解。 实现: #include \"ybwhead/ios.h\" int n; const int maxn = 5e5 + 10; struct edge { int v, nxt; } e[maxn \u003c\u003c 1]; int head[maxn], tot; void __ADD(int u, int v) { e[++tot].v = v; e[tot].nxt = head[u]; head[u] = tot; } void add(int u, int v) { __ADD(u, v); __ADD(v, u); } long long ans[maxn]; long long siz[maxn]; void pd(int u, int fa) { siz[u] = 1; for (int i = head[u]; i; i = e[i].nxt) { int v = e[i].v; if (v == fa) continue; pd(v, u); siz[u] += siz[v]; } } void dfs(int u, int fa) { for (int i = head[u]; i; i = e[i].nxt) { int v = e[i].v; if (v == fa) continue; ans[v] = ans[u] + 1ll * (siz[u] - siz[v]) * siz[v]; dfs(v, u); } } int main() { yin \u003e\u003e n; for (int i = 1; i \u003c n; i++) { int u, v; yin \u003e\u003e u \u003e\u003e v; add(u, v); } pd(1, 0); ans[1] = 1ll * n * (n - 1) / 2; dfs(1, 0); int an = 0; for (int i = 1; i \u003c= n; i++) if (ans[an] \u003c ans[i]) an = i; pd(an, 0); ans[an] = ans[1]; dfs(an, 0); an = 0; for (int i = 1; i \u003c= n; i++) if (ans[an] \u003c ans[i]) an = i; yout \u003c\u003c ans[an] \u003c\u003c endl; return 0; } ","date":"2020-08-10","objectID":"/posts/oi/problems/cf1179d/:0:0","series":null,"tags":["Notebooks/OI/OJ/Luogu"],"title":"CF1179D-Fedor Runs for President","uri":"/posts/oi/problems/cf1179d/#"},{"categories":null,"content":"CF1388E-Uncle Bogdan and Projections 题目: 题目描述: After returning to shore, uncle Bogdan usually visits the computer club “The Rock”, to solve tasks in a pleasant company. One day, uncle Bogdan met his good old friend who told him one unusual task… There are n n n non-intersecting horizontal segments with ends in integers points on the plane with the standard cartesian coordinate system. All segments are strictly above the OX OX OX axis. You can choose an arbitrary vector ( a a a , b b b ), where b\u003c0 b \u003c 0 b\u003c0 and coordinates are real numbers, and project all segments to OX OX OX axis along this vector. The projections shouldn’t intersect but may touch each other. Find the minimum possible difference between x x x coordinate of the right end of the rightmost projection and x x x coordinate of the left end of the leftmost projection. 输入格式: The first line contains the single integer n n n ( 1≤n≤2000 1 \\le n \\le 2000 1≤n≤2000 ) — the number of segments. The i i i -th of the next n n n lines contains three integers xli xl_i xli​ , xri xr_i xri​ and yi y_i yi​ ( −106≤xli\u003cxri≤106 -10^6 \\le xl_i \u003c xr_i \\le 10^6 −106≤xli​\u003cxri​≤106 ; 1≤yi≤106 1 \\le y_i \\le 10^6 1≤yi​≤106 ) — coordinates of the corresponding segment. It’s guaranteed that the segments don’t intersect or touch. 输出格式: Print the minimum possible difference you can get. Your answer will be considered correct if its absolute or relative error doesn’t exceed 10−6 10^{-6} 10−6 . Formally, if your answer is a a a and jury’s answer is b b b then your answer will be considered correct if ∣a−b∣max⁡(1,∣b∣)≤10−6 \\frac{|a - b|}{\\max{(1, |b|)}} \\le 10^{-6} max(1,∣b∣)∣a−b∣​≤10−6 . 样例: 样例输入 1: 3 1 6 2 4 6 4 4 6 6 样例输出 1: 9.000000000 样例输入 2: 3 2 5 1 4 6 4 7 8 2 样例输出 2: 6.333333333 样例输入 3: 2 1 3 1 4 7 1 样例输出 3: 6.000000000 思路: 实现: #include \"ybwhead/ios.h\" #define pb push_back #define x first #define y second using namespace std; const int N = 1e5 + 10; const double eps = 1e-9; double xl[N], xr[N], y[N], pi = acos(-1), mn_x, mx_x; int ind_l, ind_r; double point_pr(double x, double y, double ctg) { return x - y * ctg; } int main() { int n; vector\u003cpair\u003cdouble, int\u003e\u003e q; vector\u003cpair\u003cdouble, pair\u003cint, int\u003e\u003e\u003e events, prom_left, prom_right; yin \u003e\u003e n; pair\u003cdouble, double\u003e mx, mn; mx = {-1.0, -1.0}; mn = {2e9, 2e9}; mn_x = 2e9; mx_x = -2e9; for (int i = 0; i \u003c n; ++i) { yin \u003e\u003e xl[i] \u003e\u003e xr[i] \u003e\u003e y[i]; if (xl[i] \u003c mn_x) { mn_x = xl[i]; } if (xr[i] \u003e mx_x) { mx_x = xr[i]; } if (mx.y \u003c y[i]) { mx.y = y[i]; mx.x = xl[i]; ind_l = i; } else if (mx.y == y[i] \u0026\u0026 mx.x \u003e xl[i]) { mx.y = y[i]; mx.x = xl[i]; ind_l = i; } if (mn.y \u003e y[i]) { mn.y = y[i]; mn.x = xl[i]; ind_r = i; } else if (mn.y == y[i] \u0026\u0026 mn.x \u003c xl[i]) { mn.y = y[i]; mn.x = xl[i]; ind_r = i; } } double a1, a2; for (int i = 0; i \u003c n; ++i) { for (int j = 0; j \u003c n; ++j) { if (y[i] \u003e y[j]) { a1 = (xr[i] - xl[j]) / (y[i] - y[j]); a2 = (xl[i] - xr[j]) / (y[i] - y[j]); q.pb({a1, 1}); q.pb({a2, 2}); a1 = (xl[i] - xl[j]) / (y[i] - y[j]); a2 = (xr[i] - xr[j]) / (y[i] - y[j]); events.pb({a1, {i, j}}); events.pb({a2, {-i - 1, j}}); } } } if (q.empty()) { yout \u003c\u003c mx_x - mn_x \u003c\u003c endl; return 0; } sort(q.rbegin(), q.rend()); int cnt = 0; double last = 0; for (auto i : q) { if (i.y == 2) { --cnt; if (!cnt) { events.pb({i.x, {-1e9, -1e9}}); } } else { if (!cnt) { events.pb({i.x, {-1e9, -1e9}}); } ++cnt; } } sort(events.rbegin(), events.rend()); double ans = 1e18, ang; last = -1e18; for (auto i : events) { if (i.y.x == i.y.y) { unordered_set\u003cint\u003e s; vector\u003cint\u003e to_check; for (auto j : prom_left) { s.insert(j.y.x); if (j.y.x == ind_l) { to_check.pb(j.y.y); } } prom_left.clear(); for (auto j : to_check) { if (!s.count(j)) { ind_l = j; break; } } s.clear(); to_check.clear(); for (auto j : prom_right) { s.insert(j.y.y); if (j.y.y == ind_r) { to_check.pb(-j.y.x - 1); } } prom_right.clear(); for (auto j : to_check) { if (!s.count(j)) { ind_r = j; break; } } s.clear(); to_check.clear(); double res = point_pr(xr[ind_r], y[ind_r], i.x) - point_pr(xl[ind_l], y[ind_l], i.x); if ","date":"2020-08-10","objectID":"/posts/oi/problems/cf1388e/:0:0","series":null,"tags":["Notebooks/OI/OJ/Luogu"],"title":"CF1388E-Uncle Bogdan and Projections","uri":"/posts/oi/problems/cf1388e/#"},{"categories":null,"content":"CF1388D-Captain Flint and Treasure 题目: 题目描述: Captain Fint is involved in another treasure hunt, but have found only one strange problem. The problem may be connected to the treasure’s location or may not. That’s why captain Flint decided to leave the solving the problem to his crew and offered an absurdly high reward: one day off. The problem itself sounds like this… There are two arrays a a a and b b b of length n n n . Initially, an ans ans ans is equal to 0 0 0 and the following operation is defined: Choose position i i i ( 1≤i≤n 1 \\le i \\le n 1≤i≤n ); Add ai a_i ai​ to ans ans ans ; If bi≠−1 b_i \\neq -1 bi​=−1 then add ai a_i ai​ to abi a_{b_i} abi​​ . What is the maximum ans ans ans you can get by performing the operation on each i i i ( 1≤i≤n 1 \\le i \\le n 1≤i≤n ) exactly once? Uncle Bogdan is eager to get the reward, so he is asking your help to find the optimal order of positions to perform the operation on them. 输入格式: The first line contains the integer n n n ( 1≤n≤2⋅105 1 \\le n \\le 2 \\cdot 10^5 1≤n≤2⋅105 ) — the length of arrays a a a and b b b . The second line contains n n n integers a1,a2,…,an a_1, a_2, \\ldots, a_n a1​,a2​,…,an​ ( −106≤ai≤106 −10^6 \\le a_i \\le 10^6 −106≤ai​≤106 ). The third line contains n n n integers b1,b2,…,bn b_1, b_2, \\ldots, b_n b1​,b2​,…,bn​ ( 1≤bi≤n 1 \\le b_i \\le n 1≤bi​≤n or bi=−1 b_i = -1 bi​=−1 ). Additional constraint: it’s guaranteed that for any i i i ( 1≤i≤n 1 \\le i \\le n 1≤i≤n ) the sequence bi,bbi,bbbi,… b_i, b_{b_i}, b_{b_{b_i}}, \\ldots bi​,bbi​​,bbbi​​​,… is not cyclic, in other words it will always end with −1 -1 −1 . 输出格式: In the first line, print the maximum ans ans ans you can get. In the second line, print the order of operations: n n n different integers p1,p2,…,pn p_1, p_2, \\ldots, p_n p1​,p2​,…,pn​ ( 1≤pi≤n 1 \\le p_i \\le n 1≤pi​≤n ). The pi p_i pi​ is the position which should be chosen at the i i i -th step. If there are multiple orders, print any of them. 样例: 样例输入 1: 3 1 2 3 2 3 -1 样例输出 1: 10 1 2 3 样例输入 2: 2 -1 100 2 -1 样例输出 2: 99 2 1 样例输入 3: 10 -10 -1 2 2 5 -2 -3 -4 2 -6 -1 -1 2 2 -1 5 5 7 7 9 样例输出 3: -9 3 5 6 1 9 4 10 7 8 2 思路: 实现: #include \"ybwhead/ios.h\" const int maxn = 2e5 + 10; long long a[maxn]; int n; int in[maxn]; vector\u003cint\u003e c, d; int b[maxn]; int main() { yin \u003e\u003e n; for (int i = 1; i \u003c= n; i++) yin \u003e\u003e a[i]; for (int i = 1; i \u003c= n; i++) { yin \u003e\u003e b[i]; if (b[i] == -1) continue; ++in[b[i]]; } queue\u003cint\u003e q; for (int i = 1; i \u003c= n; i++) { if (in[i] == 0) q.push(i); } long long sum = 0; while (!q.empty()) { int v = q.front(); q.pop(); int w = b[v]; sum += a[v]; if (a[v] \u003e 0) { if (w \u003e 0) { a[w] += a[v]; } c.push_back(v); } else d.push_back(v); if (w \u003e 0) { --in[w]; if (in[w] == 0) q.push(w); } } yout \u003c\u003c sum \u003c\u003c endl; for (int i = 0; i \u003c c.size(); i++) yout \u003c\u003c c[i] \u003c\u003c ' '; for (int i = d.size() - 1; i \u003e= 0; i--) yout \u003c\u003c d[i] \u003c\u003c \" \"; yout \u003c\u003c endl; return 0; } ","date":"2020-08-10","objectID":"/posts/oi/problems/cf1388d/:0:0","series":null,"tags":["Notebooks/OI/OJ/Luogu"],"title":"CF1388D-Captain Flint and Treasure","uri":"/posts/oi/problems/cf1388d/#"},{"categories":null,"content":"CF1388C-Uncle Bogdan and Country Happiness 题目: 题目描述: Uncle Bogdan is in captain Flint’s crew for a long time and sometimes gets nostalgic for his homeland. Today he told you how his country introduced a happiness index. There are n n n cities and n−1 n−1 n−1 undirected roads connecting pairs of cities. Citizens of any city can reach any other city traveling by these roads. Cities are numbered from 1 1 1 to n n n and the city 1 1 1 is a capital. In other words, the country has a tree structure. There are m m m citizens living in the country. A pi p_i pi​ people live in the i i i -th city but all of them are working in the capital. At evening all citizens return to their home cities using the shortest paths. Every person has its own mood: somebody leaves his workplace in good mood but somebody are already in bad mood. Moreover any person can ruin his mood on the way to the hometown. If person is in bad mood he won’t improve it. Happiness detectors are installed in each city to monitor the happiness of each person who visits the city. The detector in the i i i -th city calculates a happiness index hi h_i hi​ as the number of people in good mood minus the number of people in bad mood. Let’s say for the simplicity that mood of a person doesn’t change inside the city. Happiness detector is still in development, so there is a probability of a mistake in judging a person’s happiness. One late evening, when all citizens successfully returned home, the government asked uncle Bogdan (the best programmer of the country) to check the correctness of the collected happiness indexes. Uncle Bogdan successfully solved the problem. Can you do the same? More formally, You need to check: “Is it possible that, after all people return home, for each city i i i the happiness index will be equal exactly to hi h_i hi​ “. 输入格式: The first line contains a single integer t t t ( 1≤t≤10000 1 \\le t \\le 10000 1≤t≤10000 ) — the number of test cases. The first line of each test case contains two integers n n n and m m m ( 1≤n≤105 1 \\le n \\le 10^5 1≤n≤105 ; 0≤m≤109 0 \\le m \\le 10^9 0≤m≤109 ) — the number of cities and citizens. The second line of each test case contains n n n integers p1,p2,…,pn p_1, p_2, \\ldots, p_{n} p1​,p2​,…,pn​ ( 0≤pi≤m 0 \\le p_i \\le m 0≤pi​≤m ; p1+p2+…+pn=m p_1 + p_2 + \\ldots + p_{n} = m p1​+p2​+…+pn​=m ), where pi p_i pi​ is the number of people living in the i i i -th city. The third line contains n n n integers h1,h2,…,hn h_1, h_2, \\ldots, h_{n} h1​,h2​,…,hn​ ( −109≤hi≤109 -10^9 \\le h_i \\le 10^9 −109≤hi​≤109 ), where hi h_i hi​ is the calculated happiness index of the i i i -th city. Next n−1 n − 1 n−1 lines contain description of the roads, one per line. Each line contains two integers xi x_i xi​ and yi y_i yi​ ( 1≤xi,yi≤n 1 \\le x_i, y_i \\le n 1≤xi​,yi​≤n ; xi≠yi x_i \\neq y_i xi​=yi​ ), where xi x_i xi​ and yi y_i yi​ are cities connected by the i i i -th road. It’s guaranteed that the sum of n n n from all test cases doesn’t exceed 2⋅105 2 \\cdot 10^5 2⋅105 . 输出格式: For each test case, print YES, if the collected data is correct, or NO — otherwise. You can print characters in YES or NO in any case. 样例: 样例输入 1: 2 7 4 1 0 1 1 0 1 0 4 0 0 -1 0 -1 0 1 2 1 3 1 4 3 5 3 6 3 7 5 11 1 2 5 2 1 -11 -2 -6 -2 -1 1 2 1 3 1 4 3 5 样例输出 1: YES YES 样例输入 2: 2 4 4 1 1 1 1 4 1 -3 -1 1 2 1 3 1 4 3 13 3 3 7 13 1 4 1 2 1 3 样例输出 2: NO NO 思路: 实现: #include \"ybwhead/ios.h\" const int maxn = 2e5 + 10; long long p[maxn], h[maxn]; int head[maxn]; int tot, ans; struct edge { int v, nxt; } e[maxn \u003c\u003c 1]; void __ADD(int u, int v) { e[++tot].v = v; e[tot].nxt = head[u]; head[u] = tot; } void add(int u, int v) { __ADD(u, v); __ADD(v, u); } int n, m; long long f[maxn], f1[maxn]; void dfs(int u, int fa) { for (int i = head[u]; i; i = e[i].nxt) { int v = e[i].v; if (v == fa) continue; dfs(v, u); if (!ans) return; f[u] += f[v]; f1[u] += f1[v]; } f[u] += p[u]; if (2 * f1[u] - f[u] \u003e h[u]) { ans = 0; return; } if ((f[u] + h[u]) % 2 == 0) { f1[u] = f[u] + h[u]; f1[u] \u003e\u003e= 1; } els","date":"2020-08-10","objectID":"/posts/oi/problems/cf1388c/:0:0","series":null,"tags":["图论","Notebooks/OI/OJ/Luogu"],"title":"CF1388C-Uncle Bogdan and Country Happiness","uri":"/posts/oi/problems/cf1388c/#"},{"categories":null,"content":"CF1388B-Captain Flint and a Long Voyage 题目: 题目描述: Captain Flint and his crew keep heading to a savage shore of Byteland for several months already, drinking rum and telling stories. In such moments uncle Bogdan often remembers his nephew Denis. Today, he has told a story about how Denis helped him to come up with an interesting problem and asked the crew to solve it. In the beginning, uncle Bogdan wrote on a board a positive integer x x x consisting of n n n digits. After that, he wiped out x x x and wrote integer k k k instead, which was the concatenation of binary representations of digits x x x consists of (without leading zeroes). For example, let x=729 x = 729 x=729 , then k=111101001 k = 111101001 k=111101001 (since 7=111 7 = 111 7=111 , 2=10 2 = 10 2=10 , 9=1001 9 = 1001 9=1001 ). After some time, uncle Bogdan understood that he doesn’t know what to do with k k k and asked Denis to help. Denis decided to wipe last n n n digits of k k k and named the new number as r r r . As a result, Denis proposed to find such integer x x x of length n n n that r r r (as number) is maximum possible. If there are multiple valid x x x then Denis is interested in the minimum one. All crew members, including captain Flint himself, easily solved the task. All, except cabin boy Kostya, who was too drunk to think straight. But what about you? Note: in this task, we compare integers ( x x x or k k k ) as numbers (despite what representations they are written in), so 729\u003c1999 729 \u003c 1999 729\u003c1999 or 111\u003c1000 111 \u003c 1000 111\u003c1000 . 输入格式: The first line contains a single integer t t t ( 1≤t≤1000 1 \\le t \\le 1000 1≤t≤1000 ) — the number of test cases. Next t t t lines contain test cases — one per test case. The one and only line of each test case contains the single integer n n n ( 1≤n≤105 1 \\le n \\le 10^5 1≤n≤105 ) — the length of the integer x x x you need to find. It’s guaranteed that the sum of n n n from all test cases doesn’t exceed 2⋅105 2 \\cdot 10^5 2⋅105 . 输出格式: For each test case, print the minimum integer x x x of length n n n such that obtained by Denis number r r r is maximum possible. 样例: 样例输入 1: 2 1 3 样例输出 1: 8 998 思路: 实现: #include \"ybwhead/ios.h\" int main() { int TTT; yin \u003e\u003e TTT; while (TTT--) { int n; yin \u003e\u003e n; for (int i = 1; i \u003c= n - (n + 3) / 4; i++) yout \u003c\u003c '9'; for (int i = 1; i \u003c= (n + 3) / 4; i++) yout \u003c\u003c '8'; yout \u003c\u003c endl; } return 0; } ","date":"2020-08-10","objectID":"/posts/oi/problems/cf1388b/:0:0","series":null,"tags":["Notebooks/OI/OJ/Luogu"],"title":"CF1388B-Captain Flint and a Long Voyage","uri":"/posts/oi/problems/cf1388b/#"},{"categories":null,"content":"CF1388A-Captain Flint and Crew Recruitment 题目: 题目描述: Despite his bad reputation, Captain Flint is a friendly person (at least, friendly to animals). Now Captain Flint is searching worthy sailors to join his new crew (solely for peaceful purposes). A sailor is considered as worthy if he can solve Flint’s task. Recently, out of blue Captain Flint has been interested in math and even defined a new class of integers. Let’s define a positive integer x x x as nearly prime if it can be represented as p⋅q p \\cdot q p⋅q , where 1\u003cp\u003cq 1 \u003c p \u003c q 1\u003cp\u003cq and p p p and q q q are prime numbers. For example, integers 6 6 6 and 10 10 10 are nearly primes (since 2⋅3=6 2 \\cdot 3 = 6 2⋅3=6 and 2⋅5=10 2 \\cdot 5 = 10 2⋅5=10 ), but integers 1 1 1 , 3 3 3 , 4 4 4 , 16 16 16 , 17 17 17 or 44 44 44 are not. Captain Flint guessed an integer n n n and asked you: can you represent it as the sum of 4 4 4 different positive integers where at least 3 3 3 of them should be nearly prime. Uncle Bogdan easily solved the task and joined the crew. Can you do the same? 输入格式: The first line contains a single integer t t t ( 1≤t≤1000 1 \\le t \\le 1000 1≤t≤1000 ) — the number of test cases. Next t t t lines contain test cases — one per line. The first and only line of each test case contains the single integer n n n (1≤n≤2⋅105) (1 \\le n \\le 2 \\cdot 10^5) (1≤n≤2⋅105) — the number Flint guessed. 输出格式: For each test case print: YES and 4 4 4 different positive integers such that at least 3 3 3 of them are nearly prime and their sum is equal to n n n (if there are multiple answers print any of them); NO if there is no way to represent n n n as the sum of 4 4 4 different positive integers where at least 3 3 3 of them are nearly prime. You can print each character of YES or NO in any case. 样例: 样例输入 1: 7 7 23 31 36 44 100 258 样例输出 1: NO NO YES 14 10 6 1 YES 5 6 10 15 YES 6 7 10 21 YES 2 10 33 55 YES 10 21 221 6 思路: 实现: #include \"ybwhead/ios.h\" int main() { int TTT; yin \u003e\u003e TTT; while (TTT--) { int n; yin \u003e\u003e n; if (n \u003e= 1 + 6 + 10 + 14) { puts(\"YES\"); if (n == 36) { yout \u003c\u003c \"5 6 10 15\" \u003c\u003c endl; continue; } if (n == 44) { yout \u003c\u003c \"6 7 10 21\" \u003c\u003c endl; continue; } if (n == 40) { yout \u003c\u003c \"6 10 15 9\" \u003c\u003c endl; continue; } // if (n == 40) yout \u003c\u003c 6 \u003c\u003c \" \" \u003c\u003c 10 \u003c\u003c ' ' \u003c\u003c 14 \u003c\u003c ' ' \u003c\u003c n - 10 - 6 - 14 \u003c\u003c endl; } else puts(\"NO\"); } return 0; } ","date":"2020-08-10","objectID":"/posts/oi/problems/cf1388a/:0:0","series":null,"tags":["Notebooks/OI/OJ/Luogu"],"title":"CF1388A-Captain Flint and Crew Recruitment","uri":"/posts/oi/problems/cf1388a/#"},{"categories":null,"content":"CF1393E2-Twilight and Ancient Scroll (harder version) 题目: 题目描述: This is a harder version of the problem E with larger constraints. Twilight Sparkle has received a new task from Princess Celestia. This time she asked to decipher the ancient scroll containing important knowledge of pony origin. To hide the crucial information from evil eyes, pony elders cast a spell on the scroll. That spell adds exactly one letter in any place to each word it is cast on. To make the path to the knowledge more tangled elders chose some of words in the scroll and cast a spell on them. Twilight Sparkle knows that the elders admired the order in all things so the scroll original scroll contained words in lexicographically non-decreasing order. She is asked to delete one letter from some of the words of the scroll (to undo the spell) to get some version of the original scroll. Unfortunately, there may be more than one way to recover the ancient scroll. To not let the important knowledge slip by Twilight has to look through all variants of the original scroll and find the required one. To estimate the maximum time Twilight may spend on the work she needs to know the number of variants she has to look through. She asks you to find that number! Since that number can be very big, Twilight asks you to find it modulo 109+7 10^9+7 109+7 . It may occur that princess Celestia has sent a wrong scroll so the answer may not exist. A string a a a is lexicographically smaller than a string b b b if and only if one of the following holds: a a a is a prefix of b b b , but a≠b a \\ne b a=b ; in the first position where a a a and b b b differ, the string a a a has a letter that appears earlier in the alphabet than the corresponding letter in b b b . 输入格式: The first line contains a single integer n n n ( 1≤n≤105 1 \\le n \\le 10^5 1≤n≤105 ): the number of words in the scroll. The i i i -th of the next n n n lines contains a string consisting of lowercase English letters: the i i i -th word in the scroll. The length of each word is at least one. The sum of lengths of words does not exceed 106 10^6 106 . 输出格式: Print one integer: the number of ways to get a version of the original from the scroll modulo 109+7 10^9+7 109+7 . 样例: 样例输入 1: 3 abcd zaza ataka 样例输出 1: 4 样例输入 2: 4 dfs bfs sms mms 样例输出 2: 8 样例输入 3: 3 abc bcd a 样例输出 3: 0 样例输入 4: 6 lapochka kartyshka bigbabytape morgenshtern ssshhhiiittt queen 样例输出 4: 2028 思路: 实现: #include \"ybwhead/ios.h\" typedef long long ll; int const maxn = 1e5 + 5, maxc = 1e6 + 5; ll mod[2], P[2], p[2][maxc], rev_P[2]; vector\u003cll\u003e h[2][maxn]; vector\u003cint\u003e sorted[maxn]; string s[maxn]; int nxt[maxc]; int a[maxc], dp[2][maxc], inf = 1e9 + 7; int MOD = 1e9 + 7; ll st(ll x, int y, int ok) { if (y == 0) return 1; if (y % 2 == 0) { ll d = st(x, y / 2, ok); return d * d % mod[ok]; } return x * st(x, y - 1, ok) % mod[ok]; } inline char get_c(int i, int x, int numb) { if (numb \u003c x) return s[i][numb]; if (numb + 1 \u003c (int)s[i].size()) return s[i][numb + 1]; return ' '; } inline ll get_hash(int t, int i, int x, int len) { if (len \u003c x) return h[t][i][len]; return (h[t][i][x] + (h[t][i][len + 1] - h[t][i][x + 1] + mod[t]) * rev_P[t]) % mod[t]; } inline pair\u003cll, ll\u003e get_h(int i, int x, int len) { return {get_hash(0, i, x, len), get_hash(1, i, x, len)}; } inline int check(int i, int x, int j, int y) { int len1 = (int)s[i].size(), len2 = (int)s[j].size(); if (x != len1) len1--; if (y != len2) len2--; int lef = 0, righ = min(len1, len2) + 1; while (righ - lef \u003e 1) { int mid = (righ + lef) / 2; if (get_h(i, x, mid) == get_h(j, y, mid)) lef = mid; else righ = mid; } return get_c(i, x, lef) \u003e= get_c(j, y, lef); } int main() { mod[0] = 1e9 + 7, mod[1] = 1e9 + 9, P[0] = 29, P[1] = 31, rev_P[0] = st(P[0], mod[0] - 2, 0), rev_P[1] = st(P[1], mod[1] - 2, 1); p[0][0] = 1, p[1][0] = 1; for (int i = 1; i \u003c maxc; ++i) { for (int j = 0; j \u003c= 1; ++j) p[j][i] = p[j][i - 1] * P[j] % mod[j]; } int n; yin \u003e\u003e n; for (int i = 1; i \u003c= n; ++i) { yin \u003e\u003e s[i]; for (int j = 0; j \u003c= 1; ++j) ","date":"2020-08-10","objectID":"/posts/oi/problems/cf1393e2/:0:0","series":null,"tags":["Notebooks/OI/OJ/Luogu"],"title":"CF1393E2-Twilight and Ancient Scroll (harder version)","uri":"/posts/oi/problems/cf1393e2/#"},{"categories":null,"content":"CF1393E1-Twilight and Ancient Scroll (easier version) 题目: 题目描述: This is an easier version of the problem E with smaller constraints. Twilight Sparkle has received a new task from Princess Celestia. This time she asked to decipher the ancient scroll containing important knowledge of pony origin. To hide the crucial information from evil eyes, pony elders cast a spell on the scroll. That spell adds exactly one letter in any place to each word it is cast on. To make the path to the knowledge more tangled elders chose some of words in the scroll and cast a spell on them. Twilight Sparkle knows that the elders admired the order in all things so the scroll original scroll contained words in lexicographically non-decreasing order. She is asked to delete one letter from some of the words of the scroll (to undo the spell) to get some version of the original scroll. Unfortunately, there may be more than one way to recover the ancient scroll. To not let the important knowledge slip by Twilight has to look through all variants of the original scroll and find the required one. To estimate the maximum time Twilight may spend on the work she needs to know the number of variants she has to look through. She asks you to find that number! Since that number can be very big, Twilight asks you to find it modulo 109+7 10^9+7 109+7 . It may occur that princess Celestia has sent a wrong scroll so the answer may not exist. A string a a a is lexicographically smaller than a string b b b if and only if one of the following holds: a a a is a prefix of b b b , but a≠b a \\ne b a=b ; in the first position where a a a and b b b differ, the string a a a has a letter that appears earlier in the alphabet than the corresponding letter in b b b . 输入格式: The first line contains a single integer n n n ( 1≤n≤1000 1 \\le n \\le 1000 1≤n≤1000 ): the number of words in the scroll. The i i i -th of the next n n n lines contains a string consisting of lowercase English letters: the i i i -th word in the scroll. The length of each word is more or equal than 1 1 1 . The sum of lengths of words does not exceed 20000 20000 20000 . 输出格式: Print one integer: the number of ways to get a version of the original from the scroll modulo 109+7 10^9+7 109+7 . 样例: 样例输入 1: 3 abcd zaza ataka 样例输出 1: 4 样例输入 2: 4 dfs bfs sms mms 样例输出 2: 8 样例输入 3: 3 abc bcd a 样例输出 3: 0 样例输入 4: 6 lapochka kartyshka bigbabytape morgenshtern ssshhhiiittt queen 样例输出 4: 2028 思路: 实现: #include \"ybwhead/ios.h\" typedef long long ll; int const maxn = 1e5 + 5, maxc = 1e6 + 5; ll mod[2], P[2], p[2][maxc], rev_P[2]; vector\u003cll\u003e h[2][maxn]; vector\u003cint\u003e sorted[maxn]; string s[maxn]; int nxt[maxc]; int a[maxc], dp[2][maxc], inf = 1e9 + 7; int MOD = 1e9 + 7; ll st(ll x, int y, int ok) { if (y == 0) return 1; if (y % 2 == 0) { ll d = st(x, y / 2, ok); return d * d % mod[ok]; } return x * st(x, y - 1, ok) % mod[ok]; } inline char get_c(int i, int x, int numb) { if (numb \u003c x) return s[i][numb]; if (numb + 1 \u003c (int)s[i].size()) return s[i][numb + 1]; return ' '; } inline ll get_hash(int t, int i, int x, int len) { if (len \u003c x) return h[t][i][len]; return (h[t][i][x] + (h[t][i][len + 1] - h[t][i][x + 1] + mod[t]) * rev_P[t]) % mod[t]; } inline pair\u003cll, ll\u003e get_h(int i, int x, int len) { return {get_hash(0, i, x, len), get_hash(1, i, x, len)}; } inline int check(int i, int x, int j, int y) { int len1 = (int)s[i].size(), len2 = (int)s[j].size(); if (x != len1) len1--; if (y != len2) len2--; int lef = 0, righ = min(len1, len2) + 1; while (righ - lef \u003e 1) { int mid = (righ + lef) / 2; if (get_h(i, x, mid) == get_h(j, y, mid)) lef = mid; else righ = mid; } return get_c(i, x, lef) \u003e= get_c(j, y, lef); } int main() { mod[0] = 1e9 + 7, mod[1] = 1e9 + 9, P[0] = 29, P[1] = 31, rev_P[0] = st(P[0], mod[0] - 2, 0), rev_P[1] = st(P[1], mod[1] - 2, 1); p[0][0] = 1, p[1][0] = 1; for (int i = 1; i \u003c maxc; ++i) { for (int j = 0; j \u003c= 1; ++j) p[j][i] = p[j][i - 1] * P[j] % mod[j]; } int n; yin \u003e\u003e n; for (int i = 1; i \u003c= n; ++i) { yin \u003e\u003e s[i]; for (in","date":"2020-08-10","objectID":"/posts/oi/problems/cf1393e1/:0:0","series":null,"tags":["Notebooks/OI/OJ/Luogu"],"title":"CF1393E1-Twilight and Ancient Scroll (easier version)","uri":"/posts/oi/problems/cf1393e1/#"},{"categories":null,"content":"CF1391E-Pairs of Pairs 题目: 题目描述: You have a simple and connected undirected graph consisting of n n n nodes and m m m edges. Consider any way to pair some subset of these n n n nodes such that no node is present in more than one pair. This pairing is valid if for every pair of pairs, the induced subgraph containing all 4 4 4 nodes, two from each pair, has at most 2 2 2 edges (out of the 6 6 6 possible edges). More formally, for any two pairs, (a,b) (a,b) (a,b) and (c,d) (c,d) (c,d) , the induced subgraph with nodes {a,b,c,d} \\{a,b,c,d\\} {a,b,c,d} should have at most 2 2 2 edges. Please note that the subgraph induced by a set of nodes contains nodes only from this set and edges which have both of its end points in this set. Now, do one of the following: Find a simple path consisting of at least ⌈n2⌉ \\lceil \\frac{n}{2} \\rceil ⌈2n​⌉ nodes. Here, a path is called simple if it does not visit any node multiple times. Find a valid pairing in which at least ⌈n2⌉ \\lceil \\frac{n}{2} \\rceil ⌈2n​⌉ nodes are paired. It can be shown that it is possible to find at least one of the two in every graph satisfying constraints from the statement. 输入格式: Each test contains multiple test cases. The first line contains the number of test cases t t t ( 1≤t≤105 1 \\le t \\le 10^5 1≤t≤105 ). Description of the test cases follows. The first line of each test case contains 2 2 2 integers n,m n, m n,m ( 2≤n≤5⋅105 2 \\le n \\le 5\\cdot 10^5 2≤n≤5⋅105 , 1≤m≤106 1 \\le m \\le 10^6 1≤m≤106 ), denoting the number of nodes and edges, respectively. The next m m m lines each contain 2 2 2 integers u u u and v v v ( 1≤u,v≤n 1 \\le u, v \\le n 1≤u,v≤n , u≠v u \\neq v u=v ), denoting that there is an undirected edge between nodes u u u and v v v in the given graph. It is guaranteed that the given graph is connected, and simple — it does not contain multiple edges between the same pair of nodes, nor does it have any self-loops. It is guaranteed that the sum of n n n over all test cases does not exceed 5⋅105 5\\cdot 10^5 5⋅105 . It is guaranteed that the sum of m m m over all test cases does not exceed 106 10^6 106 . 输出格式: For each test case, the output format is as follows. If you have found a pairing, in the first line output “PAIRING” (without quotes). Then, output k k k ( ⌈n2⌉≤2⋅k≤n \\lceil \\frac{n}{2} \\rceil \\le 2\\cdot k \\le n ⌈2n​⌉≤2⋅k≤n ), the number of pairs in your pairing. Then, in each of the next k k k lines, output 2 2 2 integers a a a and b b b — denoting that a a a and b b b are paired with each other. Note that the graph does not have to have an edge between a a a and b b b ! This pairing has to be valid, and every node has to be a part of at most 1 1 1 pair. Otherwise, in the first line output “PATH” (without quotes). Then, output k k k ( ⌈n2⌉≤k≤n \\lceil \\frac{n}{2} \\rceil \\le k \\le n ⌈2n​⌉≤k≤n ), the number of nodes in your path. Then, in the second line, output k k k integers, v1,v2,…,vk v_1, v_2, \\ldots, v_k v1​,v2​,…,vk​ , in the order in which they appear on the path. Formally, vi v_i vi​ and vi+1 v_{i+1} vi+1​ should have an edge between them for every i i i ( 1≤i\u003ck 1 \\le i \u003c k 1≤i\u003ck ). This path has to be simple, meaning no node should appear more than once. 样例: 样例输入 1: 4 6 5 1 4 2 5 3 6 1 5 3 5 6 5 1 4 2 5 3 6 1 5 3 5 12 14 1 2 2 3 3 4 4 1 1 5 1 12 2 6 2 7 3 8 3 9 4 10 4 11 2 4 1 3 12 14 1 2 2 3 3 4 4 1 1 5 1 12 2 6 2 7 3 8 3 9 4 10 4 11 2 4 1 3 样例输出 1: PATH 4 1 5 3 6 PAIRING 2 1 6 2 4 PAIRING 3 1 8 2 5 4 10 PAIRING 4 1 7 2 9 3 11 4 5 思路: 实现: #include \"ybwhead/ios.h\" const int maxm = 1e6 + 10, maxn = 5e5 + 10; struct edge { int v, nxt; } e[maxm \u003c\u003c 1]; int head[maxn], tot; void __ADD(int u, int v) { e[++tot].v = v; e[tot].nxt = head[u]; head[u] = tot; } void add(int u, int v) { __ADD(u, v); __ADD(v, u); } int n, m; int maxh; int dep[maxn]; int vis[maxn]; int dfn[maxn]; int f[maxn]; int num; vector\u003cint\u003e dd[maxn]; void dfs(int u, int fa) { dep[u] = dep[fa] + 1; if (dep[u] \u003e dep[maxh]) maxh = u; vis[u] = ++num; dd[dep[u]].push_back(u); f[u] = fa; for (int i =","date":"2020-08-10","objectID":"/posts/oi/problems/cf1391e/:0:0","series":null,"tags":["Notebooks/OI/OJ/Luogu"],"title":"CF1391E-Pairs of Pairs","uri":"/posts/oi/problems/cf1391e/#"},{"categories":null,"content":"CF1391D-505 题目: 题目描述: A binary matrix is called good if every even length square sub-matrix has an odd number of ones. Given a binary matrix a a a consisting of n n n rows and m m m columns, determine the minimum number of cells you need to change to make it good, or report that there is no way to make it good at all. All the terms above have their usual meanings — refer to the Notes section for their formal definitions. 输入格式: The first line of input contains two integers n n n and m m m ( 1≤n≤m≤106 1 \\leq n \\leq m \\leq 10^6 1≤n≤m≤106 and n⋅m≤106 n\\cdot m \\leq 10^6 n⋅m≤106 ) — the number of rows and columns in a a a , respectively. The following n n n lines each contain m m m characters, each of which is one of 0 and 1. If the j j j -th character on the i i i -th line is 1, then ai,j=1 a_{i,j} = 1 ai,j​=1 . Similarly, if the j j j -th character on the i i i -th line is 0, then ai,j=0 a_{i,j} = 0 ai,j​=0 . 输出格式: Output the minimum number of cells you need to change to make a a a good, or output −1 -1 −1 if it’s not possible at all. 样例: 样例输入 1: 3 3 101 001 110 样例输出 1: 2 样例输入 2: 7 15 000100001010010 100111010110001 101101111100100 010000111111010 111010010100001 000011001111101 111111011010011 样例输出 2: -1 思路: 实现: /* *User: ybw051114 *Time: 2020.08.09 22:35:06 */ #include \u003cbits/stdc++.h\u003e using namespace std; #ifndef use_ios11 #define use_ios11 using namespace std; struct ins { int ans; ins() { ans = 1; } #define endl '\\n' void read() { } void read1(char \u0026s) { char c = getchar(); for (; !isprint(c) || c == ' ' || c == '\\n' || c == '\\t'; c = getchar()) ; s = c; if (c == EOF) ans = 0; } void read1(string \u0026s) { s = \"\"; char c = getchar(); for (; !isprint(c) || c == ' ' || c == '\\n' || c == '\\t'; c = getchar()) ; for (; isprint(c) \u0026\u0026 c != ' ' \u0026\u0026 c != '\\n' \u0026\u0026 c != '\\t'; c = getchar()) s += c; if (c == EOF) ans = 0; } template \u003ctypename T\u003e void read1(T \u0026n) { T x = 0; int f = 1; char c = getchar(); for (; !isdigit(c); c = getchar()) { if (c == '-') f = -1; if (c == EOF) { ans = 0; return; } } for (; isdigit(c); c = getchar()) x = x * 10 + c - 48; n = x * f; if (c == EOF) ans = 0; if (c != '.') return; T l = 0.1; while ((c = getchar()) \u003c= '9' \u0026\u0026 c \u003e= '0') x = x + (c \u0026 15) * l, l *= 0.1; n = x * f; if (c == EOF) ans = 0; } void write() {} void write1(string s) { int n = s.size(); for (int i = 0; i \u003c n; i++) putchar(s[i]); } void write1(const char *s) { int n = strlen(s); for (int i = 0; i \u003c n; i++) putchar(s[i]); } void write1(char s) { putchar(s); } void write1(float s, int x = 6) { char y[10001]; sprintf(y, \"%%.%df\", x); printf(y, s); } void write1(double s, int x = 6) { char y[10001]; sprintf(y, \"%%.%dlf\", x); printf(y, s); } void write1(long double s, int x = 6) { char y[10001]; sprintf(y, \"%%.%dLf\", x); printf(y, s); } template \u003ctypename T\u003e void write1(T n) { if (n \u003c 0) n = -n, putchar('-'); if (n \u003e 9) write1(n / 10); putchar('0' + n % 10); } template \u003ctypename T\u003e friend ins operator\u003e\u003e(ins x, T \u0026n); template \u003ctypename T\u003e friend ins operator\u003c\u003c(ins x, T n); operator bool() { return ans; } }; template \u003ctypename T\u003e ins operator\u003e\u003e(ins x, T \u0026n) { if (!x.ans) return x; x.read1(n); return x; } template \u003ctypename T\u003e ins operator\u003c\u003c(ins x, T n) { x.write1(n); return x; } ins yin; ins yout; #endif const int maxn = 1e6 + 10; char c[maxn][4]; int f[maxn][8]; int a[10], b[10]; int main() { int n, m; yin \u003e\u003e n \u003e\u003e m; if (n \u003e= 4 \u0026\u0026 m \u003e= 4) { puts(\"-1\"); return 0; } if (n \u003e m) { for (int i = 1; i \u003c= n; i++) { for (int j = 1; j \u003c= m; j++) { yin \u003e\u003e c[i][j]; } } swap(n, m); } else { for (int i = 1; i \u003c= n; i++) { for (int j = 1; j \u003c= m; j++) { yin \u003e\u003e c[j][i]; } } } if (n == 1) { puts(\"0\"); return 0; } for (int i = 0; i \u003c 8; i++) { if (i \u003e= 4 \u0026\u0026 n == 2) break; for (int kk = 1; kk \u003c= n; kk++) if (i \u0026 (1 \u003c\u003c (kk - 1))) a[kk] = 1; else a[kk] = 0; int ans = 0; for (int kk = 1; kk \u003c= n; kk++) if (a[kk] != c[1][kk] - '0') ans++; f[1][i] = ans; } for (int k = 2; k \u003c= m; k++) { for (int i = 0; i \u003c 8; i++) { if (i \u003e= 4 \u0026\u0026 n == 2) break; f[k][i] = INT_MAX; for (int j = 0","date":"2020-08-10","objectID":"/posts/oi/problems/cf1391d/:0:0","series":null,"tags":["Notebooks/OI/OJ/Luogu"],"title":"CF1391D-505","uri":"/posts/oi/problems/cf1391d/#"},{"categories":null,"content":"CF1391C-Cyclic Permutations 题目: 题目描述: A permutation of length n n n is an array consisting of n n n distinct integers from 1 1 1 to n n n in arbitrary order. For example, [2,3,1,5,4] [2,3,1,5,4] [2,3,1,5,4] is a permutation, but [1,2,2] [1,2,2] [1,2,2] is not a permutation ( 2 2 2 appears twice in the array) and [1,3,4] [1,3,4] [1,3,4] is also not a permutation ( n=3 n=3 n=3 but there is 4 4 4 in the array). Consider a permutation p p p of length n n n , we build a graph of size n n n using it as follows: For every 1≤i≤n 1 \\leq i \\leq n 1≤i≤n , find the largest j j j such that 1≤j\u003ci 1 \\leq j \u003c i 1≤j\u003ci and pj\u003epi p_j \u003e p_i pj​\u003epi​ , and add an undirected edge between node i i i and node j j j For every 1≤i≤n 1 \\leq i \\leq n 1≤i≤n , find the smallest j j j such that i\u003cj≤n i \u003c j \\leq n i\u003cj≤n and pj\u003epi p_j \u003e p_i pj​\u003epi​ , and add an undirected edge between node i i i and node j j j In cases where no such j j j exists, we make no edges. Also, note that we make edges between the corresponding indices, not the values at those indices. For clarity, consider as an example n=4 n = 4 n=4 , and p=[3,1,4,2] p = [3,1,4,2] p=[3,1,4,2] ; here, the edges of the graph are (1,3),(2,1),(2,3),(4,3) (1,3),(2,1),(2,3),(4,3) (1,3),(2,1),(2,3),(4,3) . A permutation p p p is cyclic if the graph built using p p p has at least one simple cycle. Given n n n , find the number of cyclic permutations of length n n n . Since the number may be very large, output it modulo 109+7 10^9+7 109+7 . Please refer to the Notes section for the formal definition of a simple cycle 输入格式: The first and only line contains a single integer n n n ( 3≤n≤106 3 \\le n \\le 10^6 3≤n≤106 ). 输出格式: Output a single integer 0≤x\u003c109+7 0 \\leq x \u003c 10^9+7 0≤x\u003c109+7 , the number of cyclic permutations of length n n n modulo 109+7 10^9+7 109+7 . 样例: 样例输入 1: 4 样例输出 1: 16 样例输入 2: 583291 样例输出 2: 135712853 思路: 实现: /* *User: ybw051114 *Time: 2020.08.09 22:35:06 */ #include \u003cbits/stdc++.h\u003e using namespace std; #ifndef use_ios11 #define use_ios11 using namespace std; struct ins { int ans; ins() { ans = 1; } #define endl '\\n' void read() { } void read1(char \u0026s) { char c = getchar(); for (; !isprint(c) || c == ' ' || c == '\\n' || c == '\\t'; c = getchar()) ; s = c; if (c == EOF) ans = 0; } void read1(string \u0026s) { s = \"\"; char c = getchar(); for (; !isprint(c) || c == ' ' || c == '\\n' || c == '\\t'; c = getchar()) ; for (; isprint(c) \u0026\u0026 c != ' ' \u0026\u0026 c != '\\n' \u0026\u0026 c != '\\t'; c = getchar()) s += c; if (c == EOF) ans = 0; } template \u003ctypename T\u003e void read1(T \u0026n) { T x = 0; int f = 1; char c = getchar(); for (; !isdigit(c); c = getchar()) { if (c == '-') f = -1; if (c == EOF) { ans = 0; return; } } for (; isdigit(c); c = getchar()) x = x * 10 + c - 48; n = x * f; if (c == EOF) ans = 0; if (c != '.') return; T l = 0.1; while ((c = getchar()) \u003c= '9' \u0026\u0026 c \u003e= '0') x = x + (c \u0026 15) * l, l *= 0.1; n = x * f; if (c == EOF) ans = 0; } void write() {} void write1(string s) { int n = s.size(); for (int i = 0; i \u003c n; i++) putchar(s[i]); } void write1(const char *s) { int n = strlen(s); for (int i = 0; i \u003c n; i++) putchar(s[i]); } void write1(char s) { putchar(s); } void write1(float s, int x = 6) { char y[10001]; sprintf(y, \"%%.%df\", x); printf(y, s); } void write1(double s, int x = 6) { char y[10001]; sprintf(y, \"%%.%dlf\", x); printf(y, s); } void write1(long double s, int x = 6) { char y[10001]; sprintf(y, \"%%.%dLf\", x); printf(y, s); } template \u003ctypename T\u003e void write1(T n) { if (n \u003c 0) n = -n, putchar('-'); if (n \u003e 9) write1(n / 10); putchar('0' + n % 10); } template \u003ctypename T\u003e friend ins operator\u003e\u003e(ins x, T \u0026n); template \u003ctypename T\u003e friend ins operator\u003c\u003c(ins x, T n); operator bool() { return ans; } }; template \u003ctypename T\u003e ins operator\u003e\u003e(ins x, T \u0026n) { if (!x.ans) return x; x.read1(n); return x; } template \u003ctypename T\u003e ins operator\u003c\u003c(ins x, T n) { x.write1(n); return x; } ins yin; ins yout; #endif const long long mod = 1e9 + 7; long long ksm(long long a, int n) { long long ans = 1; while (n) { if (n \u0026 1) ans = (ans","date":"2020-08-10","objectID":"/posts/oi/problems/cf1391c/:0:0","series":null,"tags":["Notebooks/OI/OJ/Luogu"],"title":"CF1391C-Cyclic Permutations","uri":"/posts/oi/problems/cf1391c/#"},{"categories":null,"content":"CF1391B-Fix You 题目: 题目描述: Consider a conveyor belt represented using a grid consisting of n n n rows and m m m columns. The cell in the i i i -th row from the top and the j j j -th column from the left is labelled (i,j) (i,j) (i,j) . Every cell, except (n,m) (n,m) (n,m) , has a direction R (Right) or D (Down) assigned to it. If the cell (i,j) (i,j) (i,j) is assigned direction R, any luggage kept on that will move to the cell (i,j+1) (i,j+1) (i,j+1) . Similarly, if the cell (i,j) (i,j) (i,j) is assigned direction D, any luggage kept on that will move to the cell (i+1,j) (i+1,j) (i+1,j) . If at any moment, the luggage moves out of the grid, it is considered to be lost. There is a counter at the cell (n,m) (n,m) (n,m) from where all luggage is picked. A conveyor belt is called functional if and only if any luggage reaches the counter regardless of which cell it is placed in initially. More formally, for every cell (i,j) (i,j) (i,j) , any luggage placed in this cell should eventually end up in the cell (n,m) (n,m) (n,m) . This may not hold initially; you are, however, allowed to change the directions of some cells to make the conveyor belt functional. Please determine the minimum amount of cells you have to change. Please note that it is always possible to make any conveyor belt functional by changing the directions of some set of cells. 输入格式: Each test contains multiple test cases. The first line contains the number of test cases t t t ( 1≤t≤10 1 \\le t \\le 10 1≤t≤10 ). Description of the test cases follows. The first line of each test case contains two integers n,m n, m n,m ( 1≤n≤100 1 \\le n \\le 100 1≤n≤100 , 1≤m≤100 1 \\le m \\le 100 1≤m≤100 ) — the number of rows and columns, respectively. The following n n n lines each contain m m m characters. The j j j -th character in the i i i -th line, ai,j a_{i,j} ai,j​ is the initial direction of the cell (i,j) (i, j) (i,j) . Please note that an,m= a_{n,m}= an,m​= C. 输出格式: For each case, output in a new line the minimum number of cells that you have to change to make the conveyor belt functional. 样例: 样例输入 1: 4 3 3 RRD DDR RRC 1 4 DDDC 6 9 RDDDDDRRR RRDDRRDDD RRDRDRRDR DDDDRDDRR DRRDRDDDR DDRDRRDDC 1 1 C 样例输出 1: 1 3 9 0 思路: 实现: /* *User: ybw051114 *Time: 2020.08.09 22:35:06 */ #include \u003cbits/stdc++.h\u003e using namespace std; #ifndef use_ios11 #define use_ios11 using namespace std; struct ins { int ans; ins() { ans = 1; } #define endl '\\n' void read() { } void read1(char \u0026s) { char c = getchar(); for (; !isprint(c) || c == ' ' || c == '\\n' || c == '\\t'; c = getchar()) ; s = c; if (c == EOF) ans = 0; } void read1(string \u0026s) { s = \"\"; char c = getchar(); for (; !isprint(c) || c == ' ' || c == '\\n' || c == '\\t'; c = getchar()) ; for (; isprint(c) \u0026\u0026 c != ' ' \u0026\u0026 c != '\\n' \u0026\u0026 c != '\\t'; c = getchar()) s += c; if (c == EOF) ans = 0; } template \u003ctypename T\u003e void read1(T \u0026n) { T x = 0; int f = 1; char c = getchar(); for (; !isdigit(c); c = getchar()) { if (c == '-') f = -1; if (c == EOF) { ans = 0; return; } } for (; isdigit(c); c = getchar()) x = x * 10 + c - 48; n = x * f; if (c == EOF) ans = 0; if (c != '.') return; T l = 0.1; while ((c = getchar()) \u003c= '9' \u0026\u0026 c \u003e= '0') x = x + (c \u0026 15) * l, l *= 0.1; n = x * f; if (c == EOF) ans = 0; } void write() {} void write1(string s) { int n = s.size(); for (int i = 0; i \u003c n; i++) putchar(s[i]); } void write1(const char *s) { int n = strlen(s); for (int i = 0; i \u003c n; i++) putchar(s[i]); } void write1(char s) { putchar(s); } void write1(float s, int x = 6) { char y[10001]; sprintf(y, \"%%.%df\", x); printf(y, s); } void write1(double s, int x = 6) { char y[10001]; sprintf(y, \"%%.%dlf\", x); printf(y, s); } void write1(long double s, int x = 6) { char y[10001]; sprintf(y, \"%%.%dLf\", x); printf(y, s); } template \u003ctypename T\u003e void write1(T n) { if (n \u003c 0) n = -n, putchar('-'); if (n \u003e 9) write1(n / 10); putchar('0' + n % 10); } template \u003ctypename T\u003e friend ins operator\u003e\u003e(ins x, T \u0026n); template \u003ctypename T\u003e friend ins operator\u003c\u003c(ins x, T n); operator bool() { return ","date":"2020-08-10","objectID":"/posts/oi/problems/cf1391b/:0:0","series":null,"tags":["Notebooks/OI/OJ/Luogu"],"title":"CF1391B-Fix You","uri":"/posts/oi/problems/cf1391b/#"},{"categories":null,"content":"CF1391A-Suborrays 题目: 题目描述: A permutation of length n n n is an array consisting of n n n distinct integers from 1 1 1 to n n n in arbitrary order. For example, [2,3,1,5,4] [2,3,1,5,4] [2,3,1,5,4] is a permutation, but [1,2,2] [1,2,2] [1,2,2] is not a permutation ( 2 2 2 appears twice in the array) and [1,3,4] [1,3,4] [1,3,4] is also not a permutation ( n=3 n=3 n=3 but there is 4 4 4 in the array). For a positive integer n n n , we call a permutation p p p of length n n n good if the following condition holds for every pair i i i and j j j ( 1≤i≤j≤n 1 \\le i \\le j \\le n 1≤i≤j≤n ) — (pi OR pi+1 OR … OR pj−1 OR pj)≥j−i+1 (p_i \\text{ OR } p_{i+1} \\text{ OR } \\ldots \\text{ OR } p_{j-1} \\text{ OR } p_{j}) \\ge j-i+1 (pi​ OR pi+1​ OR … OR pj−1​ OR pj​)≥j−i+1 , where OR \\text{OR} OR denotes the bitwise OR operation. In other words, a permutation p p p is good if for every subarray of p p p , the OR \\text{OR} OR of all elements in it is not less than the number of elements in that subarray. Given a positive integer n n n , output any good permutation of length n n n . We can show that for the given constraints such a permutation always exists. 输入格式: Each test contains multiple test cases. The first line contains the number of test cases t t t ( 1≤t≤100 1 \\le t \\le 100 1≤t≤100 ). Description of the test cases follows. The first and only line of every test case contains a single integer n n n ( 1≤n≤100 1 \\le n \\le 100 1≤n≤100 ). 输出格式: For every test, output any good permutation of length n n n on a separate line. 样例: 样例输入 1: 3 1 3 7 样例输出 1: 1 3 1 2 4 3 5 2 7 1 6 思路: 实现: /* *User: ybw051114 *Time: 2020.08.09 22:35:06 */ #include \u003cbits/stdc++.h\u003e using namespace std; #ifndef use_ios11 #define use_ios11 using namespace std; struct ins { int ans; ins() { ans = 1; } #define endl '\\n' void read() { } void read1(char \u0026s) { char c = getchar(); for (; !isprint(c) || c == ' ' || c == '\\n' || c == '\\t'; c = getchar()) ; s = c; if (c == EOF) ans = 0; } void read1(string \u0026s) { s = \"\"; char c = getchar(); for (; !isprint(c) || c == ' ' || c == '\\n' || c == '\\t'; c = getchar()) ; for (; isprint(c) \u0026\u0026 c != ' ' \u0026\u0026 c != '\\n' \u0026\u0026 c != '\\t'; c = getchar()) s += c; if (c == EOF) ans = 0; } template \u003ctypename T\u003e void read1(T \u0026n) { T x = 0; int f = 1; char c = getchar(); for (; !isdigit(c); c = getchar()) { if (c == '-') f = -1; if (c == EOF) { ans = 0; return; } } for (; isdigit(c); c = getchar()) x = x * 10 + c - 48; n = x * f; if (c == EOF) ans = 0; if (c != '.') return; T l = 0.1; while ((c = getchar()) \u003c= '9' \u0026\u0026 c \u003e= '0') x = x + (c \u0026 15) * l, l *= 0.1; n = x * f; if (c == EOF) ans = 0; } void write() {} void write1(string s) { int n = s.size(); for (int i = 0; i \u003c n; i++) putchar(s[i]); } void write1(const char *s) { int n = strlen(s); for (int i = 0; i \u003c n; i++) putchar(s[i]); } void write1(char s) { putchar(s); } void write1(float s, int x = 6) { char y[10001]; sprintf(y, \"%%.%df\", x); printf(y, s); } void write1(double s, int x = 6) { char y[10001]; sprintf(y, \"%%.%dlf\", x); printf(y, s); } void write1(long double s, int x = 6) { char y[10001]; sprintf(y, \"%%.%dLf\", x); printf(y, s); } template \u003ctypename T\u003e void write1(T n) { if (n \u003c 0) n = -n, putchar('-'); if (n \u003e 9) write1(n / 10); putchar('0' + n % 10); } template \u003ctypename T\u003e friend ins operator\u003e\u003e(ins x, T \u0026n); template \u003ctypename T\u003e friend ins operator\u003c\u003c(ins x, T n); operator bool() { return ans; } }; template \u003ctypename T\u003e ins operator\u003e\u003e(ins x, T \u0026n) { if (!x.ans) return x; x.read1(n); return x; } template \u003ctypename T\u003e ins operator\u003c\u003c(ins x, T n) { x.write1(n); return x; } ins yin; ins yout; #endif int main() { int TTT; yin \u003e\u003e TTT; while (TTT--) { int n; yin \u003e\u003e n; for (int i = 1; i \u003c= n; i++) { yout \u003c\u003c i \u003c\u003c \" \"; } yout \u003c\u003c endl; } return 0; } ","date":"2020-08-10","objectID":"/posts/oi/problems/cf1391a/:0:0","series":null,"tags":["Notebooks/OI/OJ/Luogu"],"title":"CF1391A-Suborrays","uri":"/posts/oi/problems/cf1391a/#"},{"categories":null,"content":"P3830-[SHOI2012]随机树 题目: 题目描述: 输入格式: 输入仅有一行，包含两个正整数 q, n，分别表示问题编号以及叶结点的个数。 输出格式: 输出仅有一行，包含一个实数 d，四舍五入精确到小数点后 6 位。如果 q = 1，则 d 表示叶结点平均深度的数学期望值；如果 q = 2，则 d 表示树深度的数学期望值。 样例: 样例输入 1: 1 4 样例输出 1: 2.166667 样例输入 2: 2 4 样例输出 2: 2.666667 样例输入 3: 1 12 样例输出 3: 4.206421 样例输入 4: 2 12 样例输出 4: 5.916614 思路: 实现: #include \"ybwhead/ios.h\" const int maxn = 2e3 + 10; double f[maxn][maxn]; int q, n; int main() { yin \u003e\u003e q \u003e\u003e n; if (q == 1) { double x = 0; for (int i = 2; i \u003c= n; i++) x = x + (double)2 / i; yout \u003c\u003c x \u003c\u003c endl; return 0; } for (int i = 1; i \u003c= n; i++) f[i][0] = 1; for (int i = 2; i \u003c= n; i++) { for (int j = 1; j \u003c i; j++) { for (int k = 1; k \u003c i; k++) f[i][j] += f[k][j - 1] + f[i - k][j - 1] - f[k][j - 1] * f[i - k][j - 1]; // yout \u003c\u003c i \u003c\u003c \" \" \u003c\u003c j \u003c\u003c ' ' \u003c\u003c f[i][j] \u003c\u003c endl; f[i][j] = f[i][j] / (i - 1); } } double ans = 0; for (int i = 1; i \u003c n; i++) ans += f[n][i]; yout \u003c\u003c ans \u003c\u003c endl; return 0; } ","date":"2020-08-09","objectID":"/posts/oi/problems/p3830/:0:0","series":null,"tags":["dp",2012,"各省省选","上海","期望","构造","高性能","Notebooks/OI/OJ/Luogu"],"title":"P3830-[SHOI2012]随机树","uri":"/posts/oi/problems/p3830/#"},{"categories":null,"content":"CF896C-Willem, Chtholly and Seniorious 题目: 题目描述: — Willem… — What’s the matter? — It seems that there’s something wrong with Seniorious… — I’ll have a look… Seniorious is made by linking special talismans in particular order. After over 500 years, the carillon is now in bad condition, so Willem decides to examine it thoroughly. Seniorious has n n n pieces of talisman. Willem puts them in a line, the i i i -th of which is an integer ai a_{i} ai​ . In order to maintain it, Willem needs to perform m m m operations. There are four types of operations: 1 l r x 1\\ l\\ r\\ x 1 l r x : For each i i i such that l\u003c=i\u003c=r l\u003c=i\u003c=r l\u003c=i\u003c=r , assign ai+x a_{i}+x ai​+x to ai a_{i} ai​ . 2 l r x 2\\ l\\ r\\ x 2 l r x : For each i i i such that l\u003c=i\u003c=r l\u003c=i\u003c=r l\u003c=i\u003c=r , assign x x x to ai a_{i} ai​ . 3 l r x 3\\ l\\ r\\ x 3 l r x : Print the x x x -th smallest number in the index range [l,r] [l,r] [l,r] , i.e. the element at the x x x -th position if all the elements ai a_{i} ai​ such that l\u003c=i\u003c=r l\u003c=i\u003c=r l\u003c=i\u003c=r are taken and sorted into an array of non-decreasing integers. It’s guaranteed that 1\u003c=x\u003c=r−l+1 1\u003c=x\u003c=r-l+1 1\u003c=x\u003c=r−l+1 . 4 l r x y 4\\ l\\ r\\ x\\ y 4 l r x y : Print the sum of the x x x -th power of ai a_{i} ai​ such that l\u003c=i\u003c=r l\u003c=i\u003c=r l\u003c=i\u003c=r , modulo y y y , i.e. . 输入格式: The only line contains four integers n,m,seed,vmax n,m,seed,v_{max} n,m,seed,vmax​ ( 1\u003c=n,m\u003c=105,0\u003c=seed\u003c109+7,1\u003c=vmax\u003c=109 1\u003c=n,m\u003c=10^{5},0\u003c=seed\u003c10^{9}+7,1\u003c=vmax\u003c=10^{9} 1\u003c=n,m\u003c=105,0\u003c=seed\u003c109+7,1\u003c=vmax\u003c=109 ). The initial values and operations are generated using following pseudo code: def rnd(): ret = seed seed = (seed * 7 + 13) mod 1000000007 return ret for i = 1 to n: a[i] = (rnd() mod vmax) + 1 for i = 1 to m: op = (rnd() mod 4) + 1 l = (rnd() mod n) + 1 r = (rnd() mod n) + 1 if (l \u003e r): swap(l, r) if (op == 3): x = (rnd() mod (r - l + 1)) + 1 else: x = (rnd() mod vmax) + 1 if (op == 4): y = (rnd() mod vmax) + 1 Here op op op is the type of the operation mentioned in the legend. 输出格式: For each operation of types 3 3 3 or 4 4 4 , output a line containing the answer. 样例: 样例输入 1: 10 10 7 9 样例输出 1: 2 1 0 3 样例输入 2: 10 10 9 9 样例输出 2: 1 1 3 3 思路: 实现: #include \"ybwhead/ios.h\" const int mod = 1e9 + 7; const int maxn = 1e5 + 7; long long ksm(long long a, long long b, long long mod) { long long res = 1; long long ans = a % mod; while (b) { if (b \u0026 1) res = res * ans % mod; ans = ans * ans % mod; b \u003e\u003e= 1; } return res; } struct node { int l, r; mutable long long v; node(int L, int R = -1, long long V = 0) : l(L), r(R), v(V) {} bool operator\u003c(const node \u0026o) const { return l \u003c o.l; } }; typedef set\u003cnode\u003e::iterator IT; set\u003cnode\u003e s; IT split(int pos) { IT it = s.lower_bound(node(pos)); if (it != s.end() \u0026\u0026 it-\u003el == pos) return it; --it; int L = it-\u003el, R = it-\u003er; long long V = it-\u003ev; s.erase(it); s.insert(node(L, pos - 1, V)); return s.insert(node(pos, R, V)).first; } void add(int l, int r, long long val = 1) { IT itl = split(l), itr = split(r + 1); for (; itl != itr; ++itl) itl-\u003ev += val; } void assign_val(int l, int r, long long val = 0) { IT itl = split(l), itr = split(r + 1); s.erase(itl, itr); s.insert(node(l, r, val)); } long long rnk(int l, int r, int k) { vector\u003cpair\u003clong long, int\u003e\u003e vp; IT itl = split(l), itr = split(r + 1); vp.clear(); for (; itl != itr; ++itl) vp.push_back(pair\u003clong long, int\u003e(itl-\u003ev, itl-\u003er - itl-\u003el + 1)); std::sort(vp.begin(), vp.end()); for (vector\u003cpair\u003clong long, int\u003e\u003e::iterator it = vp.begin(); it != vp.end(); ++it) { k -= it-\u003esecond; if (k \u003c= 0) return it-\u003efirst; } return -1; } long long sum(int l, int r, int ex, int mod) { IT itl = split(l), itr = split(r + 1); long long res = 0; for (; itl != itr; ++itl) res = (res + (long long)(itl-\u003er - itl-\u003el + 1) * ksm(itl-\u003ev, (ex), (mod))) % mod; return res; } int n, m; long long seed, vmax; long long rnd() { long long ret = seed; seed = (seed * 7 + 13) % mod; return ret; } long long a[maxn]; int main() { yin \u003e\u003e n \u003e\u003e m \u003e\u003e seed \u003e\u003e vmax; for (int i = 1; i \u003c= n; ++i) { a[i] = (rnd() % vmax) + 1; s.insert(node(i, ","date":"2020-08-09","objectID":"/posts/oi/problems/cf896c/:0:0","series":null,"tags":["暴力数据结构","枚举,暴力","排序","构造","Notebooks/OI/OJ/Luogu"],"title":"CF896C-Willem, Chtholly and Seniorious","uri":"/posts/oi/problems/cf896c/#"},{"categories":null,"content":"P3380-【模板】二逼平衡树（树套树） 题目: 题目描述: 您需要写一种数据结构（可参考题目标题），来维护一个有序数列，其中需要提供以下操作： 查询 k 在区间内的排名 查询区间内排名为 k 的值 修改某一位值上的数值 查询 k 在区间内的前驱(前驱定义为严格小于 x，且最大的数，若不存在输出-2147483647) 查询 k 在区间内的后继(后继定义为严格大于 x，且最小的数，若不存在输出 2147483647) #注意上面两条要求和 tyvj 或者 bzoj 不一样，请注意 输入格式: 第一行两个数 n,m 表示长度为 n 的有序序列和 m 个操作 第二行有 n 个数，表示有序序列 下面有 m 行，opt 表示操作标号 若 opt=1 则为操作 1，之后有三个数 l,r,k 表示查询 k 在区间[l,r]的排名 若 opt=2 则为操作 2，之后有三个数 l,r,k 表示查询区间[l,r]内排名为 k 的数 若 opt=3 则为操作 3，之后有两个数 pos,k 表示将 pos 位置的数修改为 k 若 opt=4 则为操作 4，之后有三个数 l,r,k 表示查询区间[l,r]内 k 的前驱 若 opt=5 则为操作 5，之后有三个数 l,r,k 表示查询区间[l,r]内 k 的后继 输出格式: 对于操作 1,2,4,5 各输出一行，表示查询结果 样例: 样例输入 1: 9 6 4 2 2 1 9 4 0 1 1 2 1 4 3 3 4 10 2 1 4 3 1 2 5 9 4 3 9 5 5 2 8 5 样例输出 1: 2 4 3 4 9 思路: 实现: #include \"ybwhead/ios.h\" const int maxn = 5e6 + 10; struct fhq_treap { struct node { int ch[2], val; unsigned int pri, siz; }; static int tot; static node p[maxn]; int root; void update(int x) { p[x].siz = p[p[x].ch[0]].siz + p[p[x].ch[1]].siz + 1; } int new_node(int v) { p[++tot].siz = 1; p[tot].val = v; p[tot].pri = rand() * rand(); return tot; } int merge(int x, int y) { if (!x || !y) return x + y; if (p[x].pri \u003c p[y].pri) { p[x].ch[1] = merge(p[x].ch[1], y); update(x); // cout \u003c\u003c p[p[x].ch[1]].siz\u003c\u003c' '\u003c\u003cp[p[x]] \u003c\u003c endl; return x; } else { p[y].ch[0] = merge(x, p[y].ch[0]); update(y); // cout \u003c\u003c p[y].siz \u003c\u003c endl; return y; } } void split(int now, int k, int \u0026x, int \u0026y) { if (!now) { x = y = 0; return; } if (p[now].val \u003c= k) x = now, split(p[now].ch[1], k, p[now].ch[1], y); else y = now, split(p[now].ch[0], k, x, p[now].ch[0]); update(now); } int kth(int now, int k) { while (1) { if (k \u003c= p[p[now].ch[0]].siz) now = p[now].ch[0]; else if (k == p[p[now].ch[0]].siz + 1) return now; else k -= p[p[now].ch[0]].siz + 1, now = p[now].ch[1]; } } void insert(int x) { int xx, yy; split(root, x, xx, yy); root = merge(merge(xx, new_node(x)), yy); // cout \u003c\u003c p[root].siz \u003c\u003c endl; } void erase(int x) { int xx, yy, zz; split(root, x, xx, yy); split(xx, x - 1, xx, zz); zz = merge(p[zz].ch[0], p[zz].ch[1]); root = merge(merge(xx, zz), yy); } int rank(int x) { int xx, yy; split(root, x - 1, xx, yy); int zz = p[xx].siz + 1; root = merge(xx, yy); return zz; } int kkth(int x) { // cout \u003c\u003c root \u003c\u003c endl; return p[kth(root, x)].val; } int lower(int x) { int xx, yy; // cout \u003c\u003c x \u003c\u003c endl; split(root, x - 1, xx, yy); // puts(\"1\"); // cout \u003c\u003c kth(xx, p[xx].siz) \u003c\u003c endl; int zz = p[kth(xx, p[xx].siz)].val; root = merge(xx, yy); return zz; } int upper(int x) { int xx, yy; split(root, x, xx, yy); int zz = p[kth(yy, 1)].val; // cout \u003c\u003c kth(yy, 1) \u003c\u003c endl; root = merge(xx, yy); return zz; } }; struct Seg { struct node { fhq_treap x; int ls, rs; } x[maxn \u003e\u003e 2]; int tot; void insert(int \u0026p, int d, int y, int l = 1, int r = 1e9) { if (!p) p = ++tot; x[p].x.insert(y); if (l == r) return; int mid = (l + r) \u003e\u003e 1; if (d \u003c= mid) insert(x[p].ls, d, y, l, mid); else insert(x[p].rs, d, y, mid + 1, r); } void erase(int p, int d, int y, int l = 1, int r = 1e9) { x[p].x.erase(y); if (l == r) return; int mid = (l + r) \u003e\u003e 1; if (d \u003c= mid) erase(x[p].ls, d, y, l, mid); else erase(x[p].rs, d, y, mid + 1, r); } int kth(int p, int ll, int rr, int l_, int r_, int l = 1, int r = 1e9) { if (!p) return 0; if (l == ll \u0026\u0026 rr == r) { int yy = x[p].x.rank(r_ + 1) - x[p].x.rank(l_); return yy; } int mid = l + r \u003e\u003e 1; if (rr \u003c= mid) return kth(x[p].ls, ll, rr, l_, r_, l, mid); else if (ll \u003e mid + 1) return kth(x[p].rs, ll, rr, l_, r_, mid + 1, r); else return kth(x[p].ls, ll, mid, l_, r_, l, mid) + kth(x[p].rs, mid + 1, rr, l_, r_, mid + 1, r); } int rank(int p, int k, int ll, int rr, int l = 1, int r = 1e9) { if (l == r) return l; int ls = x[x[p].ls].x.rank(rr + 1) - x[x[p].ls].x.rank(ll); // yout \u003c\u003c ls \u003c\u003c ' ' \u003c\u003c k \u003c\u003c \" \" \u003c\u003c l \u003c\u003c \" \" \u003c\u003c r \u003c\u003c endl; int mid = l + r \u003e\u003e 1; if (ls \u003c k) return rank(x[p].rs, k - ls, ll, rr, mid + 1, r); else return rank(x[p].ls, k, ll, rr, l, mid); } } seg; int root; int n, m; int a[maxn \u003e\u003e 2]; int fhq_treap::tot = 0; fhq_treap::node fhq_treap::p[maxn]; int main() { yin \u003e\u003e n \u003e\u003e m; f","date":"2020-08-09","objectID":"/posts/oi/problems/p3380/:0:0","series":null,"tags":["树套树","高性能","Notebooks/OI/OJ/Luogu"],"title":"P3380-【模板】二逼平衡树（树套树）","uri":"/posts/oi/problems/p3380/#"},{"categories":null,"content":"CF1393D-Rarity and New Dress 题目: 题目描述: Carousel Boutique is busy again! Rarity has decided to visit the pony ball and she surely needs a new dress, because going out in the same dress several times is a sign of bad manners. First of all, she needs a dress pattern, which she is going to cut out from the rectangular piece of the multicolored fabric. The piece of the multicolored fabric consists of n×m n \\times m n×m separate square scraps. Since Rarity likes dresses in style, a dress pattern must only include scraps sharing the same color. A dress pattern must be the square, and since Rarity is fond of rhombuses, the sides of a pattern must form a 45∘ 45^{\\circ} 45∘ angle with sides of a piece of fabric (that way it will be resembling the traditional picture of a rhombus). Examples of proper dress patterns: Examples of improper dress patterns: The first one consists of multi-colored scraps, the second one goes beyond the bounds of the piece of fabric, the third one is not a square with sides forming a 45∘ 45^{\\circ} 45∘ angle with sides of the piece of fabric. Rarity wonders how many ways to cut out a dress pattern that satisfies all the conditions that do exist. Please help her and satisfy her curiosity so she can continue working on her new masterpiece! 输入格式: The first line contains two integers n n n and m m m ( 1≤n,m≤2000 1 \\le n, m \\le 2000 1≤n,m≤2000 ). Each of the next n n n lines contains m m m characters: lowercase English letters, the j j j -th of which corresponds to scrap in the current line and in the j j j -th column. Scraps having the same letter share the same color, scraps having different letters have different colors. 输出格式: Print a single integer: the number of ways to cut out a dress pattern to satisfy all of Rarity’s conditions. 样例: 样例输入 1: 3 3 aaa aaa aaa 样例输出 1: 10 样例输入 2: 3 4 abab baba abab 样例输出 2: 12 样例输入 3: 5 5 zbacg baaac aaaaa eaaad weadd 样例输出 3: 31 思路: 实现: #include \"ybwhead/ios.h\" int n, m; const int maxn = 2e3 + 10; string s[maxn]; long long ans; int nxt[maxn][maxn], nxt1[maxn][maxn], uu[maxn][maxn], dd[maxn][maxn]; int main() { yin \u003e\u003e n \u003e\u003e m; for (int i = 1; i \u003c= n; ++i) { yin \u003e\u003e s[i]; nxt[i][1] = 1; for (int j = 2; j \u003c= m; j++) { if (s[i][j - 2] == s[i][j - 1]) nxt[i][j] = nxt[i][j - 1] + 1; else nxt[i][j] = 1; } nxt1[i][m] = 1; for (int j = m; j \u003e= 2; j--) { if (s[i][j - 1] == s[i][j - 2]) nxt1[i][j - 1] = nxt1[i][j] + 1; else nxt1[i][j - 1] = 1; } } for (int i = 1; i \u003c= n; i++) { for (int j = 1; j \u003c= m; j++) { int u, d, l, r; if (s[i][j - 1] == s[i - 1][j - 1]) u = uu[i - 1][j] + 1; else u = 1; l = nxt[i][j]; r = nxt1[i][j]; uu[i][j] = min(min(l, r), u); } } for (int i = n; i \u003e= 1; i--) { for (int j = 1; j \u003c= m; j++) { int u, d, l, r; if (s[i][j - 1] == s[i + 1][j - 1]) u = dd[i + 1][j] + 1; else u = 1; l = nxt[i][j]; r = nxt1[i][j]; dd[i][j] = min(min(l, r), u); } } for (int i = 1; i \u003c= n; i++) { for (int j = 1; j \u003c= m; j++) { ans += min(uu[i][j], dd[i][j]); } } yout \u003c\u003c ans \u003c\u003c endl; return 0; } ","date":"2020-08-08","objectID":"/posts/oi/problems/cf1393d/:0:0","series":null,"tags":["Notebooks/OI/OJ/Luogu"],"title":"CF1393D-Rarity and New Dress","uri":"/posts/oi/problems/cf1393d/#"},{"categories":null,"content":"CF1393C-Pinkie Pie Eats Patty-cakes 题目: 题目描述: Pinkie Pie has bought a bag of patty-cakes with different fillings! But it appeared that not all patty-cakes differ from one another with filling. In other words, the bag contains some patty-cakes with the same filling. Pinkie Pie eats the patty-cakes one-by-one. She likes having fun so she decided not to simply eat the patty-cakes but to try not to eat the patty-cakes with the same filling way too often. To achieve this she wants the minimum distance between the eaten with the same filling to be the largest possible. Herein Pinkie Pie called the distance between two patty-cakes the number of eaten patty-cakes strictly between them. Pinkie Pie can eat the patty-cakes in any order. She is impatient about eating all the patty-cakes up so she asks you to help her to count the greatest minimum distance between the eaten patty-cakes with the same filling amongst all possible orders of eating! Pinkie Pie is going to buy more bags of patty-cakes so she asks you to solve this problem for several bags! 输入格式: The first line contains a single integer T T T ( 1≤T≤100 1 \\le T \\le 100 1≤T≤100 ): the number of bags for which you need to solve the problem. The first line of each bag description contains a single integer n n n ( 2≤n≤105 2 \\le n \\le 10^5 2≤n≤105 ): the number of patty-cakes in it. The second line of the bag description contains n n n integers a1,a2,…,an a_1, a_2, \\ldots, a_n a1​,a2​,…,an​ ( 1≤ai≤n 1 \\le a_i \\le n 1≤ai​≤n ): the information of patty-cakes’ fillings: same fillings are defined as same integers, different fillings are defined as different integers. It is guaranteed that each bag contains at least two patty-cakes with the same filling. It is guaranteed that the sum of n n n over all bags does not exceed 105 10^5 105 . 输出格式: For each bag print in separate line one single integer: the largest minimum distance between the eaten patty-cakes with the same filling amongst all possible orders of eating for that bag. 样例: 样例输入 1: 4 7 1 7 1 6 4 4 6 8 1 1 4 6 4 6 4 7 3 3 3 3 6 2 5 2 3 1 4 样例输出 1: 3 2 0 4 思路: 实现: #include \"ybwhead/ios.h\" int n; const int maxn = 1e5 + 10; int a[maxn]; int check(int x) { int j = 1; for (int i = n; i \u003e= 1; i--) { if (!a[i]) return 1; if (j + (long long)(a[i] - 1) * x \u003e n) return 0; ++j; } } int main() { int TTT; yin \u003e\u003e TTT; while (TTT--) { yin \u003e\u003e n; for (int i = 1; i \u003c= n; i++) a[i] = 0; for (int i = 1; i \u003c= n; i++) { int x; yin \u003e\u003e x; a[x]++; } sort(a + 1, a + n + 1); int l = 0, r = n; while (l \u003c r) { int mid = l + r + 1 \u003e\u003e 1; if (check(mid)) l = mid; else r = mid - 1; } yout \u003c\u003c l - 1 \u003c\u003c endl; } return 0; } ","date":"2020-08-08","objectID":"/posts/oi/problems/cf1393c/:0:0","series":null,"tags":["Notebooks/OI/OJ/Luogu"],"title":"CF1393C-Pinkie Pie Eats Patty-cakes","uri":"/posts/oi/problems/cf1393c/#"},{"categories":null,"content":"CF1393B-Applejack and Storages 题目: 题目描述: This year in Equestria was a year of plenty, so Applejack has decided to build some new apple storages. According to the advice of the farm designers, she chose to build two storages with non-zero area: one in the shape of a square and another one in the shape of a rectangle (which possibly can be a square as well). Applejack will build the storages using planks, she is going to spend exactly one plank on each side of the storage. She can get planks from her friend’s company. Initially, the company storehouse has n n n planks, Applejack knows their lengths. The company keeps working so it receives orders and orders the planks itself. Applejack’s friend can provide her with information about each operation. For convenience, he will give her information according to the following format: + + + x x x : the storehouse received a plank with length x x x − - − x x x : one plank with length x x x was removed from the storehouse (it is guaranteed that the storehouse had some planks with length x x x ). Applejack is still unsure about when she is going to order the planks so she wants to know if she can order the planks to build rectangular and square storages out of them after every event at the storehouse. Applejack is busy collecting apples and she has completely no time to do the calculations so she asked you for help! We remind you that all four sides of a square are equal, and a rectangle has two pairs of equal sides. 输入格式: The first line contains a single integer n n n ( 1≤n≤105 1 \\le n \\le 10^5 1≤n≤105 ): the initial amount of planks at the company’s storehouse, the second line contains n n n integers a1,a2,…,an a_1, a_2, \\ldots, a_n a1​,a2​,…,an​ ( 1≤ai≤105 1 \\le a_i \\le 10^5 1≤ai​≤105 ): the lengths of the planks. The third line contains a single integer q q q ( 1≤q≤105 1 \\le q \\le 10^5 1≤q≤105 ): the number of events in the company. Each of the next q q q lines contains a description of the events in a given format: the type of the event (a symbol + + + or − - − ) is given first, then goes the integer x x x ( 1≤x≤105 1 \\le x \\le 10^5 1≤x≤105 ). 输出格式: After every event in the company, print “YES” if two storages of the required shape can be built from the planks of that company’s set, and print “NO” otherwise. You can print each letter in any case (upper or lower). 样例: 样例输入 1: 6 1 1 1 2 1 1 6 + 2 + 1 - 1 + 2 - 1 + 2 样例输出 1: NO YES NO NO NO YES 思路: 实现: #include \"ybwhead/ios.h\" int n; int ans, ans1; const int maxn = 1e5 + 10; int a[maxn]; int main() { yin \u003e\u003e n; for (int i = 1; i \u003c= n; i++) { int x; yin \u003e\u003e x; a[x]++; if (a[x] == 2) ++ans; if (a[x] == 4) ++ans1, --ans; if (a[x] == 6) ++ans; if (a[x] == 8) ++ans1, --ans; } bool f = 0; if (ans1 \u003e= 2 || ans \u003e= 2 \u0026\u0026 ans1 == 1) f = 1; int TTT; yin \u003e\u003e TTT; while (TTT--) { char c; int x; yin \u003e\u003e c \u003e\u003e x; if (c == '+') { a[x]++; if (a[x] == 2) ++ans; if (a[x] == 4) ++ans1, --ans; if (a[x] == 6) ++ans; if (a[x] == 8) --ans, ++ans1; if (ans1 \u003e= 2 || ans \u003e= 2 \u0026\u0026 ans1 == 1) f = 1; else f = 0; } else { if (a[x] == 2) --ans; if (a[x] == 4) --ans1, ++ans; if (a[x] == 6) --ans; if (a[x] == 8) --ans1, ++ans; a[x]--; if (ans1 \u003e= 2 || ans \u003e= 2 \u0026\u0026 ans1 == 1) f = 1; else f = 0; } if (f) puts(\"YES\"); else puts(\"NO\"); } return 0; } ","date":"2020-08-08","objectID":"/posts/oi/problems/cf1393b/:0:0","series":null,"tags":["Notebooks/OI/OJ/Luogu"],"title":"CF1393B-Applejack and Storages","uri":"/posts/oi/problems/cf1393b/#"},{"categories":null,"content":"CF1393A-Rainbow Dash, Fluttershy and Chess Coloring 题目: 题目描述: One evening Rainbow Dash and Fluttershy have come up with a game. Since the ponies are friends, they have decided not to compete in the game but to pursue a common goal. The game starts on a square flat grid, which initially has the outline borders built up. Rainbow Dash and Fluttershy have flat square blocks with size 1×1 1\\times1 1×1 , Rainbow Dash has an infinite amount of light blue blocks, Fluttershy has an infinite amount of yellow blocks. The blocks are placed according to the following rule: each newly placed block must touch the built on the previous turns figure by a side (note that the outline borders of the grid are built initially). At each turn, one pony can place any number of blocks of her color according to the game rules. Rainbow and Fluttershy have found out that they can build patterns on the grid of the game that way. They have decided to start with something simple, so they made up their mind to place the blocks to form a chess coloring. Rainbow Dash is well-known for her speed, so she is interested in the minimum number of turns she and Fluttershy need to do to get a chess coloring, covering the whole grid with blocks. Please help her find that number! Since the ponies can play many times on different boards, Rainbow Dash asks you to find the minimum numbers of turns for several grids of the games. The chess coloring in two colors is the one in which each square is neighbor by side only with squares of different colors. 输入格式: The first line contains a single integer T T T ( 1≤T≤100 1 \\le T \\le 100 1≤T≤100 ): the number of grids of the games. Each of the next T T T lines contains a single integer n n n ( 1≤n≤109 1 \\le n \\le 10^9 1≤n≤109 ): the size of the side of the grid of the game. 输出格式: For each grid of the game print the minimum number of turns required to build a chess coloring pattern out of blocks on it. 样例: 样例输入 1: 2 3 4 样例输出 1: 2 3 思路: 实现: #include \"ybwhead/ios.h\" int main() { int TTT; yin \u003e\u003e TTT; while (TTT--) { int n; yin \u003e\u003e n; yout \u003c\u003c (n / 2) + 1 \u003c\u003c endl; } return 0; } ","date":"2020-08-08","objectID":"/posts/oi/problems/cf1393a/:0:0","series":null,"tags":["Notebooks/OI/OJ/Luogu"],"title":"CF1393A-Rainbow Dash, Fluttershy and Chess Coloring","uri":"/posts/oi/problems/cf1393a/#"},{"categories":null,"content":"P4721-【模板】分治 FFT 题目: 题目描述: 给定序列 g1…n−1g_{1\\dots n - 1}g1…n−1​，求序列 f0…n−1f_{0\\dots n - 1}f0…n−1​。 其中 fi=∑j=1ifi−jgjf_i=\\sum_{j=1}^if_{i-j}g_jfi​=∑j=1i​fi−j​gj​，边界为 f0=1f_0=1f0​=1。 答案对 998244353998244353998244353 取模。 输入格式: 第一行一个整数 nnn 。 第二行 n−1n-1n−1 个整数 g1…n−1g_{1\\dots n - 1}g1…n−1​。 输出格式: 一行 nnn 个整数，表示 f0…n−1f_{0\\dots n - 1}f0…n−1​ 对 998244353998244353998244353 取模后的值。 样例: 样例输入 1: 4 3 1 2 样例输出 1: 1 3 10 35 样例输入 2: 10 2 456 32 13524543 998244352 0 1231 634544 51 样例输出 2: 1 2 460 1864 13738095 55389979 617768468 234028967 673827961 708520894 思路: 实现: #include \"ybwhead/ios.h\" int n, lim, l; const int maxn = 1e6 + 10; long long a[maxn], b[maxn]; int r[maxn]; const int mod = 998244353; long long c[maxn]; long long ksm(long long a, int n) { long long ans = 1; while (n) { if (n \u0026 1) ans = ans * a % mod; a = a * a % mod; n \u003e\u003e= 1; } return ans; } const int g = 3, gi = 332748118; void ntt(long long a[], long long x) { for (int i = 0; i \u003c lim; i++) if (i \u003c r[i]) swap(a[i], a[r[i]]); for (int o = 2, k = 1; o \u003c= lim; o \u003c\u003c= 1, k \u003c\u003c= 1) { long long wn = ksm(x, (mod - 1) / (o)); for (int i = 0; i \u003c lim; i += o) { long long w = 1; for (int j = 0; j \u003c k; j++, w = w * wn % mod) { long long x = a[i + j], y = a[i + j + k] * w % mod; a[j + i] = (x + y) % mod; a[j + k + i] = (x - y + mod) % mod; } } } } void calc(int n, long long b[]) { if (n == 1) { b[0] = ksm(a[0], mod - 2); // yout\u003c\u003ca[0] return; } calc((n + 1) \u003e\u003e 1, b); lim = 1; l = 0; while (lim \u003c (n \u003c\u003c 1)) lim \u003c\u003c= 1, ++l; // yout\u003c\u003clim\u003c\u003c\" \"\u003c\u003ca[1]\u003c\u003cendl; for (int i = 0; i \u003c lim; i++) r[i] = (r[i \u003e\u003e 1] \u003e\u003e 1) | ((i \u0026 1) \u003c\u003c (l - 1)); for (int i = 0; i \u003c n; i++) c[i] = a[i]; for (int i = n; i \u003c lim; i++) c[i] = 0; ntt(c, g); ntt(b, g); for (int i = 0; i \u003c lim; i++) { b[i] = (2 - c[i] * b[i] % mod + mod) % mod * b[i] % mod; // yout\u003c\u003cb[i]\u003c\u003cendl; } ntt(b, gi); long long inv = ksm(lim, mod - 2); for (int i = 0; i \u003c n; i++) b[i] = (b[i] * inv) % mod; for (int i = n; i \u003c lim; i++) b[i] = 0; } int main() { yin \u003e\u003e n; for (int i = 1; i \u003c n; i++) yin \u003e\u003e a[i], a[i] = mod - a[i]; a[0] = 1; // while (lim\u003cn)lim\u003c\u003c=1, l++; calc(n, b); for (int i = 0; i \u003c n; i++) yout \u003c\u003c (b[i] + mod) % mod \u003c\u003c \" \"; yout \u003c\u003c endl; return 0; } ","date":"2020-08-08","objectID":"/posts/oi/problems/p4721/:0:0","series":null,"tags":["分治","生成函数","逆元","快速傅里叶变换,DFT,FFT","高性能","快速数论变换NTT","Notebooks/OI/OJ/Luogu"],"title":"P4721-【模板】分治 FFT","uri":"/posts/oi/problems/p4721/#"},{"categories":null,"content":"P3507-[POI2010]GRA-The Minima Game 题目: 题目描述: Alice and Bob learned the minima game, which they like very much, recently. The rules of the game are as follows. A certain number of cards lies on a table, each inscribed with a positive integer. The players make alternate moves, Alice making the first one. A move consists in picking an arbitrary positive number of cards from the table. For such move the player receives a number of points equal to the minimum of the numbers inscribed on the cards he collected. The game ends when the last card is removed from the table. The goal of each player is maximizing the difference between their and their opponent’s score. Alice and Bob have duly noted that there is an optimal strategy in the game. Thus they are asking you to write a program that, for a given set of cards, determines the outcome of the game when both players play optimally. 给出 N 个正整数，AB 两个人轮流取数，A 先取。每次可以取任意多个数，直到 N 个数都被取走。每次获得的得分为取的数中的最小值，A 和 B 的策略都是尽可能使得自己的得分减去对手的得分更大。在这样的情况下，最终 A 的得分减去 B 的得分为多少。 输入格式: In the first line of the standard input there is one integer () given, denoting the number of cards. The second line holds positive integers () , separated by single spaces, that are inscribed on the cards. 输出格式: Your program should print out a single line with a single integer to the standard output - the number of points by which Alice wins over Bob, assuming they both play optimally; if it is Bob who has more points, the result should be negative. 样例: 样例输入 1: 3 1 3 1 样例输出 1: 2 思路: 实现: #include \"ybwhead/ios.h\" int n; const int maxn = 1e6 + 10; int a[maxn]; int f[maxn]; int main() { yin \u003e\u003e n; for (int i = 1; i \u003c= n; i++) yin \u003e\u003e a[i]; sort(a + 1, a + n + 1); for (int i = 1; i \u003c= n; i++) f[i] = max(f[i - 1], a[i] - f[i - 1]); yout \u003c\u003c f[n] \u003c\u003c endl; } ","date":"2020-08-08","objectID":"/posts/oi/problems/p3507/:0:0","series":null,"tags":["模拟","dp","贪心",2010,"POI","高性能","Notebooks/OI/OJ/Luogu"],"title":"P3507-[POI2010]GRA-The Minima Game","uri":"/posts/oi/problems/p3507/#"},{"categories":null,"content":"P2964-[USACO09NOV]A Coin Game S 题目: 题目描述: 小 A 和小 B 在玩游戏。 初始时，有 nnn 个硬币被摆成了一行，从左至右第 iii 个硬币的价值为 cic_ici​。 游戏的规则是，两人交替从这堆硬币的左侧连续取出若干硬币，然后将取出的硬币的价值累加至自己获得的累计价值中。若对方上次操作取出了 kkk 个硬币，那么本次自己最多取出 k×2k \\times 2k×2 个硬币。当没有硬币可取时，游戏结束。 游戏开始时，由小 A 先动手取硬币，最多取出 222 个硬币。 请求出当双方都尽可能使自己的累计价值最大的情况下，小 A 能获得的累计价值最大是多少。 输入格式: 输入的第一行是一个整数 nnn，代表硬币的个数。 第 222 到第 (n+1)(n + 1)(n+1) 行，每行一个整数，第 (i+1)(i + 1)(i+1) 行的整数代表第 iii 个硬币的价值 cic_ici​。 输出格式: 输出一行一个整数，代表小 A 能获得的最大累计价值。 样例: 样例输入 1: 5 1 3 1 7 2 样例输出 1: 9 思路: 实现: #include \"ybwhead/ios.h\" const int maxn = 2e3 + 10; int a[maxn]; int sum[maxn]; int dp[maxn][maxn]; int n; int main() { yin \u003e\u003e n; for (int i = 1; i \u003c= n; i++) yin \u003e\u003e a[i]; reverse(a + 1, a + n + 1); for (int i = 1; i \u003c= n; i++) sum[i] = sum[i - 1] + a[i]; for (int i = 1; i \u003c= n; i++) { for (int j = 1; j \u003c= n; j++) { dp[i][j] = dp[i][j - 1]; int k = j \u003c\u003c 1; if (k \u003c= i) dp[i][j] = max(dp[i][j], sum[i] - dp[i - k][k]); k--; if (k \u003c= i) dp[i][j] = max(dp[i][j], sum[i] - dp[i - k][k]); } } yout \u003c\u003c dp[n][1] \u003c\u003c endl; return 0; } ","date":"2020-08-08","objectID":"/posts/oi/problems/p2964/:0:0","series":null,"tags":["dp","博弈论",2009,"USACO","Notebooks/OI/OJ/Luogu"],"title":"P2964-[USACO09NOV]A Coin Game S","uri":"/posts/oi/problems/p2964/#"},{"categories":null,"content":"SP1812-LCS2 - Longest Common Substring II 题目: 题目描述: A string is finite sequence of characters over a non-empty finite set Σ. In this problem, Σ is the set of lowercase letters. Substring, also called factor, is a consecutive sequence of characters occurrences at least once in a string. Now your task is a bit harder, for some given strings, find the length of the longest common substring of them. Here common substring means a substring of two or more strings. 输入格式: The input contains at most 10 lines, each line consists of no more than 100000 lowercase letters, representing a string. 输出格式: The length of the longest common substring. If such string doesn’t exist, print “0” instead. 样例: 样例输入 1: alsdfkjfjkdsal fdjskalajfkdsla aaaajfaaaa 样例输出 1: 2 思路: 实现: #include \"ybwhead/ios.h\" using namespace std; const int maxn = 1e6 + 10; int nl; struct SAM { struct node { int len, fa, mp[26], mx, mi; } x[maxn]; int las, cnt; SAM() { las = cnt = 1; } void insert(int c) { int p = las; x[las = ++cnt] = {nl, 0, {0}, 0, INT_MAX}; for (; p \u0026\u0026 !x[p].mp[c]; p = x[p].fa) x[p].mp[c] = las; if (!p) { x[las].fa = 1; return; } int q = x[p].mp[c]; if (x[q].len == x[p].len + 1) { x[las].fa = q; return; } x[++cnt] = x[q]; x[cnt].len = x[p].len + 1; x[q].fa = x[las].fa = cnt; for (; x[p].mp[c] == q; p = x[p].fa) x[p].mp[c] = cnt; } int a[maxn]; void search(string s) { int ans = 0, p = 1, tot = 0; for (int i = 0; i \u003c s.size(); i++) { if (x[p].mp[s[i] - 'a']) { ++tot; p = x[p].mp[s[i] - 'a']; } else { for (; p \u0026\u0026 !x[p].mp[s[i] - 'a']; p = x[p].fa) ; if (p) tot = x[p].len + 1, p = x[p].mp[s[i] - 'a']; else p = 1, tot = 0; } x[p].mx = max(x[p].mx, tot); } for (int i = 1; i \u003c= cnt; i++) { int p = a[i]; x[x[p].fa].mx = max(x[x[p].fa].mx, min(x[p].mx, x[x[p].fa].len)); x[p].mi = min(x[p].mi, x[p].mx); x[p].mx = 0; } } } s; string s1; int cmp(int a, int b) { return s.x[a].len \u003e s.x[b].len; } int main() { yin \u003e\u003e s1; for (nl = 1; nl \u003c= s1.size(); nl++) s.insert(s1[nl - 1] - 'a'); for (int i = 1; i \u003c= s.cnt; i++) s.a[i] = i; sort(s.a + 1, s.a + s.cnt + 1, cmp); while (cin \u003e\u003e s1) { if (!s1.size()) break; // yout \u003c\u003c s1 \u003c\u003c endl; s.search(s1); } int ans = 0; for (int i = 1; i \u003c= s.cnt; i++) ans = max(ans, s.x[i].mi); yout \u003c\u003c ans \u003c\u003c endl; return 0; } ","date":"2020-08-08","objectID":"/posts/oi/problems/sp1812/:0:0","series":null,"tags":["字符串","后缀自动机,SAM","概率论,统计","后缀数组,SA","Notebooks/OI/OJ/Luogu"],"title":"SP1812-LCS2 - Longest Common Substring II","uri":"/posts/oi/problems/sp1812/#"},{"categories":null,"content":"SP1811-LCS - Longest Common Substring 题目: 题目描述: A string is finite sequence of characters over a non-empty finite set Σ. In this problem, Σ is the set of lowercase letters. Substring, also called factor, is a consecutive sequence of characters occurrences at least once in a string. Now your task is simple, for two given strings, find the length of the longest common substring of them. Here common substring means a substring of two or more strings. 输入格式: The input contains exactly two lines, each line consists of no more than 250000 lowercase letters, representing a string. 输出格式: The length of the longest common substring. If such string doesn’t exist, print “0” instead. 样例: 样例输入 1: alsdfkjfjkdsal fdjskalajfkdsla 样例输出 1: 3 思路: 实现: #include \"ybwhead/ios.h\" using namespace std; const int maxn = 1e6 + 10; int nl; struct SAM { struct node { int len, fa, mp[26]; } x[maxn]; int las, cnt; SAM() { las = cnt = 1; } void insert(int c) { int p = las; x[las = ++cnt] = {nl, 0, {0}}; for (; p \u0026\u0026 !x[p].mp[c]; p = x[p].fa) x[p].mp[c] = las; if (!p) { x[las].fa = 1; return; } int q = x[p].mp[c]; if (x[q].len == x[p].len + 1) { x[las].fa = q; return; } x[++cnt] = x[q]; x[cnt].len = x[p].len + 1; x[q].fa = x[las].fa = cnt; for (; x[p].mp[c] == q; p = x[p].fa) x[p].mp[c] = cnt; } int search(string s) { int ans = 0, p = 1, tot = 0; for (int i = 0; i \u003c s.size(); i++) { if (x[p].mp[s[i] - 'a']) { ++tot; p = x[p].mp[s[i] - 'a']; } else { for (; p \u0026\u0026 !x[p].mp[s[i] - 'a']; p = x[p].fa) ; if (p) tot = x[p].len + 1, p = x[p].mp[s[i] - 'a']; else p = 1, tot = 0; } ans = max(ans, tot); } return ans; } } s; string s1, s2; int main() { yin \u003e\u003e s1 \u003e\u003e s2; for (nl = 1; nl \u003c= s1.size(); nl++) s.insert(s1[nl - 1] - 'a'); yout \u003c\u003c s.search(s2) \u003c\u003c endl; return 0; } ","date":"2020-08-08","objectID":"/posts/oi/problems/sp1811/:0:0","series":null,"tags":["字符串","后缀自动机,SAM","后缀数组,SA","构造","Notebooks/OI/OJ/Luogu"],"title":"SP1811-LCS - Longest Common Substring","uri":"/posts/oi/problems/sp1811/#"},{"categories":null,"content":"SP7258-SUBLEX - Lexicographical Substring Search 题目: 题目描述: Little Daniel loves to play with strings! He always finds different ways to have fun with strings! Knowing that, his friend Kinan decided to test his skills so he gave him a string S and asked him Q questions of the form: If all distinct substrings of string S were sorted lexicographically, which one will be the K-th smallest? After knowing the huge number of questions Kinan will ask, Daniel figured out that he can’t do this alone. Daniel, of course, knows your exceptional programming skills, so he asked you to write him a program which given S will answer Kinan’s questions. Example: S = “aaa” (without quotes) substrings of S are “a” , “a” , “a” , “aa” , “aa” , “aaa”. The sorted list of substrings will be: “a”, “aa”, “aaa”. Input In the first line there is Kinan’s string S (with length no more than 90000 characters). It contains only small letters of English alphabet. The second line contains a single integer Q (Q \u003c= 500) , the number of questions Daniel will be asked. In the next Q lines a single integer K is given (0 \u003c K \u003c 2^31). Output Output consists of Q lines, the i-th contains a string which is the answer to the i-th asked question. 输入格式: 输出格式: 样例: 样例输入 1: aaa 2 2 3 样例输出 1: aa aaa 思路: 实现: #include \u003ccstdio\u003e #include \u003ccstring\u003e typedef long long LL; const int MAXN = 90005; template \u003ctypename _T\u003e void read(_T \u0026x) { x = 0; char s = getchar(); int f = 1; while (s \u003c '0' || '9' \u003c s) { f = 1; if (s == '-') f = -1; s = getchar(); } while ('0' \u003c= s \u0026\u0026 s \u003c= '9') { x = (x \u003c\u003c 3) + (x \u003c\u003c 1) + s - '0', s = getchar(); } x *= f; } template \u003ctypename _T\u003e void write(_T x) { if (x \u003c 0) { putchar('-'), x = -x; } if (9 \u003c x) { write(x / 10); } putchar(x % 10 + '0'); } LL f[MAXN \u003c\u003c 1]; int cnt[MAXN \u003c\u003c 1], seq[MAXN \u003c\u003c 1]; char A[MAXN], res[MAXN]; int ch[MAXN \u003c\u003c 1][26], fa[MAXN \u003c\u003c 1], mx[MAXN \u003c\u003c 1]; int N, Q, K, rt, lst, tot, len; void copy(const int a, const int b) { fa[a] = fa[b], mx[a] = mx[b], memcpy(ch[a], ch[b], sizeof ch[a]); } void expand(const char c) { int x = c - 'a', p = lst, cur = ++tot; mx[cur] = mx[p] + 1, lst = cur; while (p \u0026\u0026 !ch[p][x]) ch[p][x] = cur, p = fa[p]; if (!p) { fa[cur] = rt; return; } int q = ch[p][x]; if (mx[q] == mx[p] + 1) { fa[cur] = q; return; } int nq = ++tot; copy(nq, q); mx[nq] = mx[p] + 1, fa[cur] = fa[q] = nq; while (p \u0026\u0026 ch[p][x] == q) ch[p][x] = nq, p = fa[p]; } void topo() { for (int i = 1; i \u003c= tot; i++) cnt[mx[i]]++; for (int i = 1; i \u003c= tot; i++) cnt[i] += cnt[i - 1]; for (int i = tot; i; i--) seq[cnt[mx[i]]--] = i; } void DFS(const int u, int rnk) { if (!rnk) return; int v; for (int i = 0; i \u003c 26; i++) { if (!(v = ch[u][i])) continue; if (rnk \u003c= f[v]) { putchar('a' + i), DFS(v, rnk - 1); return; } else rnk -= f[v]; } } int main() { scanf(\"%s\", A + 1); N = strlen(A + 1); rt = lst = ++tot; for (int i = 1; i \u003c= N; i++) expand(A[i]); topo(); for (int i = tot, u; i; i--) { u = seq[i]; //一定要用拓扑序来dp! if (i \u003e 1) f[u] = 1; for (int j = 0; j \u003c 26; j++) if (ch[u][j]) f[u] += f[ch[u][j]]; } read(Q); while (Q--) { read(K); DFS(1, K), putchar('\\n'); } return 0; } ","date":"2020-08-08","objectID":"/posts/oi/problems/sp7258/:0:0","series":null,"tags":["Notebooks/OI/OJ/Luogu"],"title":"SP7258-SUBLEX - Lexicographical Substring Search","uri":"/posts/oi/problems/sp7258/#"},{"categories":null,"content":"P3975-[TJOI2015]弦论 题目: 题目描述: 为了提高智商，ZJY 开始学习弦论。这一天，她在《String theory》中看到了这样一道问题：对于一个给定的长度为 nnn 的字符串，求出它的第 kkk 小子串是什么。你能帮帮她吗? 输入格式: 第一行是一个仅由小写英文字母构成的字符串 sss。 第二行为两个整数 ttt 和 kkk，ttt 为 000 则表示不同位置的相同子串算作一个，ttt 为 111 则表示不同位置的相同子串算作多个。kkk 的意义见题目描述。 输出格式: 输出数据仅有一行,该行有一个字符串，为第 kkk 小的子串。若子串数目不足 kkk 个，则输出 −1-1−1。 样例: 样例输入 1: aabc 0 3 样例输出 1: aab 样例输入 2: aabc 1 3 样例输出 2: aa 样例输入 3: aabc 1 11 样例输出 3: -1 思路: 实现: #include \"ybwhead/ios.h\" int nl, flag; int k; const int maxn = 1e6 + 10; struct SAM { struct node { int fa, len; int siz, mp[26]; int sum; } x[maxn \u003c\u003c 1]; int las, cnt; SAM() { las = cnt = 1; } void insert(int c) { int p = las; x[las = ++cnt] = {0, nl, 1, {0}, 0}; for (; p \u0026\u0026 !x[p].mp[c]; p = x[p].fa) x[p].mp[c] = las; if (!p) { x[las].fa = 1; return; } int q = x[p].mp[c]; if (x[q].len == x[p].len + 1) { x[las].fa = q; return; } x[++cnt] = x[q]; x[cnt].len = x[p].len + 1; x[cnt].siz = 0; x[q].fa = x[las].fa = cnt; for (; x[p].mp[c] == q; p = x[p].fa) x[p].mp[c] = cnt; } int a[maxn]; void pre() { if (flag) { for (int i = 1; i \u003c= cnt; i++) x[x[a[i]].fa].siz += x[a[i]].siz; } for (int i = 1; i \u003c= cnt; i++) x[i].sum = x[i].siz = max(x[i].siz, 1); x[1].siz = x[1].sum = 0; // x[0].sum = 0; for (int i = 1; i \u003c= cnt; i++) { for (int j = 0; j \u003c 26; j++) { x[a[i]].sum += x[x[a[i]].mp[j]].sum; } } } void print() { if (k \u003e x[1].sum) { puts(\"-1\"); return; } int now = 1; k -= x[now].siz; while (k \u003e 0) { int p = 0; while (k \u003e x[x[now].mp[p]].sum) { k -= x[x[now].mp[p]].sum; p++; } now = x[now].mp[p]; putchar('a' + p); k -= x[now].siz; } } } s; string s1; int cmp(int a, int b) { return s.x[a].len \u003e s.x[b].len; } int main() { yin \u003e\u003e s1; yin \u003e\u003e flag \u003e\u003e k; for (nl = 1; nl \u003c= s1.size(); nl++) s.insert(s1[nl - 1] - 'a'); for (int i = 1; i \u003c= s.cnt; i++) s.a[i] = i; sort(s.a + 1, s.a + s.cnt + 1, cmp); s.pre(); s.print(); return 0; } ","date":"2020-08-08","objectID":"/posts/oi/problems/p3975/:0:0","series":null,"tags":[2015,"各省省选","后缀自动机,SAM","枚举,暴力","后缀数组,SA","天津","Notebooks/OI/OJ/Luogu"],"title":"P3975-[TJOI2015]弦论","uri":"/posts/oi/problems/p3975/#"},{"categories":null,"content":"P4512-【模板】多项式除法 题目: 题目描述: 给定一个 nnn 次多项式 F(x)F(x)F(x) 和一个 mmm 次多项式 G(x)G(x)G(x) ，请求出多项式 Q(x)Q(x)Q(x), R(x)R(x)R(x)，满足以下条件： Q(x)Q(x)Q(x) 次数为 n−mn-mn−m，R(x)R(x)R(x) 次数小于 mmm F(x)=Q(x)∗G(x)+R(x)F(x) = Q(x) * G(x) + R(x)F(x)=Q(x)∗G(x)+R(x) 所有的运算在模 998244353998244353998244353 意义下进行。 输入格式: 第一行两个整数 nnn，mmm，意义如上。 第二行 n+1n+1n+1 个整数，从低到高表示 F(x)F(x)F(x) 的各个系数。 第三行 m+1m+1m+1 个整数，从低到高表示 G(x)G(x)G(x) 的各个系数。 输出格式: 第一行 n−m+1n-m+1n−m+1 个整数，从低到高表示 Q(x)Q(x)Q(x) 的各个系数。 第二行 mmm 个整数，从低到高表示 R(x)R(x)R(x) 的各个系数。 如果 R(x)R(x)R(x) 不足 m−1m-1m−1 次，多余的项系数补 000。 样例: 样例输入 1: 5 1 1 9 2 6 0 8 1 7 样例输出 1: 237340659 335104102 649004347 448191342 855638018 760903695 思路: 实现: #include \"ybwhead/ios.h\" int n, lim, l; const int maxn = 1e6 + 10; long long a[maxn], b[maxn]; int r[maxn]; const int mod = 998244353; long long c[maxn]; long long ksm(long long a, int n) { long long ans = 1; while (n) { if (n \u0026 1) ans = ans * a % mod; a = a * a % mod; n \u003e\u003e= 1; } return ans; } const int g = 3, gi = 332748118; void ntt(long long a[], long long x) { for (int i = 0; i \u003c lim; i++) if (i \u003c r[i]) swap(a[i], a[r[i]]); for (int o = 2, k = 1; o \u003c= lim; o \u003c\u003c= 1, k \u003c\u003c= 1) { long long wn = ksm(x, (mod - 1) / (o)); for (int i = 0; i \u003c lim; i += o) { long long w = 1; for (int j = 0; j \u003c k; j++, w = w * wn % mod) { long long x = a[i + j], y = a[i + j + k] * w % mod; a[j + i] = (x + y) % mod; a[j + k + i] = (x - y + mod) % mod; } } } } void calc(int n, long long b[]) { if (n == 1) { b[0] = ksm(a[0], mod - 2); // yout\u003c\u003ca[0] return; } calc((n + 1) \u003e\u003e 1, b); lim = 1; l = 0; while (lim \u003c (n \u003c\u003c 1)) lim \u003c\u003c= 1, ++l; // yout\u003c\u003clim\u003c\u003c\" \"\u003c\u003ca[1]\u003c\u003cendl; for (int i = 0; i \u003c lim; i++) r[i] = (r[i \u003e\u003e 1] \u003e\u003e 1) | ((i \u0026 1) \u003c\u003c (l - 1)); for (int i = 0; i \u003c n; i++) c[i] = a[i]; for (int i = n; i \u003c lim; i++) c[i] = 0; ntt(c, g); ntt(b, g); for (int i = 0; i \u003c lim; i++) { b[i] = (2 - c[i] * b[i] % mod + mod) % mod * b[i] % mod; // yout\u003c\u003cb[i]\u003c\u003cendl; } ntt(b, gi); long long inv = ksm(lim, mod - 2); for (int i = 0; i \u003c n; i++) b[i] = (b[i] * inv) % mod; for (int i = n; i \u003c lim; i++) b[i] = 0; } int m; long long d[maxn]; long long aa[maxn]; int main() { yin \u003e\u003e m \u003e\u003e n; ++m; ++n; for (int i = 0; i \u003c m; i++) yin \u003e\u003e d[i]; for (int i = 0; i \u003c n; i++) yin \u003e\u003e a[i], aa[i] = a[i]; reverse(a, a + n); for (int i = m - n + 1; i \u003c m; i++) a[i] = 0; calc(m - n + 1, b); lim = 1, l = 0; while (lim \u003c= (m \u003c\u003c 1)) lim \u003c\u003c= 1, ++l; reverse(d, d + m); for (int i = 0; i \u003c lim; i++) c[i] = d[i]; reverse(d, d + m); for (int i = 0; i \u003c lim; i++) r[i] = (r[i \u003e\u003e 1] \u003e\u003e 1) | ((i \u0026 1) \u003c\u003c (l - 1)); ntt(c, g); ntt(b, g); for (int i = 0; i \u003c lim; i++) c[i] *= b[i], c[i] %= mod; ntt(c, gi); reverse(c, c + m - n + 1); long long inv = ksm(lim, mod - 2); for (int i = 0; i \u003c lim; i++) c[i] = (c[i] * inv) % mod; for (int i = 0; i \u003c m - n + 1; i++) yout \u003c\u003c c[i] \u003c\u003c \" \"; for (int i = m - n + 1; i \u003c lim; i++) c[i] = 0; yout \u003c\u003c endl; for (int i = 0; i \u003c m; i++) a[i] = aa[i]; ntt(a, g); ntt(c, g); for (int i = 0; i \u003c lim; i++) a[i] *= c[i], a[i] %= mod; ntt(a, gi); inv = ksm(lim, mod - 2); for (int i = 0; i \u003c n - 1; i++) { yout \u003c\u003c (d[i] - a[i] * inv % mod + mod) % mod \u003c\u003c ' '; } return 0; } ","date":"2020-08-07","objectID":"/posts/oi/problems/p4512/:0:0","series":null,"tags":["快速数论变换NTT","Notebooks/OI/OJ/Luogu"],"title":"P4512-【模板】多项式除法","uri":"/posts/oi/problems/p4512/#"},{"categories":null,"content":"P3338-[ZJOI2014]力 题目: 题目描述: 给出 nnn 个数 q1,q2,…qnq_1,q_2, \\dots q_nq1​,q2​,…qn​，定义 Fj = ∑i=1j−1qi×qj(i−j)2 − ∑i=j+1nqi×qj(i−j)2F_j~=~\\sum_{i = 1}^{j - 1} \\frac{q_i \\times q_j}{(i - j)^2}~-~\\sum_{i = j + 1}^{n} \\frac{q_i \\times q_j}{(i - j)^2}Fj​ = i=1∑j−1​(i−j)2qi​×qj​​ − i=j+1∑n​(i−j)2qi​×qj​​Ei = FiqiE_i~=~\\frac{F_i}{q_i}Ei​ = qi​Fi​​对 1≤i≤n1 \\leq i \\leq n1≤i≤n，求 EiE_iEi​ 的值。 输入格式: 第一行输入一个整数 nnn。 以下 nnn 行，每行有一个实数。第 i+1i+1i+1 行的数代表 qiq_iqi​。 输出格式: 输出 nnn 行每行一个实数，第 iii 行的数字代表 EiE_iEi​。 当你的输出与标准答案相差不超过 10−210^{-2}10−2 时即被认为正确。 样例: 样例输入 1: 5 4006373.885184 15375036.435759 1717456.469144 8514941.004912 1410681.345880 样例输出 1: -16838672.693 3439.793 7509018.566 4595686.886 10903040.872 思路: 实现: #include \"ybwhead/ios.h\" using namespace std; int lim = 1, l; const int maxn = 6e5 + 10; // #define double long double struct com { long double x, y; com() : x(0), y(0) {} com(long double a, long double b) : x(a), y(b) {} com operator+(com a) { return com(x + a.x, y + a.y); } com operator-(com a) { return com(x - a.x, y - a.y); } com operator*(com a) { return com(x * a.x - y * a.y, x * a.y + y * a.x); } }; com a[maxn], b[maxn]; int r[maxn]; const long double pi = acos(-1); void fft(com a[], int x) { for (int i = 0; i \u003c lim; i++) if (i \u003c r[i]) swap(a[i], a[r[i]]); for (int o = 2, k = 1; o \u003c= lim; o \u003c\u003c= 1, k \u003c\u003c= 1) { com wn(cos(pi / k), x * sin(pi / k)); for (int i = 0; i \u003c lim; i += o) { com w(1, 0); for (int j = 0; j \u003c k; j++, w = w * wn) { com x = a[i + j], y = w * a[i + j + k]; a[i + j] = x + y; a[i + j + k] = x - y; } } } return; } int n; int main() { yin \u003e\u003e n; for (int i = 0; i \u003c n; i++) { yin \u003e\u003e b[i].x; } for (int i = -n + 1; i \u003c= n - 1; i++) { if (i \u003c 0) a[i + n - 1].x = -(long double)1.0 / i / i; else if (i == 0) a[i + n - 1].x = 0; else a[i + n - 1].x = (long double)1.0 / i / i; } while (lim \u003c (n * 3)) lim \u003c\u003c= 1, ++l; for (int i = 0; i \u003c lim; i++) r[i] = (r[i \u003e\u003e 1] \u003e\u003e 1) | ((i \u0026 1) \u003c\u003c (l - 1)); fft(a, 1); fft(b, 1); for (int i = 0; i \u003c lim; i++) a[i] = a[i] * b[i]; fft(a, -1); for (int i = 0; i \u003c n; i++) { yout \u003c\u003c (a[i + n - 1].x) / lim \u003c\u003c endl; } } ","date":"2020-08-07","objectID":"/posts/oi/problems/p3338/:0:0","series":null,"tags":["数论,数学",2014,"浙江","Special Judge","快速傅里叶变换,DFT,FFT","Notebooks/OI/OJ/Luogu"],"title":"P3338-[ZJOI2014]力","uri":"/posts/oi/problems/p3338/#"},{"categories":null,"content":"P4245-【模板】任意模数 NTT 题目: 题目描述: 给定 222 个多项式 F(x),G(x)F(x), G(x)F(x),G(x) ，请求出 F(x)∗G(x)F(x) * G(x)F(x)∗G(x)。 系数对 ppp 取模，且不保证 ppp 可以分解成 p=a⋅2k+1p = a \\cdot 2^k + 1p=a⋅2k+1 之形式。 输入格式: 输入共 333 行。 第一行 333 个整数 n,m,pn, m, pn,m,p，分别表示 F(x),G(x)F(x), G(x)F(x),G(x) 的次数以及模数 ppp 。 第二行为 n+1n+1n+1 个整数， 第 iii 个整数 aia_iai​ 表示 F(x)F(x)F(x) 的 i−1i-1i−1 次项的系数。 第三行为 m+1m+1m+1 个整数， 第 iii 个整数 bib_ibi​ 表示 G(x)G(x)G(x) 的 i−1i-1i−1 次项的系数。 输出格式: 输出 n+m+1n+m+1n+m+1 个整数， 第 iii 个整数 cic_ici​ 表示 F(x)∗G(x)F(x) * G(x)F(x)∗G(x) 的 i−1i-1i−1 次项的系数。 样例: 样例输入 1: 5 8 28 19 32 0 182 99 95 77 54 15 3 98 66 21 20 38 样例输出 1: 7 18 25 19 5 13 12 2 9 22 5 27 6 26 思路: 实现: #include \"ybwhead/ios.h\" int mod; inline int pw(int base, int p, const int mod) { static int res; for (res = 1; p; p \u003e\u003e= 1, base = static_cast\u003clong long\u003e(base) * base % mod) if (p \u0026 1) res = static_cast\u003clong long\u003e(res) * base % mod; return res; } inline int inv(int x, const int mod) { return pw(x, mod - 2, mod); } const int mod1 = 998244353, mod2 = 1004535809, mod3 = 469762049, G = 3; const long long mod_1_2 = static_cast\u003clong long\u003e(mod1) * mod2; const int inv_1 = inv(mod1, mod2), inv_2 = inv(mod_1_2 % mod3, mod3); struct Int { int A, B, C; explicit inline Int() {} explicit inline Int(int __num) : A(__num), B(__num), C(__num) {} explicit inline Int(int __A, int __B, int __C) : A(__A), B(__B), C(__C) {} static inline Int reduce(const Int \u0026x) { return Int(x.A + (x.A \u003e\u003e 31 \u0026 mod1), x.B + (x.B \u003e\u003e 31 \u0026 mod2), x.C + (x.C \u003e\u003e 31 \u0026 mod3)); } inline friend Int operator+(const Int \u0026lhs, const Int \u0026rhs) { return reduce(Int(lhs.A + rhs.A - mod1, lhs.B + rhs.B - mod2, lhs.C + rhs.C - mod3)); } inline friend Int operator-(const Int \u0026lhs, const Int \u0026rhs) { return reduce(Int(lhs.A - rhs.A, lhs.B - rhs.B, lhs.C - rhs.C)); } inline friend Int operator*(const Int \u0026lhs, const Int \u0026rhs) { return Int(static_cast\u003clong long\u003e(lhs.A) * rhs.A % mod1, static_cast\u003clong long\u003e(lhs.B) * rhs.B % mod2, static_cast\u003clong long\u003e(lhs.C) * rhs.C % mod3); } inline int get() { long long x = static_cast\u003clong long\u003e(B - A + mod2) % mod2 * inv_1 % mod2 * mod1 + A; return (static_cast\u003clong long\u003e(C - x % mod3 + mod3) % mod3 * inv_2 % mod3 * (mod_1_2 % mod) % mod + x) % mod; } }; #define maxn 131072 #define N (maxn \u003c\u003c 1) int lim, s, rev[N]; Int Wn[N | 1]; inline void init(int n) { s = -1, lim = 1; while (lim \u003c n) lim \u003c\u003c= 1, ++s; for (register int i = 1; i \u003c lim; ++i) rev[i] = rev[i \u003e\u003e 1] \u003e\u003e 1 | (i \u0026 1) \u003c\u003c s; const Int t(pw(G, (mod1 - 1) / lim, mod1), pw(G, (mod2 - 1) / lim, mod2), pw(G, (mod3 - 1) / lim, mod3)); *Wn = Int(1); for (register Int *i = Wn; i != Wn + lim; ++i) *(i + 1) = *i * t; } inline void NTT(Int *A, const int op = 1) { for (register int i = 1; i \u003c lim; ++i) if (i \u003c rev[i]) std::swap(A[i], A[rev[i]]); for (register int mid = 1; mid \u003c lim; mid \u003c\u003c= 1) { const int t = lim / mid \u003e\u003e 1; for (register int i = 0; i \u003c lim; i += mid \u003c\u003c 1) { for (register int j = 0; j \u003c mid; ++j) { const Int W = op ? Wn[t * j] : Wn[lim - t * j]; const Int X = A[i + j], Y = A[i + j + mid] * W; A[i + j] = X + Y, A[i + j + mid] = X - Y; } } } if (!op) { const Int ilim(inv(lim, mod1), inv(lim, mod2), inv(lim, mod3)); for (register Int *i = A; i != A + lim; ++i) *i = (*i) * ilim; } } #undef N int n, m; Int A[maxn \u003c\u003c 1], B[maxn \u003c\u003c 1]; int main() { yin \u003e\u003e n \u003e\u003e m \u003e\u003e mod; ++n, ++m; for (int i = 0, x; i \u003c n; ++i) yin \u003e\u003e x, A[i] = Int(x % mod); for (int i = 0, x; i \u003c m; ++i) yin \u003e\u003e x, B[i] = Int(x % mod); init(n + m); NTT(A), NTT(B); for (int i = 0; i \u003c lim; ++i) A[i] = A[i] * B[i]; NTT(A, 0); for (int i = 0; i \u003c n + m - 1; ++i) { yout \u003c\u003c A[i].get() \u003c\u003c \" \"; } return 0; } ","date":"2020-08-07","objectID":"/posts/oi/problems/p4245/:0:0","series":null,"tags":["数论,数学","O2优化","素数判断,质数,筛法","同余,中国剩余定理","快速傅里叶变换,DFT,FFT","高性能","Notebooks/OI/OJ/Luogu"],"title":"P4245-【模板】任意模数NTT","uri":"/posts/oi/problems/p4245/#"},{"categories":null,"content":"P4238-【模板】多项式乘法逆 题目: 题目描述: 给定一个多项式 F(x)F(x)F(x) ，请求出一个多项式 G(x)G(x)G(x)， 满足 F(x)∗G(x)≡1(mod xn)F(x) * G(x) \\equiv 1 ( \\mathrm{mod\\:} x^n )F(x)∗G(x)≡1(modxn)。系数对 998244353998244353998244353 取模。 输入格式: 首先输入一个整数 nnn， 表示输入多项式的项数。 接着输入 nnn 个整数，第 iii 个整数 aia_iai​ 代表 F(x)F(x)F(x) 次数为 i−1i-1i−1 的项的系数。 输出格式: 输出 nnn 个数字，第 iii 个整数 bib_ibi​ 代表 G(x)G(x)G(x) 次数为 i−1i-1i−1 的项的系数。 保证有解。 样例: 样例输入 1: 5 1 6 3 4 9 样例输出 1: 1 998244347 33 998244169 1020 思路: 实现: #include \"ybwhead/ios.h\" int n, lim, l; const int maxn=1e6+10; long long a[maxn], b[maxn]; int r[maxn]; const int mod=998244353; long long c[maxn]; long long ksm(long long a, int n) { long long ans=1; while (n) { if (n\u00261)ans=ans*a%mod; a=a*a%mod; n\u003e\u003e=1; } return ans; } const int g=3, gi=332748118; void ntt(long long a[], long long x) { for (int i=0;i\u003clim;i++)if (i\u003cr[i])swap(a[i], a[r[i]]); for (int o=2, k=1;o\u003c=lim;o\u003c\u003c=1, k\u003c\u003c=1) { long long wn=ksm(x, (mod-1)/(o)); for (int i=0;i\u003clim;i+=o) { long long w=1; for (int j=0;j\u003ck;j++, w=w*wn%mod) { long long x=a[i+j], y=a[i+j+k]*w%mod; a[j+i]=(x+y)%mod; a[j+k+i]=(x-y+mod)%mod; } } } } void calc(int n, long long b[]) { if (n==1) { b[0]=ksm(a[0], mod-2); // yout\u003c\u003ca[0] return; } calc((n+1)\u003e\u003e1, b); lim=1;l=0; while (lim\u003c(n\u003c\u003c1))lim\u003c\u003c=1, ++l; // yout\u003c\u003clim\u003c\u003c\" \"\u003c\u003ca[1]\u003c\u003cendl; for (int i=0;i\u003clim;i++)r[i]=(r[i\u003e\u003e1]\u003e\u003e1)|((i\u00261)\u003c\u003c(l-1)); for (int i=0;i\u003cn;i++)c[i]=a[i]; for (int i=n;i\u003clim;i++)c[i]=0; ntt(c, g);ntt(b, g); for (int i=0;i\u003clim;i++) { b[i]=(2-c[i]*b[i]%mod+mod)%mod*b[i]%mod; // yout\u003c\u003cb[i]\u003c\u003cendl; } ntt(b, gi); long long inv=ksm(lim, mod-2); for (int i=0;i\u003cn;i++)b[i]=(b[i]*inv)%mod; for (int i=n;i\u003clim;i++)b[i]=0; } int main() { yin\u003e\u003en; for (int i=0;i\u003cn;i++)yin\u003e\u003ea[i]; // while (lim\u003cn)lim\u003c\u003c=1, l++; calc(n, b); for (int i=0;i\u003cn;i++)yout\u003c\u003c(b[i]+mod)%mod\u003c\u003c\" \"; yout\u003c\u003cendl; return 0; } ","date":"2020-08-06","objectID":"/posts/oi/problems/p4238/:0:0","series":null,"tags":["数论,数学","递推","倍增","递归","逆元","快速傅里叶变换,DFT,FFT","高性能","Notebooks/OI/OJ/Luogu"],"title":"P4238-【模板】多项式乘法逆","uri":"/posts/oi/problems/p4238/#"},{"categories":null,"content":"P1919-【模板】A*B Problem 升级版（FFT 快速傅里叶） 题目: 题目描述: 给你两个正整数 a,ba,ba,b，求 a×ba \\times ba×b。 输入格式: 第一行一个正整数，表示 aaa； 第二行一个正整数，表示 bbb。 输出格式: 输出一行一个整数表示答案。 样例: 样例输入 1: 114514 1919810 样例输出 1: 219845122340 思路: 实现: #include \"ybwhead/ios.h\" // #define int long long string s, s1; int lim; const int maxn = 3e6 + 10; const long long mod=998244353; int r[maxn]; long long a[maxn]; long long b[maxn]; long long ksm(long long a, int n) { long long ans=1; while (n) { if (n\u00261)ans=ans*a%mod; a=(a*a)%mod; n\u003e\u003e=1; } return ans; } const long long g=3, gi=ksm(3, mod-2); void NTT(long long a[], long long x) { for (int i=1;i\u003c=lim;i++) { // yout\u003c\u003ci-1\u003c\u003c\" \"\u003c\u003cr[i-1]\u003c\u003cendl; // yout\u003c\u003ci\u003c\u003c' '\u003c\u003cr[i-1]+1\u003c\u003cendl; if (i-1\u003cr[i-1]+1)swap(a[i], a[r[i-1]+1]); } for (int o=1;o\u003clim;o\u003c\u003c=1) { long long wn=ksm(x, (mod-1)/(o\u003c\u003c1)); for (int i=1;i\u003c=lim;i+=o\u003c\u003c1) { long long w=1; for (int j=0;j\u003co;j++, w=w*wn%mod) { long long x=a[i+j], y=a[i+j+o]*w%mod; // cout\u003c\u003cx\u003c\u003c' '\u003c\u003cy\u003c\u003cendl; a[i+j]=(x+y)%mod; a[i+j+o]=(long long)(x-y+mod)%mod; } } } } signed main() { yin \u003e\u003e s \u003e\u003e s1; int n = s.size(), m = s1.size(); for (int i = 1; i \u003c= n; i++) a[i] = s[n-i] - '0'; for (int i = 1; i \u003c= m; i++) b[i] = s1[m-i] - '0'; int l=0; lim=1; while (lim \u003c n + m) lim \u003c\u003c= 1, ++l; for (int i = 0; i \u003c lim; i++) { r[i] = (r[i \u003e\u003e 1]\u003e\u003e1) | ((i \u0026 1) \u003c\u003c (l - 1)); } // puts(\"!!!\"); NTT(a, g); NTT(b, g); // puts(\"!!!\"); for (int i = 1; i \u003c= lim; i++) { a[i] *= b[i]; a[i]%=mod; // cout\u003c\u003ca[i]\u003c\u003c\" \"\u003c\u003cb[i]\u003c\u003cendl; } // cout\u003c\u003cgi\u003c\u003cendl; NTT(a, gi); long long inv=ksm(lim, mod-2); for (int i=1;i\u003c=lim;i++) { a[i]=(a[i]*inv)%mod; // cout\u003c\u003ca[i]\u003c\u003cendl; } for (int i=1;i\u003c=lim;i++) { a[i+1]+=a[i]/10; a[i]%=10; } ++lim; while (!a[lim]\u0026\u0026lim)lim--; if (!lim)puts(\"0\"); else for (int i=lim;i\u003e=1;i--)yout\u003c\u003ca[i]; yout\u003c\u003cendl; return 0; } ","date":"2020-08-06","objectID":"/posts/oi/problems/p1919/:0:0","series":null,"tags":["高精","O2优化","快速傅里叶变换,DFT,FFT","Notebooks/OI/OJ/Luogu"],"title":"P1919-【模板】A*B Problem升级版（FFT快速傅里叶）","uri":"/posts/oi/problems/p1919/#"},{"categories":null,"content":"P4070-[SDOI2016]生成魔咒 题目: 题目描述: 魔咒串由许多魔咒字符组成，魔咒字符可以用数字表示。例如可以将魔咒字符 1,21,21,2 拼凑起来形成一个魔咒串 [1,2][1,2][1,2]。 一个魔咒串 SSS 的非空字串被称为魔咒串 SSS 的生成魔咒。 例如 S=[1,2,1]S=[1,2,1]S=[1,2,1] 时，它的生成魔咒有 [1],[2],[1,2],[2,1],[1,2,1][1],[2],[1,2],[2,1],[1,2,1][1],[2],[1,2],[2,1],[1,2,1] 五种。S=[1,1,1]S=[1,1,1]S=[1,1,1] 时，它的生成魔咒有 [1],[1,1],[1,1,1][1],[1,1],[1,1,1][1],[1,1],[1,1,1] 三种，最初 S 为空串。 共进行 nnn 次操作，每次操作是在 SSS 的结尾加入一个魔咒字符。每次操作后都需要求出，当前的魔咒串 SSS 共有多少种生成魔咒。 输入格式: 第一行一个整数 nnn。 第二行 nnn 个数，第 iii 个数表示第 iii 次操作加入的魔咒字符 xix_ixi​。 输出格式: 输出 nnn 行，每行一个数。 第 iii 行的数表示第 iii 次操作后 SSS 的生成魔咒数量 样例: 样例输入 1: 7 1 2 3 3 3 1 2 样例输出 1: 1 3 6 9 12 17 22 思路: 实现: #include \"ybwhead/ios.h\" const int maxn = 5e5 + 10; int nl; long long ans; struct SAM { struct node { int len, fa; map\u003cint, int\u003e mp; } x[maxn]; int las, cnt; SAM() { las = cnt = 1; } void insert(int c) { int p = las; las = ++cnt; x[las].len = nl; for (; p \u0026\u0026 !x[p].mp[c]; p = x[p].fa) x[p].mp[c] = las; if (p == 0) { x[las].fa = 1; ans += x[las].len - x[x[las].fa].len; return; } int q = x[p].mp[c]; if (x[q].len == x[p].len + 1) { x[las].fa = q; ans += x[las].len - x[x[las].fa].len; return; } ++cnt; x[cnt].fa = x[q].fa; x[q].fa = cnt; x[cnt].len = x[p].len + 1; x[cnt].mp = x[q].mp; x[las].fa = cnt; for (; x[p].mp[c] == q; p = x[p].fa) x[p].mp[c] = cnt; ans += x[las].len - x[x[las].fa].len; } } s; int main() { int n; yin \u003e\u003e n; for (nl = 1; nl \u003c= n; nl++) { int x; yin \u003e\u003e x; s.insert(x); yout \u003c\u003c ans \u003c\u003c endl; } return 0; } ","date":"2020-08-05","objectID":"/posts/oi/problems/p4070/:0:0","series":null,"tags":["字符串",2016,"各省省选","平衡树","山东","后缀自动机,SAM","后缀数组,SA","Notebooks/OI/OJ/Luogu"],"title":"P4070-[SDOI2016]生成魔咒","uri":"/posts/oi/problems/p4070/#"},{"categories":null,"content":"P3804-【模板】后缀自动机 (SAM) 题目: 题目描述: 给定一个只包含小写字母的字符串SSS, 请你求出 SSS 的所有出现次数不为 111 的子串的出现次数乘上该子串长度的最大值。 输入格式: 一行一个仅包含小写字母的字符串SSS 输出格式: 一个整数，为 所求答案 样例: 样例输入 1: abab 样例输出 1: 4 思路: 实现: #include \"ybwhead/ios.h\" long long ans; int n, nl; const int maxn = 3 * 1e6 + 100; char s[maxn]; struct sam { int mp[maxn][26]; struct edge { int nxt, v; } e[maxn]; int tot, cnt, las, len[maxn], head[maxn], siz[maxn], fa[maxn]; void add(int u, int v) { e[++tot].v = v; e[tot].nxt = head[u]; head[u] = tot; } void ins(int c) { int p = las; siz[las = ++cnt] = 1; len[las] = nl; for (; p \u0026\u0026 mp[p][c] == 0; p = fa[p]) { mp[p][c] = las; } if (p == 0) { fa[las] = 1; return; } int q = mp[p][c]; if (len[p] + 1 == len[q]) { fa[las] = q; return; } len[++cnt] = len[p] + 1; for (int i = 0; i \u003c 26; i++) { mp[cnt][i] = mp[q][i]; } fa[cnt] = fa[q]; fa[q] = cnt; fa[las] = cnt; for (int i = p; mp[i][c] == q; i = fa[i]) { mp[i][c] = cnt; } } inline void jt() { for (int i = 2; i \u003c= cnt; i++) { add(fa[i], i); } } void dfs(int u) { for (int i = head[u]; i; i = e[i].nxt) { dfs(e[i].v); siz[u] += siz[e[i].v]; } if (siz[u] != 1) { ans = max(ans, (long long)siz[u] * len[u]); } } } sam; int main() { scanf(\"%s\", s + 1); n = strlen(s + 1); sam.cnt = sam.las = 1; for (nl = 1; nl \u003c= n; nl++) sam.ins(s[nl] - 'a'); sam.jt(); sam.dfs(1); yout \u003c\u003c ans \u003c\u003c endl; return 0; } ","date":"2020-08-04","objectID":"/posts/oi/problems/p3804/:0:0","series":null,"tags":["字符串","后缀自动机,SAM","O2优化","后缀数组,SA","Notebooks/OI/OJ/Luogu"],"title":"P3804-【模板】后缀自动机 (SAM)","uri":"/posts/oi/problems/p3804/#"},{"categories":null,"content":"P4717-【模板】快速沃尔什变换 (FWT) 题目: 题目描述: 给定长度为 2n2^n2n 两个序列 A,BA, BA,B，设 Ci=∑j⊕k=iAj×BkC_i=\\sum_{j\\oplus k = i}A_j \\times B_kCi​=j⊕k=i∑​Aj​×Bk​分别当 ⊕\\oplus⊕ 是 or, and, xor 时求出 CCC 输入格式: 第一行一个数 n。 第二行2n2^n2n个数A0..A2n−1A_0.. A_{2^n-1}A0​..A2n−1​ 第三行2n2^n2n个数B0..B2n−1B_0.. B_{2^n-1}B0​..B2n−1​ 输出格式: 三行每行2n2^n2n个数，分别代表⊕\\oplus⊕是 or, and, xor 时C0..C2n−1C_0.. C_{2^n-1}C0​..C2n−1​的值 mod 998244353\\bmod\\ 998244353mod 998244353 样例: 样例输入 1: 2 2 4 6 8 1 3 5 7 样例输出 1: 2 22 46 250 88 64 112 56 100 92 68 60 思路: 实现: #include \"ybwhead/ios.h\" const int maxn = (1 \u003c\u003c 17) + 10; int n; long long a[maxn], b[maxn], f[maxn], g[maxn]; const int mod = 998244353; const int inv = (mod + 1) \u003e\u003e 1; void mul() { for (int i = 1; i \u003c= n; i++) f[i] *= g[i], f[i] %= mod; } void print() { for (int i = 1; i \u003c= n; i++) yout \u003c\u003c f[i] \u003c\u003c \" \"; puts(\"\"); } void pre() { memcpy(f, a, sizeof(f)); memcpy(g, b, sizeof(g)); } void __AND(long long f[], int x = 1) { for (int o = 2, k = 1; o \u003c= n; o \u003c\u003c= 1, k \u003c\u003c= 1) { for (int i = 1; i \u003c= n; i += o) { for (int j = 0; j \u003c k; j++) { f[i + j] += f[i + j + k] * x + mod; while (f[i + j] \u003e= mod) f[i + j] -= mod; } } } } void __OR(long long f[], int x = 1) { for (int o = 2, k = 1; o \u003c= n; o \u003c\u003c= 1, k \u003c\u003c= 1) { for (int i = 1; i \u003c= n; i += o) { for (int j = 0; j \u003c k; j++) { f[i + j + k] += f[i + j] * x + mod; while (f[i + j + k] \u003e= mod) f[i + j + k] -= mod; } } } } void __XOR(long long f[], int x = 1) { for (int o = 2, k = 1; o \u003c= n; o \u003c\u003c= 1, k \u003c\u003c= 1) { for (int i = 1; i \u003c= n; i += o) { for (int j = 0; j \u003c k; j++) { f[i + j] += f[i + j + k]; f[i + j + k] = f[i + j] - f[i + j + k] - f[i + j + k]; f[i + j] *= x; f[i + j + k] *= x; f[i + j] = (f[i + j] % mod + mod) % mod; f[i + j + k] = (f[i + j + k] % mod + mod) % mod; } } } } int main() { yin \u003e\u003e n; n = 1 \u003c\u003c n; for (int i = 1; i \u003c= n; i++) yin \u003e\u003e a[i]; for (int i = 1; i \u003c= n; i++) yin \u003e\u003e b[i]; pre(); __OR(f); __OR(g); mul(); __OR(f, -1); print(); pre(); __AND(f); __AND(g); mul(); __AND(f, -1); print(); pre(); __XOR(f); __XOR(g); mul(); __XOR(f, inv); print(); return 0; } ","date":"2020-08-04","objectID":"/posts/oi/problems/p4717/:0:0","series":null,"tags":["dp","数论, 数学","快速傅里叶变换, DFT, FFT","Notebooks/OI/OJ/Luogu"],"title":"P4717-【模板】快速沃尔什变换 (FWT)","uri":"/posts/oi/problems/p4717/#"},{"categories":null,"content":"P6136-【模板】普通平衡树（数据加强版） 题目: 题目描述: 您需要写一种数据结构（可参考题目标题），来维护一些整数，其中需要提供以下操作： 插入一个整数 xxx。 删除一个整数 xxx（若有多个相同的数，只删除一个）。 查询整数 xxx 的排名（排名定义为比当前数小的数的个数 +1+1+1）。 查询排名为 xxx 的数（如果不存在，则认为是排名小于 xxx 的最大数。保证 xxx 不会超过当前数据结构中数的总数）。 求 xxx 的前驱（前驱定义为小于 xxx，且最大的数）。 求 xxx 的后继（后继定义为大于 xxx，且最小的数）。 本题强制在线，保证所有操作合法（操作 222 保证存在至少一个 xxx，操作 4,5,64,5,64,5,6 保证存在答案）。 输入格式: 第一行两个正整数 n,mn,mn,m，表示初始数的个数和操作的个数。 第二行 nnn 个整数 a1,a2,a3,…,ana_1,a_2,a_3,\\ldots,a_na1​,a2​,a3​,…,an​，表示初始的数。 接下来 mmm 行，每行有两个整数 opt\\text{opt}opt 和 x′x'x′，opt\\text{opt}opt 表示操作的序号（1≤opt≤6 1 \\leq \\text{opt} \\leq 6 1≤opt≤6），x′x'x′ 表示加密后的操作数。 我们记 last\\text{last}last 表示上一次 3,4,5,63,4,5,63,4,5,6 操作的答案，则每次操作的 x′x'x′ 都要异或上 last\\text{last}last 才是真实的 xxx。初始 last\\text{last}last 为 000。 输出格式: 输出一行一个整数，表示所有 3,4,5,63,4,5,63,4,5,6 操作的答案的异或和。 样例: 样例输入 1: 6 7 1 1 4 5 1 4 2 1 1 9 4 1 5 8 3 13 6 7 1 4 样例输出 1: 6 思路: 实现: #include \"ybwhead/ios.h\" const int maxn = 2e6 + 10; struct fhq_treap { struct node { int ch[2], val; unsigned int pri, siz; } p[maxn]; int tot, root; void update(int x) { p[x].siz = p[p[x].ch[0]].siz + p[p[x].ch[1]].siz + 1; } int new_node(int v) { p[++tot].siz = 1; p[tot].val = v; p[tot].pri = rand() * rand(); return tot; } int merge(int x, int y) { if (!x || !y) return x + y; if (p[x].pri \u003c p[y].pri) { p[x].ch[1] = merge(p[x].ch[1], y); update(x); // cout \u003c\u003c p[p[x].ch[1]].siz\u003c\u003c' '\u003c\u003cp[p[x]] \u003c\u003c endl; return x; } else { p[y].ch[0] = merge(x, p[y].ch[0]); update(y); // cout \u003c\u003c p[y].siz \u003c\u003c endl; return y; } } void split(int now, int k, int \u0026x, int \u0026y) { if (!now) { x = y = 0; return; } if (p[now].val \u003c= k) x = now, split(p[now].ch[1], k, p[now].ch[1], y); else y = now, split(p[now].ch[0], k, x, p[now].ch[0]); update(now); } int kth(int now, int k) { while (1) { if (k \u003c= p[p[now].ch[0]].siz) now = p[now].ch[0]; else if (k == p[p[now].ch[0]].siz + 1) return now; else k -= p[p[now].ch[0]].siz + 1, now = p[now].ch[1]; } } void insert(int x) { int xx, yy; split(root, x, xx, yy); root = merge(merge(xx, new_node(x)), yy); // cout \u003c\u003c p[root].siz \u003c\u003c endl; } void erase(int x) { int xx, yy, zz; split(root, x, xx, yy); split(xx, x - 1, xx, zz); zz = merge(p[zz].ch[0], p[zz].ch[1]); root = merge(merge(xx, zz), yy); } int rank(int x) { int xx, yy; split(root, x - 1, xx, yy); int zz = p[xx].siz + 1; root = merge(xx, yy); return zz; } int kkth(int x) { // cout \u003c\u003c root \u003c\u003c endl; return p[kth(root, x)].val; } int lower(int x) { int xx, yy; // cout \u003c\u003c x \u003c\u003c endl; split(root, x - 1, xx, yy); // puts(\"1\"); // cout \u003c\u003c kth(xx, p[xx].siz) \u003c\u003c endl; int zz = p[kth(xx, p[xx].siz)].val; root = merge(xx, yy); return zz; } int upper(int x) { int xx, yy; split(root, x, xx, yy); int zz = p[kth(yy, 1)].val; // cout \u003c\u003c kth(yy, 1) \u003c\u003c endl; root = merge(xx, yy); return zz; } } tr; int n, m; int main() { yin \u003e\u003e n \u003e\u003e m; for (int i = 1; i \u003c= n; i++) { int x; yin \u003e\u003e x; tr.insert(x); } int ans = 0, last = 0; while (m--) { int opt, x; yin \u003e\u003e opt \u003e\u003e x; x ^= last; if (opt == 1) tr.insert(x); if (opt == 2) tr.erase(x); if (opt == 3) ans ^= (last = tr.rank(x)); if (opt == 4) ans ^= (last = tr.kkth(x)); if (opt == 5) ans ^= (last = tr.lower(x)); if (opt == 6) ans ^= (last = tr.upper(x)); } yout \u003c\u003c ans \u003c\u003c endl; } ","date":"2020-08-04","objectID":"/posts/oi/problems/p6136/:0:0","series":null,"tags":["平衡树","O2优化","Notebooks/OI/OJ/Luogu"],"title":"P6136-【模板】普通平衡树（数据加强版）","uri":"/posts/oi/problems/p6136/#"},{"categories":null,"content":"CF700B-Connecting Universities 题目: 题目描述: Treeland is a country in which there are n n n towns connected by n−1 n-1 n−1 two-way road such that it’s possible to get from any town to any other town. In Treeland there are 2k 2k 2k universities which are located in different towns. Recently, the president signed the decree to connect universities by high-speed network.The Ministry of Education understood the decree in its own way and decided that it was enough to connect each university with another one by using a cable. Formally, the decree will be done! To have the maximum sum in the budget, the Ministry decided to divide universities into pairs so that the total length of the required cable will be maximum. In other words, the total distance between universities in k k k pairs should be as large as possible. Help the Ministry to find the maximum total distance. Of course, each university should be present in only one pair. Consider that all roads have the same length which is equal to 1 1 1 . 输入格式: The first line of the input contains two integers n n n and k k k ( 2\u003c=n\u003c=200000 2\u003c=n\u003c=200000 2\u003c=n\u003c=200000 , 1\u003c=k\u003c=n/2 1\u003c=k\u003c=n/2 1\u003c=k\u003c=n/2 ) — the number of towns in Treeland and the number of university pairs. Consider that towns are numbered from 1 1 1 to n n n . The second line contains 2k 2k 2k distinct integers u1,u2,...,u2k u_{1},u_{2},...,u_{2k} u1​,u2​,...,u2k​ ( 1\u003c=ui\u003c=n 1\u003c=u_{i}\u003c=n 1\u003c=ui​\u003c=n ) — indices of towns in which universities are located. The next n−1 n-1 n−1 line contains the description of roads. Each line contains the pair of integers xj x_{j} xj​ and yj y_{j} yj​ ( 1\u003c=xj,yj\u003c=n 1\u003c=x_{j},y_{j}\u003c=n 1\u003c=xj​,yj​\u003c=n ), which means that the j j j -th road connects towns xj x_{j} xj​ and yj y_{j} yj​ . All of them are two-way roads. You can move from any town to any other using only these roads. 输出格式: Print the maximum possible sum of distances in the division of universities into k k k pairs. 样例: 样例输入 1: 7 2 1 5 6 2 1 3 3 2 4 5 3 7 4 3 4 6 样例输出 1: 6 样例输入 2: 9 3 3 2 1 6 5 9 8 9 3 2 2 7 3 4 7 6 4 5 2 1 2 8 样例输出 2: 9 思路: 实现: #include \"ybwhead/ios.h\" const int maxn = 2e5 + 10; vector\u003cint\u003e v[maxn]; int a[maxn]; long long ans; int n, k; void dfs(int u, int fa) { for (int i = 0; i \u003c v[u].size(); i++) { int vv = v[u][i]; if (vv == fa) continue; dfs(vv, u); a[u] += a[vv]; ans += min(a[vv], k * 2 - a[vv]); } } int main() { yin \u003e\u003e n \u003e\u003e k; for (int i = 1; i \u003c= k \u003c\u003c 1; i++) { int x; yin \u003e\u003e x; a[x] = 1; } for (int i = 1; i \u003c n; i++) { int x, y; yin \u003e\u003e x \u003e\u003e y; v[x].push_back(y); v[y].push_back(x); } dfs(1, 0); yout \u003c\u003c ans \u003c\u003c endl; return 0; } ","date":"2020-08-01","objectID":"/posts/oi/problems/cf700b/:0:0","series":null,"tags":["Notebooks/OI/OJ/Luogu"],"title":"CF700B-Connecting Universities","uri":"/posts/oi/problems/cf700b/#"},{"categories":null,"content":"P2495-[SDOI2011]消耗战 题目: 题目描述: 在一场战争中，战场由 nnn 个岛屿和 n−1n-1n−1 个桥梁组成，保证每两个岛屿间有且仅有一条路径可达。现在，我军已经侦查到敌军的总部在编号为 111 的岛屿，而且他们已经没有足够多的能源维系战斗，我军胜利在望。已知在其他 kkk 个岛屿上有丰富能源，为了防止敌军获取能源，我军的任务是炸毁一些桥梁，使得敌军不能到达任何能源丰富的岛屿。由于不同桥梁的材质和结构不同，所以炸毁不同的桥梁有不同的代价，我军希望在满足目标的同时使得总代价最小。 侦查部门还发现，敌军有一台神秘机器。即使我军切断所有能源之后，他们也可以用那台机器。机器产生的效果不仅仅会修复所有我军炸毁的桥梁，而且会重新随机资源分布（但可以保证的是，资源不会分布到 111 号岛屿上）。不过侦查部门还发现了这台机器只能够使用 mmm 次，所以我们只需要把每次任务完成即可。 输入格式: 第一行一个整数 nnn，表示岛屿数量。 接下来 n−1n-1n−1 行，每行三个整数 u,v,wu,v,wu,v,w ，表示 uuu 号岛屿和 vvv 号岛屿由一条代价为 www 的桥梁直接相连。 第 n+1n+1n+1 行，一个整数 mmm ，代表敌方机器能使用的次数。 接下来 mmm 行，第 iii 行一个整数 kik_iki​ ，代表第 iii 次后，有 kik_iki​ 个岛屿资源丰富。接下来 kik_iki​ 个整数 h1,h2,...,hkih_1,h_2,..., h_{k_i}h1​,h2​,...,hki​​ ，表示资源丰富岛屿的编号。 输出格式: 输出共 mmm 行，表示每次任务的最小代价。 样例: 样例输入 1: 10 1 5 13 1 9 6 2 1 19 2 4 8 2 3 91 5 6 8 7 5 4 7 8 31 10 7 9 3 2 10 6 4 5 7 8 3 3 9 4 6 样例输出 1: 12 32 22 思路: 实现: #include \"ybwhead/ios.h\" int n; const int maxn = 5e5 + 10; struct Edge { struct Edge_node { int v, nxt; long long w; } e[maxn \u003c\u003c 1]; // #ifndef maxn // const int maxn = (int)1e5 + 100; // #endif int head[maxn], tot; void __ADD(int u, int v, long long w) { e[++tot] = (Edge_node){v, head[u], w}; head[u] = tot; } void add(int u, int v) { __ADD(u, v, 1); __ADD(v, u, 1); } void add(int u, int v, int w) { __ADD(u, v, w); __ADD(v, u, w); } } e, e1; int f[maxn \u003c\u003c 1][20]; int num, dfn[maxn]; int dep[maxn]; int lg[maxn \u003c\u003c 1]; long long mv[maxn]; void dfs(int u, int fa) { dfn[u] = ++num; dep[u] = dep[fa] + 1; f[num][0] = u; for (int i = e.head[u]; i; i = e.e[i].nxt) { int v = e.e[i].v; if (v == fa) continue; mv[v] = min(mv[u], e.e[i].w); dfs(v, u); f[++num][0] = u; } } int calc(int x, int y) { return dep[x] \u003c dep[y] ? x : y; } void pre() { for (int i = 2; i \u003c= num; i++) lg[i] = lg[i \u003e\u003e 1] + 1; for (int j = 1; j \u003c= 18; j++) { for (int i = 1; i \u003c= num - (1 \u003c\u003c j) + 1; i++) { f[i][j] = calc(f[i][j - 1], f[i + (1 \u003c\u003c (j - 1))][j - 1]); } } } int lca(int x, int y) { int l = dfn[x], r = dfn[y]; if (l \u003e r) swap(l, r); return calc(f[l][lg[r - l + 1]], f[r - (1 \u003c\u003c lg[r - l + 1]) + 1][lg[r - l + 1]]); } int k, v[maxn]; int q[maxn]; int cmp(int a, int b) { return dfn[a] \u003c dfn[b]; } int s[maxn], top; long long dfs1(int u, int fa) { long long sum = 0; long long tmp; for (int i = e1.head[u]; i; i = e1.e[i].nxt) { int v = e1.e[i].v; // yout \u003c\u003c v \u003c\u003c \"!!!\" \u003c\u003c i \u003c\u003c endl; if (v == fa) continue; sum += dfs1(v, u); } // cout \u003c\u003c u \u003c\u003c \" \" \u003c\u003c mv[u] \u003c\u003c \" \" \u003c\u003c sum \u003c\u003c endl; if (q[u]) tmp = mv[u]; else tmp = min((long long)mv[u], sum); q[u] = 0; e1.head[u] = 0; return tmp; } long long work() { for (int i = 1; i \u003c= k; i++) q[v[i]] = 1; sort(v + 1, v + k + 1, cmp); s[top = 1] = v[1]; for (int i = 2; i \u003c= k; i++) { int now = v[i]; int lc = lca(now, s[top]); // yout \u003c\u003c now \u003c\u003c endl; while (1) { if (dep[lc] \u003e= dep[s[top - 1]]) { if (lc != s[top]) { e1.add(lc, s[top]); if (lc != s[top - 1]) s[top] = lc; else top--; } break; } else { e1.add(s[top - 1], s[top]); top--; } } s[++top] = now; } // yout \u003c\u003c top \u003c\u003c endl; // yout \u003c\u003c s[top] \u003c\u003c ' ' \u003c\u003c s[top - 1] \u003c\u003c endl; while (--top) e1.add(s[top], s[top + 1]); return dfs1(s[1], 0); } int main() { yin \u003e\u003e n; mv[1] = LLONG_MAX / 10; for (int i = 1; i \u003c n; i++) { int u, v; long long w; yin \u003e\u003e u \u003e\u003e v \u003e\u003e w; e.add(u, v, w); } dfs(1, 0); // yout \u003c\u003c dep[0] \u003c\u003c endl; pre(); // yout \u003c\u003c dep[0] \u003c\u003c endl; int m; yin \u003e\u003e m; while (m--) { // int k; yin \u003e\u003e k; for (int i = 1; i \u003c= k; i++) yin \u003e\u003e v[i]; // yout \u003c\u003c dep[0] \u003c\u003c endl; yout \u003c\u003c work() \u003c\u003c endl; e1.tot = 0; } return 0; } ","date":"2020-08-01","objectID":"/posts/oi/problems/p2495/:0:0","series":null,"tags":[2011,"各省省选","山东","最近公共祖先,LCA","虚树","栈","高性能","Notebooks/OI/OJ/Luogu"],"title":"P2495-[SDOI2011]消耗战","uri":"/posts/oi/problems/p2495/#"},{"categories":null,"content":"P3369-【模板】普通平衡树 题目: 题目描述: 您需要写一种数据结构（可参考题目标题），来维护一些数，其中需要提供以下操作： 插入 xxx 数 删除 xxx 数(若有多个相同的数，因只删除一个) 查询 xxx 数的排名(排名定义为比当前数小的数的个数 +1+1+1 ) 查询排名为 xxx 的数 求 xxx 的前驱(前驱定义为小于 xxx，且最大的数) 求 xxx 的后继(后继定义为大于 xxx，且最小的数) 输入格式: 第一行为 nnn，表示操作的个数,下面 nnn 行每行有两个数 opt\\text{opt}opt 和 xxx，opt\\text{opt}opt 表示操作的序号( 1≤opt≤6 1 \\leq \\text{opt} \\leq 6 1≤opt≤6 ) 输出格式: 对于操作 3,4,5,63,4,5,63,4,5,6 每行输出一个数，表示对应答案 样例: 样例输入 1: 10 1 106465 4 1 1 317721 1 460929 1 644985 1 84185 1 89851 6 81968 1 492737 5 493598 样例输出 1: 106465 84185 492737 思路: 实现: #include \"ybwhead/ios.h\" const int maxn = 5e5 + 10; struct fhq_treap { struct node { int ch[2], val; unsigned int pri, siz; } p[maxn]; int tot, root; void update(int x) { p[x].siz = p[p[x].ch[0]].siz + p[p[x].ch[1]].siz + 1; } int new_node(int v) { p[++tot].siz = 1; p[tot].val = v; p[tot].pri = rand() * rand(); return tot; } int merge(int x, int y) { if (!x || !y) return x + y; if (p[x].pri \u003c p[y].pri) { p[x].ch[1] = merge(p[x].ch[1], y); update(x); // cout \u003c\u003c p[p[x].ch[1]].siz\u003c\u003c' '\u003c\u003cp[p[x]] \u003c\u003c endl; return x; } else { p[y].ch[0] = merge(x, p[y].ch[0]); update(y); // cout \u003c\u003c p[y].siz \u003c\u003c endl; return y; } } void split(int now, int k, int \u0026x, int \u0026y) { if (!now) { x = y = 0; return; } if (p[now].val \u003c= k) x = now, split(p[now].ch[1], k, p[now].ch[1], y); else y = now, split(p[now].ch[0], k, x, p[now].ch[0]); update(now); } int kth(int now, int k) { while (1) { if (k \u003c= p[p[now].ch[0]].siz) now = p[now].ch[0]; else if (k == p[p[now].ch[0]].siz + 1) return now; else k -= p[p[now].ch[0]].siz + 1, now = p[now].ch[1]; } } void insert(int x) { int xx, yy; split(root, x, xx, yy); root = merge(merge(xx, new_node(x)), yy); // cout \u003c\u003c p[root].siz \u003c\u003c endl; } void erase(int x) { int xx, yy, zz; split(root, x, xx, yy); split(xx, x - 1, xx, zz); zz = merge(p[zz].ch[0], p[zz].ch[1]); root = merge(merge(xx, zz), yy); } int rank(int x) { int xx, yy; split(root, x - 1, xx, yy); int zz = p[xx].siz + 1; root = merge(xx, yy); return zz; } int kkth(int x) { // cout \u003c\u003c root \u003c\u003c endl; return p[kth(root, x)].val; } int lower(int x) { int xx, yy; // cout \u003c\u003c x \u003c\u003c endl; split(root, x - 1, xx, yy); // puts(\"1\"); // cout \u003c\u003c kth(xx, p[xx].siz) \u003c\u003c endl; int zz = p[kth(xx, p[xx].siz)].val; root = merge(xx, yy); return zz; } int upper(int x) { int xx, yy; split(root, x, xx, yy); int zz = p[kth(yy, 1)].val; // cout \u003c\u003c kth(yy, 1) \u003c\u003c endl; root = merge(xx, yy); return zz; } } tr; int n, m; int main() { yin \u003e\u003e m; while (m--) { int opt, x; yin \u003e\u003e opt \u003e\u003e x; if (opt == 1) tr.insert(x); if (opt == 2) tr.erase(x); if (opt == 3) yout \u003c\u003c tr.rank(x) \u003c\u003c endl; if (opt == 4) yout \u003c\u003c tr.kkth(x) \u003c\u003c endl; if (opt == 5) yout \u003c\u003c tr.lower(x) \u003c\u003c endl; if (opt == 6) yout \u003c\u003c tr.upper(x) \u003c\u003c endl; } } ","date":"2020-07-30","objectID":"/posts/oi/problems/p3369/:0:0","series":null,"tags":["平衡树","高性能","Notebooks/OI/OJ/Luogu"],"title":"P3369-【模板】普通平衡树","uri":"/posts/oi/problems/p3369/#"},{"categories":null,"content":"P6192-【模板】最小斯坦纳树 题目: 题目描述: 给定一个包含 nnn 个结点和 mmm 条带权边的无向连通图 G=(V,E)G=(V, E)G=(V,E)。 再给定包含 kkk 个结点的点集 SSS，选出 GGG 的子图 G′=(V′,E′)G'=(V', E')G′=(V′,E′)，使得： S⊆V′S\\subseteq V'S⊆V′； G′G'G′ 为连通图； E′E'E′ 中所有边的权值和最小。 你只需要求出 E′E'E′ 中所有边的权值和。 输入格式: 第一行：三个整数 n,m,kn, m, kn,m,k，表示 GGG 的结点数、边数和 SSS 的大小。 接下来 mmm 行：每行三个整数 u,v,wu, v, wu,v,w，表示编号为 u,vu, vu,v 的点之间有一条权值为 www 的无向边。 接下来一行：kkk 个互不相同的正整数，表示 SSS 的元素。 输出格式: 第一行：一个整数，表示 E′E'E′ 中边权和的最小值。 样例: 样例输入 1: 7 7 4 1 2 3 2 3 2 4 3 9 2 6 2 4 5 3 6 5 2 7 6 4 2 4 7 5 样例输出 1: 11 思路: 记fi,sf_{i, s}fi,s​表示第 i 个点联通状态为 s 的最小代价 可以得到状态转移方程： fi,s=min{fi,ss+fi,s⊕ssss∈sfj,s+wi,j1≤j≤nf_{i, s}=min\\begin{cases}f_{i, ss}+f_{i, s\\oplus ss}\u0026 \u0026 ss\\in{s}\\\\f_{j, s}+w_{i, j}\u0026 \u0026 1\\leq j\\leq n\\end{cases}fi,s​=min{fi,ss​+fi,s⊕ss​fj,s​+wi,j​​​ss∈s1≤j≤n​实现: #include \"ybwhead/ios.h\" int n, m, k; const int maxn = 1e3 + 10; struct edge { int v, w, nxt; } e[maxn \u003c\u003c 1]; int head[maxn], tot; void __ADD(int u, int v, int w) { e[++tot].v = v; e[tot].w = w; e[tot].nxt = head[u]; head[u] = tot; } void add(int u, int v, int w) { __ADD(u, v, w); __ADD(v, u, w); } priority_queue\u003cpair\u003cint, int\u003e\u003e q; int f[maxn][maxn \u003c\u003c 1]; void dij(int s) { while (!q.empty()) { int x = q.top().second; q.pop(); for (int i = head[x]; i; i = e[i].nxt) { int v = e[i].v; if (f[v][s] \u003e e[i].w + f[x][s]) { f[v][s] = e[i].w + f[x][s]; q.push(make_pair(-f[v][s], v)); } } } } int ma; int p[maxn]; int main() { yin \u003e\u003e n \u003e\u003e m \u003e\u003e k; memset(f, 0x3f3f3f3f, sizeof(f)); for (int i = 1; i \u003c= m; i++) { int u, v, w; yin \u003e\u003e u \u003e\u003e v \u003e\u003e w; add(u, v, w); } for (int i = 1; i \u003c= k; i++) { yin \u003e\u003e p[i]; f[p[i]][1 \u003c\u003c (i - 1)] = 0; } ma = (1 \u003c\u003c k) - 1; for (int s = 0; s \u003c= ma; s++) { for (int i = 1; i \u003c= n; i++) { for (int ss = (s - 1) \u0026 s; ss; ss = (ss - 1) \u0026 s) { f[i][s] = min(f[i][ss] + f[i][s ^ ss], f[i][s]); } if (f[i][s] != 0x3f3f3f3f) q.push(make_pair(-f[i][s], i)); } dij(s); } yout \u003c\u003c f[p[1]][ma] \u003c\u003c endl; return 0; } ","date":"2020-07-30","objectID":"/posts/oi/problems/p6192/:0:0","series":null,"tags":["dp","图论","状态压缩, 状压","最短路","Notebooks/OI/OJ/Luogu"],"title":"P6192-【模板】最小斯坦纳树","uri":"/posts/oi/problems/p6192/#"},{"categories":null,"content":"CF1366G-Construct the String 题目: 题目描述: Let’s denote the function f(s) f(s) f(s) that takes a string s s s consisting of lowercase Latin letters and dots, and returns a string consisting of lowercase Latin letters as follows: let r r r be an empty string; process the characters of s s s from left to right. For each character c c c , do the following: if c c c is a lowercase Latin letter, append c c c at the end of the string r r r ; otherwise, delete the last character from r r r (if r r r is empty before deleting the last character — the function crashes); return r r r as the result of the function. You are given two strings s s s and t t t . You have to delete the minimum possible number of characters from s s s so that f(s)=t f(s) = t f(s)=t (and the function does not crash). Note that you aren’t allowed to insert new characters into s s s or reorder the existing ones. 输入格式: The input consists of two lines: the first one contains s s s — a string consisting of lowercase Latin letters and dots, the second one contains t t t — a string consisting of lowercase Latin letters ( 1≤∣t∣≤∣s∣≤10000 1 \\le |t| \\le |s| \\le 10000 1≤∣t∣≤∣s∣≤10000 ). Additional constraint on the input: it is possible to remove some number of characters from s s s so that f(s)=t f(s) = t f(s)=t . 输出格式: Print one integer — the minimum possible number of characters you have to delete from s s s so f(s) f(s) f(s) does not crash and returns t t t as the result of the function. 样例: 样例输入 1: a.ba.b. abb 样例输出 1: 2 样例输入 2: .bbac..a.c.cd bacd 样例输出 2: 3 样例输入 3: c..code..c...o.d.de code 样例输出 3: 3 思路: 首先有一个很显然的思路，dpi,jdp_{i,j}dpi,j​ 表示 s1⋯is_{1\\cdots i}s1⋯i​ 匹配t1⋯jt_{1\\cdots j}t1⋯j​要删掉的字符的最小值。 dpi,j=min{dpi−1,j+1dpi−1,j−1si=tjdpi−1,jsi=′.′dp_{i,j}=min\\begin{cases}dp_{i-1,j}+1\\\\dp_{i-1,j-1}\u0026 \u0026 s_i=t_j\\\\dp_{i-1,j}\u0026 \u0026 si='.'\u0026\\end{cases}dpi,j​=min⎩⎨⎧​dpi−1,j​+1dpi−1,j−1​dpi−1,j​​​si​=tj​si=′.′​​然后我们发现它是假的，因为有可能存在先有一段字符，之后又会出现一段删除 所以我们可以统计一个 nxt 表示上一个清空的位置即可 现在式子变成 dpi,j=min{dpnxti,j+1dpi−1,j−1si=tjdpi−1,jsi=′.′dp_{i,j}=min\\begin{cases}dp_{nxt_i,j}+1\\\\dp_{i-1,j-1}\u0026 \u0026 s_i=t_j\\\\dp_{i-1,j}\u0026 \u0026 si='.'\u0026\\end{cases}dpi,j​=min⎩⎨⎧​dpnxti​,j​+1dpi−1,j−1​dpi−1,j​​​si​=tj​si=′.′​​注意程序中的 nxt 表示下一个清空的位置。 实现: #include \"ybwhead/ios.h\" using namespace std; string s, t; const int maxn = 1e4 + 10; int dp[maxn][maxn]; int nxt[maxn]; int main() { yin \u003e\u003e s \u003e\u003e t; for (int i = 0; i \u003c s.size(); i++) { nxt[i] = -1; int bal = 0; if (s[i] != '.') for (int j = i; j \u003c s.size();j++) { if (s[j] == '.') --bal; else ++bal; if (!bal) { nxt[i] = j; break; } } } memset(dp, 0x7f7f7f7f, sizeof(dp)); dp[0][0] = 0; for (int i = 0; i \u003c s.size(); i++) { for (int j = 0; j \u003c= t.size(); j++) { dp[i + 1][j] = min(dp[i + 1][j], dp[i][j] + 1); if (j \u003c t.size() \u0026\u0026 s[i] == t[j]) dp[i + 1][j + 1] = min(dp[i + 1][j + 1], dp[i][j]); if (s[i] != '.' \u0026\u0026 nxt[i] != -1) dp[nxt[i] + 1][j] = min(dp[nxt[i] + 1][j], dp[i][j]); } } yout \u003c\u003c dp[s.size()][t.size()] \u003c\u003c endl; return 0; } ","date":"2020-07-26","objectID":"/posts/oi/problems/cf1366g/:0:0","series":null,"tags":["Notebooks/OI/OJ/Luogu"],"title":"CF1366G-Construct the String","uri":"/posts/oi/problems/cf1366g/#"},{"categories":null,"content":"CF1312G-Autocompletion 题目: 题目描述: You are given a set of strings S S S . Each string consists of lowercase Latin letters. For each string in this set, you want to calculate the minimum number of seconds required to type this string. To type a string, you have to start with an empty string and transform it into the string you want to type using the following actions: if the current string is t t t , choose some lowercase Latin letter c c c and append it to the back of t t t , so the current string becomes t+c t + c t+c . This action takes 1 1 1 second; use autocompletion. When you try to autocomplete the current string t t t , a list of all strings s∈S s \\in S s∈S such that t t t is a prefix of s s s is shown to you. This list includes t t t itself, if t t t is a string from S S S , and the strings are ordered lexicographically. You can transform t t t into the i i i -th string from this list in i i i seconds. Note that you may choose any string from this list you want, it is not necessarily the string you are trying to type. What is the minimum number of seconds that you have to spend to type each string from S S S ? Note that the strings from S S S are given in an unusual way. 输入格式: The first line contains one integer n n n ( 1≤n≤106 1 \\le n \\le 10^6 1≤n≤106 ). Then n n n lines follow, the i i i -th line contains one integer pi p_i pi​ ( 0≤pi\u003ci 0 \\le p_i \u003c i 0≤pi​\u003ci ) and one lowercase Latin character ci c_i ci​ . These lines form some set of strings such that S S S is its subset as follows: there are n+1 n + 1 n+1 strings, numbered from 0 0 0 to n n n ; the 0 0 0 -th string is an empty string, and the i i i -th string ( i≥1 i \\ge 1 i≥1 ) is the result of appending the character ci c_i ci​ to the string pi p_i pi​ . It is guaranteed that all these strings are distinct. The next line contains one integer k k k ( 1≤k≤n 1 \\le k \\le n 1≤k≤n ) — the number of strings in S S S . The last line contains k k k integers a1 a_1 a1​ , a2 a_2 a2​ , …, ak a_k ak​ ( 1≤ai≤n 1 \\le a_i \\le n 1≤ai​≤n , all ai a_i ai​ are pairwise distinct) denoting the indices of the strings generated by above-mentioned process that form the set S S S — formally, if we denote the i i i -th generated string as si s_i si​ , then S=sa1,sa2,…,sak S = {s_{a_1}, s_{a_2}, \\dots, s_{a_k}} S=sa1​​,sa2​​,…,sak​​ . 输出格式: Print k k k integers, the i i i -th of them should be equal to the minimum number of seconds required to type the string sai s_{a_i} sai​​ . 样例: 样例输入 1: 10 0 i 1 q 2 g 0 k 1 e 5 r 4 m 5 h 3 p 3 e 5 8 9 1 10 6 样例输出 1: 2 4 1 3 3 样例输入 2: 8 0 a 1 b 2 a 2 b 4 a 4 b 5 c 6 d 5 2 3 4 7 8 样例输出 2: 1 2 2 4 4 思路: 发现给出的串格式其实就是一个 trietrietrie。 那把 trietrietrie 建出来之后，发现操作就可以变成这样：往自己子节点走，代价 111，以及往自己子树内第 xxx 个关键点走，代价 xxx。 然后可以类似于 dfsdfsdfs 序，只不过如果当前这个位置不在 SSS 里就不加 cntcntcnt，然后子树内的关键点 ididid 就连续了。 连续了之后我们令 dpi=dp_i =dpi​= 到节点 iii 的最少步数，很明显可以从 fafafa 转移，并且还可以从任意一个祖先转移，即 dpi=min⁡(dpanc+idi−idanc+hav_anc)dp_i = \\min(dp_{anc} + id_i - id_{anc} + hav\\_{anc})dpi​=min(dpanc​+idi​−idanc​+hav_anc)，这里的 havhavhav 是指祖先是不是关键点。 然后这个移项后就变成了 dpi=min⁡(dpanc−idanc+hav_anc)+ididp_i = \\min(dp_{anc} - id_{anc} + hav\\_{anc})+id_idpi​=min(dpanc​−idanc​+hav_anc)+idi​​，又因为只有祖先能转移，所以就树上前缀 minminmin 优化一下即可。 实现: #include \"ybwhead/ios.h\" using namespace std; int n; const int maxn = 1e6 + 10; int a[maxn]; int b[maxn]; vector\u003cint\u003e v[maxn]; int tot, tr[maxn][26]; int num[maxn]; int f[maxn]; int ne(int u, int v, int w) { if (!tr[u][w]) tr[u][w] = num[v] = ++tot, f[tot] = u; else num[v] = tr[u][w]; // cout \u003c\u003c u \u003c\u003c \" \" \u003c\u003c v \u003c\u003c \" \" \u003c\u003c w \u003c\u003c \" \" \u003c\u003c endl; return 0; } int dp[maxn]; int up[maxn]; int dfn; void dfs(int u) { dfn += a[u]; dp[u] = min(dp[u], dp[f[u]] + 1); if (a[u]) { dp[u] = min(dp[u], up[f[u]] + dfn); } up[u] = min(up[f[u]], dp[u] - (dfn - a[u])); for (int i = 0; i \u003c 26; i++) if (tr[u][i]) dfs(tr[u][i]); } int main() { yin \u003e\u003e n; num[1] = 1; tot = 1; for (int i = 2; i \u003c= n + 1; i++) { int x; char c; yin \u003e\u003e x \u003e\u003e c; ++x; ne(num[x], i, c - 'a'); } yin \u003e\u003e n; memset(dp, 0x3f, sizeof(dp)); memset(up, 0x3f,","date":"2020-07-26","objectID":"/posts/oi/problems/cf1312g/:0:0","series":null,"tags":["Notebooks/OI/OJ/Luogu"],"title":"CF1312G-Autocompletion","uri":"/posts/oi/problems/cf1312g/#"},{"categories":null,"content":"CF1366F-Jog Around The Graph 题目: 题目描述: You are given a simple weighted connected undirected graph, consisting of n n n vertices and m m m edges. A path in the graph of length k k k is a sequence of k+1 k+1 k+1 vertices v1,v2,…,vk+1 v_1, v_2, \\dots, v_{k+1} v1​,v2​,…,vk+1​ such that for each i i i (1≤i≤k) (1 \\le i \\le k) (1≤i≤k) the edge (vi,vi+1) (v_i, v_{i+1}) (vi​,vi+1​) is present in the graph. A path from some vertex v v v also has vertex v1=v v_1=v v1​=v . Note that edges and vertices are allowed to be included in the path multiple times. The weight of the path is the total weight of edges in it. For each i i i from 1 1 1 to q q q consider a path from vertex 1 1 1 of length i i i of the maximum weight. What is the sum of weights of these q q q paths? Answer can be quite large, so print it modulo 109+7 10^9+7 109+7 . 输入格式: The first line contains a three integers n n n , m m m , q q q ( 2≤n≤2000 2 \\le n \\le 2000 2≤n≤2000 ; n−1≤m≤2000 n - 1 \\le m \\le 2000 n−1≤m≤2000 ; m≤q≤109 m \\le q \\le 10^9 m≤q≤109 ) — the number of vertices in the graph, the number of edges in the graph and the number of lengths that should be included in the answer. Each of the next m m m lines contains a description of an edge: three integers v v v , u u u , w w w ( 1≤v,u≤n 1 \\le v, u \\le n 1≤v,u≤n ; 1≤w≤106 1 \\le w \\le 10^6 1≤w≤106 ) — two vertices v v v and u u u are connected by an undirected edge with weight w w w . The graph contains no loops and no multiple edges. It is guaranteed that the given edges form a connected graph. 输出格式: Print a single integer — the sum of the weights of the paths from vertex 1 1 1 of maximum weights of lengths 1,2,…,q 1, 2, \\dots, q 1,2,…,q modulo 109+7 10^9+7 109+7 . 样例: 样例输入 1: 7 8 25 1 2 1 2 3 10 3 4 2 1 5 2 5 6 7 6 4 15 5 3 1 1 7 3 样例输出 1: 4361 样例输入 2: 2 1 5 1 2 4 样例输出 2: 60 样例输入 3: 15 15 23 13 10 12 11 14 12 2 15 5 4 10 8 10 2 4 10 7 5 3 10 1 5 6 11 1 13 8 9 15 4 4 2 9 11 15 1 11 12 14 10 8 12 3 6 11 样例输出 3: 3250 样例输入 4: 5 10 10000000 2 4 798 1 5 824 5 2 558 4 1 288 3 4 1890 3 1 134 2 3 1485 4 5 284 3 5 1025 1 2 649 样例输出 4: 768500592 思路: 1.先考虑 k≤mk\\leq mk≤m 的情况，可以直接用 O(N×M)O(N\\times M)O(N×M) 的暴力 dp 解决 2.k\u003eMk \u003e Mk\u003eM 时，最长路径的最后一段一定是在一条边上来回走。 考虑枚举最后来回走的那一条边，再枚举走到那条边的时间，时间 一定在 MMM 以内。斜率优化 dp 即可 实现: #include \"ybwhead/ios.h\" #define int long long int n, m; long long q; const int maxn = 2e3 + 10; struct edge { int v, nxt, w; } e[maxn \u003c\u003c 1]; int head[maxn], tot; int hv[maxn]; const int mod = 1e9 + 7; const int inv2 = mod / 2 + 1; void __ADD(int u, int v, int w) { e[++tot].v = v; e[tot].w = w; e[tot].nxt = head[u]; head[u] = tot; hv[v] = max(hv[v], w); } void add(int u, int v, int w) { __ADD(u, v, w); __ADD(v, u, w); } int d[maxn], nd[maxn]; struct frac { long long x, y; frac(long long a, long long b) { if (b \u003c 0) a = -a, b = -b; x = a, y = b; } bool operator\u003c(frac b) { return x * b.y \u003c= y * b.x; } }; struct lin { long long m, c; frac xx(const lin \u0026l) { return frac(c - l.c, l.m - m); } } fi[maxn]; deque\u003clin\u003e ch; int cmp(lin a, lin b) { if (a.m ^ b.m) return a.m \u003c b.m; return a.c \u003e b.c; } int cmp1(lin a, lin b) { return a.m == b.m; } int add(int a, int b) { a += b; if (a \u003e= mod) a -= mod; if (a \u003c 0) a += mod; return a; } int mul(int a, int b) { return a * 1ll * b % mod; } int calc(int a1, int d, int n) { return mul(mul(n, inv2), add(mul(2, a1), mul(add(n, -1), d))); } signed main() { yin \u003e\u003e n \u003e\u003e m \u003e\u003e q; for (int i = 1; i \u003c= m; i++) { int u, v, w; yin \u003e\u003e u \u003e\u003e v \u003e\u003e w; add(u, v, w); } memset(d, -0x7f7f7f7f, sizeof(d)); d[1] = 0; long long ans = 0; for (int x = 1; x \u003c= m; x++) { long long mx = 0; for (int i = 1; i \u003c= n; i++) mx = max(mx, (long long)d[i]); if (x != 1) ans = add(ans, mx % mod); for (int i = 1; i \u003c= n; i++) nd[i] = d[i]; for (int u = 1; u \u003c= n; u++) { for (int i = head[u]; i; i = e[i].nxt) { int v = e[i].v; nd[v] = max(nd[v], d[u] + e[i].w); } } for (int i = 1; i \u003c= n; i++) d[i] = nd[i]; } for (int i = 1; i \u003c= n; i++) fi[i] = (lin){hv[i], d[i]}; sort(fi + 1, fi + n + 1, cmp); int mm = unique(fi + 1, fi + n + 1, cmp","date":"2020-07-26","objectID":"/posts/oi/problems/cf1366f/:0:0","series":null,"tags":["Notebooks/OI/OJ/Luogu"],"title":"CF1366F-Jog Around The Graph","uri":"/posts/oi/problems/cf1366f/#"},{"categories":null,"content":"CF437D-The Child and Zoo 题目: 题目描述: Of course our child likes walking in a zoo. The zoo has n n n areas, that are numbered from 1 1 1 to n n n . The i i i -th area contains ai a_{i} ai​ animals in it. Also there are m m m roads in the zoo, and each road connects two distinct areas. Naturally the zoo is connected, so you can reach any area of the zoo from any other area using the roads. Our child is very smart. Imagine the child want to go from area p p p to area q q q . Firstly he considers all the simple routes from p p p to q q q . For each route the child writes down the number, that is equal to the minimum number of animals among the route areas. Let’s denote the largest of the written numbers as f(p,q) f(p,q) f(p,q) . Finally, the child chooses one of the routes for which he writes down the value f(p,q) f(p,q) f(p,q) . After the child has visited the zoo, he thinks about the question: what is the average value of f(p,q) f(p,q) f(p,q) for all pairs p,q p,q p,q (p≠q) (p≠q) (p=q) ? Can you answer his question? 输入格式: The first line contains two integers n n n and m m m ( 2\u003c=n\u003c=105 2\u003c=n\u003c=10^{5} 2\u003c=n\u003c=105 ; 0\u003c=m\u003c=105 0\u003c=m\u003c=10^{5} 0\u003c=m\u003c=105 ). The second line contains n n n integers: a1,a2,...,an a_{1},a_{2},...,a_{n} a1​,a2​,...,an​ ( 0\u003c=ai\u003c=105 0\u003c=a_{i}\u003c=10^{5} 0\u003c=ai​\u003c=105 ). Then follow m m m lines, each line contains two integers xi x_{i} xi​ and yi y_{i} yi​ ( 1\u003c=xi,yi\u003c=n 1\u003c=x_{i},y_{i}\u003c=n 1\u003c=xi​,yi​\u003c=n ; xi≠yi x_{i}≠y_{i} xi​=yi​ ), denoting the road between areas xi x_{i} xi​ and yi y_{i} yi​ . All roads are bidirectional, each pair of areas is connected by at most one road. 输出格式: Output a real number — the value of . The answer will be considered correct if its relative or absolute error doesn’t exceed 10−4 10^{-4} 10−4 . 样例: 样例输入1: 4 3 10 20 30 40 1 3 2 3 4 3 样例输出1: 16.666667 样例输入2: 3 3 10 20 30 1 2 2 3 3 1 样例输出2: 13.333333 样例输入3: 7 8 40 20 10 30 20 50 40 1 2 2 3 3 4 4 5 5 6 6 7 1 4 5 7 样例输出3: 18.571429 思路: 实现: #include \"ybwhead/ios.h\" int n, m; const int maxn = 3e5; int a[maxn]; struct node { int x, y, z; } b[maxn]; int cmp(node a, node b) { return a.z \u003e b.z; } int f[maxn]; int g[maxn]; int gf(int x) { if (f[x] == x) return x; return f[x] = gf(f[x]); } int main() { yin \u003e\u003e n \u003e\u003e m; for (int i = 1; i \u003c= n; i++) yin \u003e\u003e a[i]; for (int i = 1; i \u003c= m; i++) { yin \u003e\u003e b[i].x \u003e\u003e b[i].y; b[i].z = min(a[b[i].x], a[b[i].y]); } sort(b + 1, b + m + 1, cmp); for (int i = 1; i \u003c= n; i++) f[i] = i, g[i] = 1; double ans = 0; for (int i = 1; i \u003c= m; i++) { int x = gf(b[i].x), y = gf(b[i].y); if (x == y) continue; f[x] = y; ans += (long long)b[i].z * g[x] * g[y]; // cout \u003c\u003c x \u003c\u003c ' ' \u003c\u003c y \u003c\u003c endl; // cout \u003c\u003c ans \u003c\u003c \" \" \u003c\u003c b[i].z \u003c\u003c ' ' \u003c\u003c g[x] \u003c\u003c ' ' \u003c\u003c g[y] \u003c\u003c endl; g[y] += g[x]; } // cout \u003c\u003c ans \u003c\u003c endl; cout \u003c\u003c ans / n / (n - 1) * 2 \u003c\u003c endl; return 0; } ","date":"2020-07-25","objectID":"/posts/oi/problems/cf437d/:0:0","series":null,"tags":["Notebooks/OI/OJ/Luogu"],"title":"CF437D-The Child and Zoo","uri":"/posts/oi/problems/cf437d/#"},{"categories":null,"content":"P1550-[USACO08OCT]Watering Hole G 题目: 题目描述: Farmer John 的农场缺水了。 他决定将水引入到他的 nnn（1≤n≤3001 \\leq n \\leq 3001≤n≤300）个牧场。他准备通过挖若干井，并在各块田中修筑水道来连通各块田地以供水。在第 iii 号田中挖一口井需要花费 WiW_iWi​（1≤Wi≤1051 \\leq W_i \\leq 10^51≤Wi​≤105）元。连接 iii 号田与 jjj 号田需要 Pi,jP_{i,j}Pi,j​（1≤Pi,j≤1051 \\leq P_{i,j} \\leq 10^51≤Pi,j​≤105，且 Pj,i=Pi,jP_{j,i}=P_{i,j}Pj,i​=Pi,j​）元。 请求出 FJ 需要为使所有农场都与有水的农场相连或拥有水井所需要的最少钱数。 输入格式: 第一行为一个整数 nnn。 接下来 nnn 每行一个整数 WiW_iWi​。 接下来 nnn 行，每行 nnn 个整数，第 iii 行的第 jjj 个数表示连接 iii 号田和 jjj 号田需要的费用 Pi,jP_{i,j}Pi,j​。 输出格式: 输出最小开销。 样例: 样例输入1: 4 5 4 4 3 0 2 2 2 2 0 3 3 2 3 0 4 2 3 4 0 样例输出1: 9 思路: 实现: #include \"ybwhead/ios.h\" int n; struct bi { int a, b, c; } e[100001]; int f[10001]; int find(int x) { if (f[x] == x) return x; return f[x] = find(f[x]); } int cmp(bi a, bi b) { return a.c \u003c b.c; } int main() { yin \u003e\u003e n; for (int i = 1; i \u003c= n; i++) { int t; yin \u003e\u003e t; e[i].a = 0; e[i].b = i; e[i].c = t; } int sum = n; for (int i = 1; i \u003c= n; i++) { for (int j = 1; j \u003c= n; j++) { int c; yin \u003e\u003e c; if (c) { e[++sum].a = i; e[sum].b = j; e[sum].c = c; } } } sort(e + 1, e + sum + 1, cmp); int ans = 0; for (int i = 1; i \u003c= n; i++) f[i] = i; for (int i = 1; i \u003c= sum; i++) { int sa = find(e[i].a), sb = find(e[i].b); if (sa != sb) { f[sa] = sb; ans += e[i].c; } } yout \u003c\u003c ans \u003c\u003c endl; return 0; } ","date":"2020-07-24","objectID":"/posts/oi/problems/p1550/:0:0","series":null,"tags":["图论","贪心",2008,"USACO","Notebooks/OI/OJ/Luogu"],"title":"P1550-[USACO08OCT]Watering Hole G","uri":"/posts/oi/problems/p1550/#"},{"categories":null,"content":"P4208-[JSOI2008]最小生成树计数 题目: 题目描述: 现在给出了一个简单无向加权图。你不满足于求出这个图的最小生成树，而希望知道这个图中有多少个不同的最小生成树。（如果两颗最小生成树中至少有一条边不同，则这两个最小生成树就是不同的）。由于不同的最小生成树可能很多，所以你只需要输出方案数对31011的模就可以了。 输入格式: 第一行包含两个数，n和m，其中1\u003c=n\u003c=100; 1\u003c=m\u003c=1000; 表示该无向图的节点数和边数。每个节点用1~n的整数编号。 接下来的m行，每行包含两个整数：a, b, c，表示节点a, b之间的边的权值为c，其中1\u003c=c\u003c=1,000,000,000。 数据保证不会出现自回边和重边。注意：具有相同权值的边不会超过10条。 输出格式: 输出不同的最小生成树有多少个。你只需要输出数量对31011的模就可以了。 样例: 样例输入1: 4 6 1 2 1 1 3 1 1 4 1 2 3 2 2 4 1 3 4 1 样例输出1: 8 思路: 实现: #include \"ybwhead/ios.h\" const int maxn = 1e3 + 10; const int mod = 31011; struct Edge { int now, to, val; } edge[maxn]; struct Mintree { int l, r, val; } mintree[maxn]; int fa[maxn]; int n, m, sum; int cmp(Edge a, Edge b) { return a.val \u003c b.val; } int findfa(int x) { if (x == fa[x]) return x; return x = findfa(fa[x]); } void dfs(int x, int now, int k) { if (now == mintree[x].r + 1) { if (k == mintree[x].val) sum++; return; } int fax = findfa(edge[now].now), fay = findfa(edge[now].to); if (fax != fay) { fa[fax] = fay; dfs(x, now + 1, k + 1); fa[fax] = fax; fa[fay] = fay; } dfs(x, now + 1, k); } int main() { cin \u003e\u003e n \u003e\u003e m; for (int i = 1; i \u003c= n; i++) { fa[i] = i; } for (int i = 1; i \u003c= m; i++) { cin \u003e\u003e edge[i].now \u003e\u003e edge[i].to \u003e\u003e edge[i].val; } sort(edge + 1, edge + m + 1, cmp); int cnt = 0, cntt = 0; for (int i = 1; i \u003c= m; i++) { if (edge[i].val != edge[i - 1].val) { cnt++; mintree[cnt].l = i; mintree[cnt - 1].r = i - 1; } int fax = findfa(edge[i].now); int fay = findfa(edge[i].to); if (fax != fay) { fa[fax] = fay; mintree[cnt].val++; cntt++; } } mintree[cnt].r = m; if (cntt != n - 1) { yout \u003c\u003c 0 \u003c\u003c endl; return 0; } int ans = 1; for (int i = 1; i \u003c= n; i++) fa[i] = i; for (int i = 1; i \u003c= cnt; i++) { sum = 0; dfs(i, mintree[i].l, 0); ans = (ans * sum) % mod; for (int j = mintree[i].l; j \u003c= mintree[i].r; j++) { int fax = findfa(edge[j].now), fay = findfa(edge[j].to); if (fax != fay) fa[fax] = fay; } } yout \u003c\u003c ans \u003c\u003c endl; return 0; } ","date":"2020-07-24","objectID":"/posts/oi/problems/p4208/:0:0","series":null,"tags":[2008,"并查集","各省省选","江苏","生成树","素数判断,质数,筛法","高斯消元","Notebooks/OI/OJ/Luogu"],"title":"P4208-[JSOI2008]最小生成树计数","uri":"/posts/oi/problems/p4208/#"},{"categories":null,"content":"CF962F-Simple Cycles Edges 题目: 题目描述: You are given an undirected graph, consisting of n n n vertices and m m m edges. The graph does not necessarily connected. Guaranteed, that the graph does not contain multiple edges (more than one edges between a pair of vertices) or loops (edges from a vertex to itself). A cycle in a graph is called a simple, if it contains each own vertex exactly once. So simple cycle doesn’t allow to visit a vertex more than once in a cycle. Determine the edges, which belong to exactly on one simple cycle. 输入格式: The first line contain two integers n n n and m m m (1≤n≤100 000 (1 \\le n \\le 100\\,000 (1≤n≤100000 , 0≤m≤min⁡(n⋅(n−1)/2,100 000)) 0 \\le m \\le \\min(n \\cdot (n - 1) / 2, 100\\,000)) 0≤m≤min(n⋅(n−1)/2,100000)) — the number of vertices and the number of edges. Each of the following m m m lines contain two integers u u u and v v v ( 1≤u,v≤n 1 \\le u, v \\le n 1≤u,v≤n , u≠v u \\neq v u=v ) — the description of the edges. 输出格式: In the first line print the number of edges, which belong to exactly one simple cycle. In the second line print the indices of edges, which belong to exactly one simple cycle, in increasing order. The edges are numbered from one in the same order as they are given in the input. 样例: 样例输入 1: 3 3 1 2 2 3 3 1 样例输出 1: 3 1 2 3 样例输入 2: 6 7 2 3 3 4 4 2 1 2 1 5 5 6 6 1 样例输出 2: 6 1 2 3 5 6 7 样例输入 3: 5 6 1 2 2 3 2 4 4 3 2 5 5 3 样例输出 3: 0 思路: 实现: #include \"ybwhead/ios.h\" int n, m; const int maxn = 1e5 + 10; int tot = 1, head[maxn]; struct edge { int v, nxt, tr; } e[maxn \u003c\u003c 1]; void __ADD(int u, int v) { e[++tot].v = v; e[tot].nxt = head[u]; head[u] = tot; } void add(int a, int b) { __ADD(a, b); __ADD(b, a); } int ans; int vis[maxn]; int a[maxn]; int dep[maxn]; int tof[maxn]; int f[maxn]; int sum[maxn]; void dfs(int u, int fa) { vis[u] = 1; dep[u] = dep[fa] + 1; f[u] = fa; for (int i = head[u]; i; i = e[i].nxt) { int v = e[i].v; if (v == fa) continue; // cout \u003c\u003c u \u003c\u003c ' ' \u003c\u003c v \u003c\u003c endl; if (vis[v]) { if (dep[u] \u003e dep[v]) sum[v]--, sum[u]++; } else dfs(v, u), e[i].tr = e[i ^ 1].tr = 1, tof[v] = i; } } vector\u003cint\u003e ans1; void dfs1(int u, int fa, int deep) { // cout \u003c\u003c u \u003c\u003c vis[5] \u003c\u003c endl; vis[u] = 1; // cout \u003c\u003c u \u003c\u003c \" \" \u003c\u003c deep \u003c\u003c \" \" \u003c\u003c sum[u] \u003c\u003c endl; deep = sum[u] == 1 ? deep : dep[u] + 1; for (int i = head[u]; i; i = e[i].nxt) { int v = e[i].v; if (v == fa) continue; if (!vis[v]) dfs1(v, u, deep); else { if (dep[v] + 1 \u003e= deep \u0026\u0026 dep[u] \u003e dep[v]) { int uu = u, vv = v; ans1.push_back(i / 2); while (uu != vv) { ans1.push_back(tof[uu] / 2); // cout \u003c\u003c uu \u003c\u003c ' ' \u003c\u003c v \u003c\u003c endl; uu = f[uu]; } } } } } void dfs2(int u, int fa) { vis[u] = 1; for (int i = head[u]; i; i = e[i].nxt) { int v = e[i].v; if (v == fa) continue; if (!vis[v]) { dfs2(v, u); sum[u] += sum[v]; } } // cout \u003c\u003c u \u003c\u003c \" \" \u003c\u003c sum[u] \u003c\u003c endl; } int main() { yin \u003e\u003e n \u003e\u003e m; for (int i = 1; i \u003c= m; i++) { int a, b; yin \u003e\u003e a \u003e\u003e b; add(a, b); } for (int i = 1; i \u003c= n; i++) if (!vis[i]) dfs(i, 0); memset(vis, 0, sizeof(vis)); // cout \u003c\u003c vis[5] \u003c\u003c endl; for (int i = 1; i \u003c= n; i++) if (!vis[i]) dfs2(i, 0); memset(vis, 0, sizeof(vis)); for (int i = 1; i \u003c= n; i++) if (!vis[i]) dfs1(i, 0, 1); sort(ans1.begin(), ans1.end()); yout \u003c\u003c ans1.size() \u003c\u003c endl; for (int i = 0; i \u003c ans1.size(); i++) yout \u003c\u003c ans1[i] \u003c\u003c \" \"; return 0; } ","date":"2020-07-22","objectID":"/posts/oi/problems/cf962f/:0:0","series":null,"tags":["搜索","枚举,暴力","差分","Notebooks/OI/OJ/Luogu"],"title":"CF962F-Simple Cycles Edges","uri":"/posts/oi/problems/cf962f/#"},{"categories":null,"content":"P2065-[TJOI2011]卡片 题目: 题目描述: 桌子上现在有m张蓝色卡片和n张红色卡片，每张卡片上有一个大于1的整数。现在你要从桌子上拿走一些卡片，分若干次拿。每次只能拿走一组卡片：这组卡片颜色不同，并且两张卡片上面的数字的最大公约数大于1。问：最多可以从桌上拿走多少张卡片。 输入格式: 每个输入文件中包含多组测试数据，每个文件中测试数据的数目不超过100。 文件的第一行读入一个整数T，为数据组数。 每组数据的格式如下： m n b1 b2 … bm r1 r2 … rn 第二行给出每张蓝色卡片上面的数字，第三行给出每张红色卡片上的数字。 输出格式: 对每组测试数据，输出最多可以拿走多少张卡片。 样例: 样例输入1: 7 4 3 2 6 6 15 2 3 5 2 3 4 9 8 16 32 4 2 4 9 11 13 5 7 5 5 2 3 5 1001 1001 7 11 13 30 30 10 10 2 3 5 7 9 11 13 15 17 29 4 6 10 14 18 22 26 30 34 38 20 20 195 144 903 63 137 513 44 626 75 473 876 421 568 519 755 840 374 368 570 872 363 650 155 265 64 26 426 391 15 421 373 984 564 54 823 477 565 866 879 638 100 100 195 144 903 63 137 513 44 626 75 473 876 421 568 519 755 840 374 368 570 872 363 650 155 265 64 26 426 391 15 421 373 984 564 54 823 477 565 866 879 638 117 755 835 683 52 369 302 424 513 870 75 874 299 228 140 361 30 342 750 819 761 123 804 325 952 405 578 517 49 457 932 941 988 767 624 41 912 702 241 426 351 92 300 648 318 216 785 347 556 535 166 318 434 746 419 386 928 996 680 975 231 390 916 220 933 319 37 846 797 54 272 924 145 348 350 239 563 135 362 119 446 305 213 879 51 631 43 755 405 499 509 412 887 203 408 821 298 443 445 96 274 715 796 417 839 147 654 402 280 17 298 725 98 287 382 923 694 201 679 99 699 188 288 364 389 694 185 464 138 406 558 188 897 354 603 737 277 35 139 556 826 213 59 922 499 217 846 193 416 525 69 115 489 355 256 654 49 439 118 961 样例输出1: 3 1 0 4 9 18 85 思路: 实现: #include \"ybwhead/ios.h\" int m, n; const int maxn = 1e5 + 10; const int maxm = 1e6 + 10; struct edge { int v, w, nxt; } e[maxm \u003c\u003c 1]; int tot = 1, head[maxn]; void __ADD(int u, int v, int w) { e[++tot].v = v; e[tot].w = w; e[tot].nxt = head[u]; head[u] = tot; } void add(int u, int v) { __ADD(u, v, 1); __ADD(v, u, 0); } void clear() { tot = 1; memset(head, 0, sizeof(head)); } bitset\u003c1000010\u003e not_prime; bitset\u003c100010\u003e used; int prime[maxn]; int pnum; inline void Get_Prime() { not_prime[1] = 1; for (int i = 2; i \u003c= 1000010; i++) { if (!not_prime[i]) prime[++pnum] = i; for (int j = 1; j \u003c= pnum \u0026\u0026 i * prime[j] \u003c= 1000010; j++) { not_prime[i * prime[j]] = 1; if (i % prime[j] == 0) break; } } } int de[maxn]; int pre[maxn]; int s, t; int bfs() { memset(de, 0, sizeof(de)); memset(pre, -1, sizeof(pre)); queue\u003cint\u003e q; q.push(s); de[s] = 1; while (!q.empty()) { int u = q.front(); q.pop(); for (int i = head[u]; i; i = e[i].nxt) { int v = e[i].v; if (!de[v] \u0026\u0026 e[i].w) { de[v] = de[u] + 1; q.push(v); } } } if (de[t]) return 1; return 0; } int dfs(int u, int liu) { // cout \u003c\u003c u \u003c\u003c endl; if (u == t) return liu; for (int i = head[u]; i; i = e[i].nxt) { int v = e[i].v; if (de[v] == de[u] + 1 \u0026\u0026 e[i].w) { int di = dfs(v, min(liu, e[i].w)); if (di) { e[i].w -= di; e[i ^ 1].w += di; return di; } } } return 0; } int dinic() { int ans = 0; while (bfs()) { while (int l = dfs(s, INT_MAX)) ans += l; // cout \u003c\u003c ans \u003c\u003c endl; } return ans; } int main() { int TTT; Get_Prime(); yin \u003e\u003e TTT; while (TTT--) { clear(); yin \u003e\u003e n \u003e\u003e m; s = 0; t = n + m + pnum + 1; for (int i = 1; i \u003c= n; i++) { int x; yin \u003e\u003e x; for (int j = 1; prime[j] \u003c= x; j++) if (x % prime[j] == 0) { add(i, n + m + j); while (x % prime[j] == 0) x /= prime[j]; } add(0, i); } for (int i = 1; i \u003c= m; i++) { int x; yin \u003e\u003e x; for (int j = 1; prime[j] \u003c= x; j++) if (x % prime[j] == 0) { add(n + m + j, i + n); while (x % prime[j] == 0) x /= prime[j]; } add(i + n, t); } yout \u003c\u003c dinic() \u003c\u003c endl; } return 0; } ","date":"2020-07-19","objectID":"/posts/oi/problems/p2065/:0:0","series":null,"tags":[2011,"各省省选","高性能","天津","Notebooks/OI/OJ/Luogu"],"title":"P2065-[TJOI2011]卡片","uri":"/posts/oi/problems/p2065/#"},{"categories":null,"content":"P4035-[JSOI2008]球形空间产生器 题目: 题目描述: 有一个球形空间产生器能够在 nnn 维空间中产生一个坚硬的球体。现在，你被困在了这个 nnn 维球体中，你只知道球面上 n+1n+1n+1 个点的坐标，你需要以最快的速度确定这个 nnn 维球体的球心坐标，以便于摧毁这个球形空间产生器。 输入格式: 第一行是一个整数 nnn (1\u003c=N=10)(1\u003c=N=10)(1\u003c=N=10)。接下来的 n+1n+1n+1 行，每行有 nnn 个实数，表示球面上一点的 nnn 维坐标。每一个实数精确到小数点后 666 位，且其绝对值都不超过 200002000020000。 输出格式: 有且只有一行，依次给出球心的 nnn 维坐标（ nnn 个实数），两个实数之间用一个空格隔开。每个实数精确到小数点后 333 位。数据保证有解。你的答案必须和标准输出一模一样才能够得分。 样例: 样例输入1: 2 0.0 0.0 -1.0 1.0 1.0 0.0 样例输出1: 0.500 1.500 思路: 实现: #include \"ybwhead/ios.h\" using namespace std; int n; double c[111][111], a[111][111]; int main() { yin \u003e\u003e n; for (int i = 1; i \u003c= n + 1; i++) { for (int j = 1; j \u003c= n; j++) { yin \u003e\u003e c[i][j]; } } for (int i = 1; i \u003c= n; i++) { for (int j = 1; j \u003c= n; j++) { a[i][j] = 2 * (c[i][j] - c[i + 1][j]); a[i][n + 1] += c[i][j] * c[i][j] - c[i + 1][j] * c[i + 1][j]; } } for (int i = 1; i \u003c= n; i++) { int mx = i; for (int j = i + 1; j \u003c= n; j++) { if (fabs(a[i][j]) \u003e fabs(a[i][mx])) mx = j; } for (int j = 1; j \u003c= n + 1; j++) { swap(a[i][j], a[mx][j]); } if (!a[i][i]) { puts(\"No Solution\"); return 0; } for (int j = 1; j \u003c= n; j++) { if (j != i) { double tmp = a[j][i] / a[i][i]; for (int k = i + 1; k \u003c= n + 1; k++) { a[j][k] -= a[i][k] * tmp; } } } } for (int i = 1; i \u003c= n; i++) { printf(\"%.3lf \", a[i][n + 1] / a[i][i]); } return 0; } ","date":"2020-07-19","objectID":"/posts/oi/problems/p4035/:0:0","series":null,"tags":[2008,"各省省选","江苏","模拟退火","高斯消元","构造","Notebooks/OI/OJ/Luogu"],"title":"P4035-[JSOI2008]球形空间产生器","uri":"/posts/oi/problems/p4035/#"},{"categories":null,"content":"P3389-【模板】高斯消元法 题目: 题目描述: 给定一个线性方程组，对其求解 输入格式: 第一行，一个正整数 nnn 第二至 n+1n+1n+1行，每行 n+1n+1n+1 个整数，为a1,a2⋯an a_1, a_2 \\cdots a_na1​,a2​⋯an​ 和 bbb，代表一组方程。 输出格式: 共n行，每行一个数，第 iii行为 xix_ixi​ （保留2位小数） 如果不存在唯一解，在第一行输出\"No Solution\". 样例: 样例输入1: 3 1 3 4 5 1 4 7 3 9 3 2 2 样例输出1: -0.97 5.18 -2.39 思路: 实现: #include \"ybwhead/ios.h\" using namespace std; int n; const int maxn = 101; double a[maxn][maxn]; int main() { yin \u003e\u003e n; for (int i = 1; i \u003c= n; i++) { for (int j = 1; j \u003c= n + 1; j++) { yin \u003e\u003e a[i][j]; } } for (int i = 1; i \u003c= n; i++) { int mx = i; for (int j = i + 1; j \u003c= n; j++) { if (fabs(a[i][j]) \u003e fabs(a[i][mx])) mx = j; } for (int j = 1; j \u003c= n + 1; j++) { swap(a[i][j], a[mx][j]); } if (!a[i][i]) { puts(\"No Solution\"); return 0; } for (int j = 1; j \u003c= n; j++) { if (j != i) { double tmp = a[j][i] / a[i][i]; for (int k = i + 1; k \u003c= n + 1; k++) { a[j][k] -= a[i][k] * tmp; } } } } for (int i = 1; i \u003c= n; i++) { printf(\"%.2lf\\n\", a[i][n + 1] / a[i][i]); } return 0; } ","date":"2020-07-18","objectID":"/posts/oi/problems/p3389/:0:0","series":null,"tags":["线性代数","高斯消元","Notebooks/OI/OJ/Luogu"],"title":"P3389-【模板】高斯消元法","uri":"/posts/oi/problems/p3389/#"},{"categories":null,"content":"P6626-[省选联考 2020 B 卷] 消息传递 题目: 题目描述: 给定一个包含 nnn 个人（从 111 到 nnn 编号）的树形社交网络。如果一个人在某天收到了一条消息，则下一天他会将消息传递给所有与他有直接社交关系的人。 现在有 mmm 次询问，每次询问假定第 000 天 xxx 号人收到了一条消息，请你计算第 kkk 天时新收到此条消息的人数（即第 kkk 天前收到过此条消息的人不计入其中）。不同询问间互不影响。 输入格式: 本题包含多组测试数据。 第一行一个整数 TTT，为测试数据组数。 对于每组测试数据： 第一行两个数 n,mn,mn,m 分别表示树形社交网络的人数和询问的数量。 接下来 n−1n - 1n−1 行，每行两个数 a,ba, ba,b，表示 aaa 号人和 bbb 号人之间有直接社交关系。保证输入的是树形社交网络。 接下来 mmm 行，每行两个数 x,kx, kx,k，意义见题目描述。 输出格式: 对于每组测试数据：输出 mmm 行，每行一个数表示询问的答案。 样例: 样例输入1: 1 4 2 1 2 2 3 3 4 1 1 2 2 样例输出1: 1 1 思路: 实现: #include \"ybwhead/ios.h\" int n, m; const int maxn = 1e5 + 10; int head[maxn], tot; struct edge { int v, nxt; } e[maxn \u003c\u003c 1]; void __ADD(int u, int v) { e[++tot].v = v; e[tot].nxt = head[u]; head[u] = tot; } void add(int u, int v) { __ADD(u, v); __ADD(v, u); } int pos, tmp; int w[maxn], v[maxn]; int dep[maxn], sz[maxn], c[maxn]; vector\u003cpair\u003cint, int\u003e\u003e q[maxn]; int ans[maxn]; int sum; int siz[maxn]; int ms[maxn]; int rt; int vis[maxn]; void gr(int u, int fa) { // cout \u003c\u003c u \u003c\u003c endl; siz[u] = ms[u] = 1; for (int i = head[u]; i; i = e[i].nxt) { int v = e[i].v; if (v != fa \u0026\u0026 !vis[v]) { gr(v, u); siz[u] += siz[v]; if (siz[v] \u003e ms[u]) ms[u] = siz[v]; } } ms[u] = max(ms[u], sum - siz[u]); if (ms[u] \u003c ms[rt]) rt = u; } int xp[maxn]; void getdep(int u, int fa) { // cout \u003c\u003c u \u003c\u003c endl; ++xp[dep[u]]; for (int i = head[u]; i; i = e[i].nxt) { int v = e[i].v; if (vis[v] || v == fa) continue; dep[v] = dep[u] + 1; getdep(v, u); } } void remove(int u, int fa, int d) { xp[dep[u]] += d; for (int i = head[u]; i; i = e[i].nxt) { int v = e[i].v; if (v != fa \u0026\u0026 !vis[v]) { remove(v, u, d); } } } void getans(int u, int fa) { // cout \u003c\u003c u \u003c\u003c endl; for (int i = 0; i \u003c q[u].size(); ++i) { int k = q[u][i].first - dep[u]; if (k \u003c 0) continue; ans[q[u][i].second] += xp[k]; } for (int i = head[u]; i; i = e[i].nxt) { int v = e[i].v; if (v == fa || vis[v]) continue; getans(v, u); } } void ga(int u) { // cout \u003c\u003c u \u003c\u003c endl; int mxd = 0; dep[u] = 0; getdep(u, 0); for (int i = 0; i \u003c q[u].size(); i++) { int k = q[u][i].first; ans[q[u][i].second] += xp[k]; } for (int i = head[u]; i; i = e[i].nxt) { int v = e[i].v; if (!vis[v]) { remove(v, u, -1); getans(v, u); remove(v, u, 1); } } remove(u, 0, -1); } void solve(int u) { vis[u] = 1; ga(u); for (int i = head[u]; i; i = e[i].nxt) { int v = e[i].v; if (vis[v]) continue; rt = 0; ms[0] = INT_MAX; sum = siz[v]; gr(v, u); solve(rt); } } void clear() { memset(head, 0, sizeof(head)); tot = 0; memset(ans, 0, sizeof(ans)); memset(vis, 0, sizeof(vis)); for (int i = 1; i \u003c= n; ++i) { q[i].clear(); } } int main() { int TTT; yin \u003e\u003e TTT; while (TTT--) { clear(); yin \u003e\u003e n \u003e\u003e m; for (int i = 1; i \u003c n; i++) { int a, b; yin \u003e\u003e a \u003e\u003e b; add(a, b); } for (int i = 1; i \u003c= m; i++) { int x, y; yin \u003e\u003e x \u003e\u003e y; q[x].push_back(make_pair(y, i)); } sum = n; ms[0] = INT_MAX; gr(1, 0); solve(rt); for (int i = 1; i \u003c= m; i++) { yout \u003c\u003c ans[i] \u003c\u003c endl; } } return 0; } ","date":"2020-07-18","objectID":"/posts/oi/problems/p6626/:0:0","series":null,"tags":[2020,"各省省选","Notebooks/OI/OJ/Luogu"],"title":"P6626-[省选联考 2020 B 卷] 消息传递","uri":"/posts/oi/problems/p6626/#"},{"categories":null,"content":"P6329-【模板】点分树 | 震波 题目: 题目描述: 在一片土地上有 nnn 个城市，通过 n−1n-1n−1 条无向边互相连接，形成一棵树的结构，相邻两个城市的距离为 111，其中第 iii 个城市的价值为 valueivalue_ivaluei​。 不幸的是，这片土地常常发生地震，并且随着时代的发展，城市的价值也往往会发生变动。 接下来你需要在线处理 mmm 次操作： 0 x k 表示发生了一次地震，震中城市为 xxx，影响范围为 kkk，所有与 xxx 距离不超过 kkk 的城市都将受到影响，该次地震造成的经济损失为所有受影响城市的价值和。 1 x y 表示第 xxx 个城市的价值变成了 yyy 。 为了体现程序的在线性，操作中的 xxx、yyy、kkk 都需要异或你程序上一次的输出来解密，如果之前没有输出，则默认上一次的输出为 000 。 输入格式: 第一行包含两个正整数 nnn 和 mmm 。 第二行包含 nnn 个正整数，第 iii 个数表示 valueivalue_ivaluei​ 。 接下来 n−1n-1n−1 行，每行包含两个正整数 uuu、vvv，表示 uuu 和 vvv 之间有一条无向边。 接下来 mmm 行，每行包含三个数，表示 mmm 次操作。 输出格式: 包含若干行，对于每个询问输出一行一个正整数表示答案。 样例: 样例输入1: 8 1 1 10 100 1000 10000 100000 1000000 10000000 1 2 1 3 2 4 2 5 3 6 3 7 3 8 0 3 1 样例输出1: 11100101 思路: 实现: #include \"ybwhead/ios.h\" const int maxn = 2e5 + 10; int a[maxn]; int n, m; struct edge { int v, nxt; } e[maxn \u003c\u003c 1]; int tot, head[maxn]; void __ADD(int u, int v) { e[++tot].v = v; e[tot].nxt = head[u]; head[u] = tot; } void add(int u, int v) { __ADD(u, v); __ADD(v, u); } int stt[20][maxn], num; int dep[maxn], id1[maxn]; int lg2[maxn]; void dfs1(int u, int fa) { dep[u] = dep[fa] + 1; stt[0][++num] = u; id1[u] = num; for (int i = head[u]; i; i = e[i].nxt) { int v = e[i].v; if (v == fa) continue; dfs1(v, u); stt[0][++num] = u; } } int lower(int x, int y) { return dep[x] \u003c dep[y] ? x : y; } void getst() { for (int i = 2; i \u003c= tot; i++) lg2[i] = lg2[i \u003e\u003e 1] + 1; for (int i = 1; (1 \u003c\u003c i) \u003c= tot; i++) { int w = (1 \u003c\u003c i); for (int j = 1; j + w - 1 \u003c= tot; j++) { stt[i][j] = lower(stt[i - 1][j], stt[i - 1][j + w / 2]); } } } int LCA(int x, int y) { x = id1[x]; y = id1[y]; if (x \u003e y) swap(x, y); int i = lg2[y - x + 1], w = (1 \u003c\u003c i); return lower(stt[i][x], stt[i][y - w + 1]); } int Dis(int x, int y) { return dep[x] + dep[y] - 2 * dep[LCA(x, y)]; } int siz[maxn], maxs[maxn]; int dfa[maxn]; int vis[maxn]; int dsiz[maxn]; int dfs2(int u, int fa, int tots) { siz[u] = 1; maxs[u] = 0; int cen = 0; for (int i = head[u]; i; i = e[i].nxt) { int v = e[i].v; if (vis[v] || v == fa) continue; int vcen = dfs2(v, u, tots); if (!cen || maxs[vcen] \u003c maxs[cen]) cen = vcen; siz[u] += siz[v]; maxs[u] = max(maxs[u], siz[v]); } maxs[u] = max(maxs[u], tots - siz[u]); if (!cen || maxs[u] \u003c maxs[cen]) cen = u; return cen; } void divide(int cen, int tots) { vis[cen] = 1; dsiz[cen] = tots; for (int i = head[cen]; i; i = e[i].nxt) { int v = e[i].v; if (vis[v]) continue; int vsize = (siz[v] \u003c siz[cen]) ? siz[v] : (tots - siz[cen]); int vcen = dfs2(v, cen, vsize); dfa[vcen] = cen; divide(vcen, vsize); } } struct node { int sum; int ls, rs; } x[(int)1e7]; int ncnt; struct Seg { int rt; void modify(int \u0026pos, int l, int r, int d, int k) { if (!pos) pos = ++ncnt; x[pos].sum += k; if (l == r) return; int mid = (l + r) \u003e\u003e 1; if (d \u003c= mid) modify(x[pos].ls, l, mid, d, k); else modify(x[pos].rs, mid + 1, r, d, k); } int query(int pos, int l, int r, int nl, int nr) { if (!pos) return 0; if (l == nl \u0026\u0026 r == nr) return x[pos].sum; int mid = (l + r) \u003e\u003e 1; if (nr \u003c= mid) { return query(x[pos].ls, l, mid, nl, nr); } if (nl \u003e mid) { return query(x[pos].rs, mid + 1, r, nl, nr); } return query(x[pos].ls, l, mid, nl, mid) + query(x[pos].rs, mid + 1, r, mid + 1, nr); } } T1[maxn], T2[maxn]; void modify(int idx, int val) { int now = idx; while (now) { int fa = dfa[now]; T1[now].modify(T1[now].rt, 0, dsiz[now], Dis(now, idx), val); // cout \u003c\u003c idx \u003c\u003c \" \" \u003c\u003c now \u003c\u003c \" \" \u003c\u003c Dis(now, idx) \u003c\u003c endl; if (fa) T2[now].modify(T2[now].rt, 0, dsiz[fa], Dis(fa, idx), val); now = fa; } } int query(int idx, int k) { int res = 0; int now = idx, last = 0; while (now) { int d = Dis(idx, now); if (d \u003e k) { last = now; now = dfa[now]; continue; } res += T1[now].query(T1[now].rt, 0, dsiz[now], 0, k - d); if (last) res -= T2[last].query(T2[last].rt, 0, dsiz[now], 0, k - d); last = now; // cout \u003c\u003c now \u003c\u003c \" \" \u003c\u003c T1[now].query(T1[now].rt, 0, dsiz[now], 0, k - d) \u003c\u003c endl; now = dfa[now]; } return res; } void pre() { dfs1(1, 0); getst(); int cen = dfs2(1, 0, n); divide(cen, n); // cout \u003c\u003c LCA(2, 3) \u003c\u003c endl; for (int i = 1; i \u003c= n;","date":"2020-07-18","objectID":"/posts/oi/problems/p6329/:0:0","series":null,"tags":["点分治","树状数组","O2优化","Notebooks/OI/OJ/Luogu"],"title":"P6329-【模板】点分树 | 震波","uri":"/posts/oi/problems/p6329/#"},{"categories":null,"content":"P2345-[USACO04OPEN]MooFest G 题目: 题目描述: 约翰的N 头奶牛每年都会参加“哞哞大会”。哞哞大会是奶牛界的盛事。集会上的活动很多，比如堆干草，跨栅栏，摸牛仔的屁股等等。它们参加活动时会聚在一起，第i 头奶牛的坐标为Xi，没有两头奶牛的坐标是相同的。奶牛们的叫声很大，第i 头和第j 头奶牛交流，会发出max{Vi; Vj}×|Xi − Xj | 的音量，其中Vi 和Vj 分别是第i 头和第j 头奶牛的听力。 假设每对奶牛之间同时都在说话，请计算所有奶牛产生的音量之和是多少。 输入格式: • 第一行：单个整数N，1 ≤ N ≤ 20000 • 第二行到第N + 1 行：第i + 1 行有两个整数Vi 和Xi，1 ≤ Vi ≤ 20000; 1 ≤ Xi ≤ 20000 输出格式: • 单个整数：表示所有奶牛产生的音量之和 样例: 样例输入1: 4 3 1 2 5 2 6 4 3 样例输出1: 57 思路: 实现: #include \"ybwhead/ios.h\" using namespace std; const int maxn = 1e5 + 10; struct node { int v, x; } a[maxn], tmp[maxn]; int cmp(node a, node b) { return a.v \u003c b.v; } long long ans, n; void cdq(int l, int r) { if (l \u003e= r) return; int mid = (l + r) \u003e\u003e 1, ll = l; cdq(l, mid); cdq(mid + 1, r); long long s2, s1; s1 = s2 = 0; for (int i = l; i \u003c= mid; i++) s1 += a[i].x; for (int i = mid + 1; i \u003c= r; i++) { while (ll \u003c= mid \u0026\u0026 a[ll].x \u003c a[i].x) { s2 += a[ll].x; s1 -= a[ll].x; ll++; } ans += (1ll * a[i].x * (ll - l) - s2 - 1ll * a[i].x * (mid - ll + 1) + s1) * a[i].v; } int l1 = l, l2 = mid + 1, k = l - 1; while (l1 \u003c= mid || l2 \u003c= r) { if ((a[l1].x \u003e a[l2].x || l1 \u003e mid) \u0026\u0026 l2 \u003c= r) { tmp[++k] = a[l2]; l2++; } else { tmp[++k] = a[l1]; l1++; } } for (int i = l; i \u003c= r; i++) a[i] = tmp[i]; } int main() { yin \u003e\u003e n; for (int i = 1; i \u003c= n; i++) { yin \u003e\u003e a[i].v \u003e\u003e a[i].x; } sort(a + 1, a + n + 1, cmp); cdq(1, n); yout \u003c\u003c ans \u003c\u003c endl; return 0; } ","date":"2020-07-17","objectID":"/posts/oi/problems/p2345/:0:0","series":null,"tags":["模拟",2004,"USACO","树状数组","cdq分治","Notebooks/OI/OJ/Luogu"],"title":"P2345-[USACO04OPEN]MooFest G","uri":"/posts/oi/problems/p2345/#"},{"categories":null,"content":"P2634-[国家集训队]聪聪可可 题目: 题目描述: 聪聪和可可是兄弟俩，他们俩经常为了一些琐事打起来，例如家中只剩下最后一根冰棍而两人都想吃、两个人都想玩儿电脑（可是他们家只有一台电脑）……遇到这种问题，一般情况下石头剪刀布就好了，可是他们已经玩儿腻了这种低智商的游戏。 他们的爸爸快被他们的争吵烦死了，所以他发明了一个新游戏：由爸爸在纸上画 nnn 个“点”，并用 n−1n-1n−1 条“边”把这 nnn 个“点”恰好连通（其实这就是一棵树）。并且每条“边”上都有一个数。接下来由聪聪和可可分别随即选一个点（当然他们选点时是看不到这棵树的），如果两个点之间所有边上数的和加起来恰好是 333 的倍数，则判聪聪赢，否则可可赢。 聪聪非常爱思考问题，在每次游戏后都会仔细研究这棵树，希望知道对于这张图自己的获胜概率是多少。现请你帮忙求出这个值以验证聪聪的答案是否正确。 输入格式: 输入的第 111 行包含 111 个正整数 nnn。后面 n−1n-1n−1 行，每行 333 个整数 x,y,wx, y, wx,y,w，表示 xxx 号点和 yyy 号点之间有一条边，上面的数是 www。 输出格式: 以即约分数形式输出这个概率（即 a/b 的形式，其中 aaa 和 bbb 必须互质。如果概率为 111，输出 1/1 ）。 样例: 样例输入1: 5 1 2 1 1 3 2 1 4 1 2 5 3 样例输出1: 13/25 思路: 实现: #include \"ybwhead/ios.h\" long long ans, full; int n; const int maxn = 1e5 + 10; struct edge { int v, w, nxt; } e[maxn \u003c\u003c 1]; int tot, head[maxn]; void __ADD(int u, int v, int w) { e[++tot].v = v; e[tot].w = w; e[tot].nxt = head[u]; head[u] = tot; } void add(int u, int v, int w) { __ADD(u, v, w); __ADD(v, u, w); } int mod(int x) { return (x % 3 + 3) % 3; } long long f[maxn][3]; void dfs(int u, int fa) { // cout \u003c\u003c u \u003c\u003c endl; f[u][0] = 1; for (int i = head[u]; i; i = e[i].nxt) { int v = e[i].v, w = e[i].w; if (v == fa) continue; dfs(v, u); for (int i = 0; i \u003c 3; i++) ans += f[v][i] * f[u][mod(-i - w)]; for (int i = 0; i \u003c 3; i++) f[u][mod(i + w)] += f[v][i]; } } long long gcd(long long a, long long b) { if (!b) return a; return gcd(b, a % b); } int main() { yin \u003e\u003e n; for (int i = 1; i \u003c n; i++) { int a, b, c; yin \u003e\u003e a \u003e\u003e b \u003e\u003e c; add(a, b, c); } dfs(1, 0); ans \u003c\u003c= 1; ans += n; full = n * n; long long gc = gcd(full, ans); full /= gc; ans /= gc; yout \u003c\u003c ans \u003c\u003c \"/\" \u003c\u003c full \u003c\u003c endl; return 0; } ","date":"2020-07-17","objectID":"/posts/oi/problems/p2634/:0:0","series":null,"tags":["dp","点分治","WC/CTSC/集训队","Notebooks/OI/OJ/Luogu"],"title":"P2634-[国家集训队]聪聪可可","uri":"/posts/oi/problems/p2634/#"},{"categories":null,"content":"P5283-[十二省联考2019]异或粽子 题目: 题目描述: 小粽是一个喜欢吃粽子的好孩子。今天她在家里自己做起了粽子。 小粽面前有 nnn 种互不相同的粽子馅儿，小粽将它们摆放为了一排，并从左至右编号为 111 到 nnn。第 iii 种馅儿具有一个非负整数的属性值 aia_iai​。每种馅儿的数量都足够多，即小粽不会因为缺少原料而做不出想要的粽子。小粽准备用这些馅儿来做出 kkk 个粽子。 小粽的做法是：选两个整数数 lll, rrr，满足 1⩽l⩽r⩽n1 \\leqslant l \\leqslant r \\leqslant n1⩽l⩽r⩽n，将编号在 [l,r][l, r][l,r] 范围内的所有馅儿混合做成一个粽子，所得的粽子的美味度为这些粽子的属性值的异或和。（异或就是我们常说的 xor 运算，即 C/C++ 中的 ˆ 运算符或 Pascal 中的 xor 运算符） 小粽想品尝不同口味的粽子，因此它不希望用同样的馅儿的集合做出一个以上的 粽子。 小粽希望她做出的所有粽子的美味度之和最大。请你帮她求出这个值吧！ 输入格式: 第一行两个正整数 nnn, kkk，表示馅儿的数量，以及小粽打算做出的粽子的数量。 接下来一行为 nnn 个非负整数，第 iii 个数为 aia_iai​，表示第 iii 个粽子的属性值。 对于所有的输入数据都满足：1⩽n⩽5×1051 \\leqslant n \\leqslant 5 \\times 10^51⩽n⩽5×105, 1⩽k⩽min⁡{n(n−1)2,2×105}1 \\leqslant k \\leqslant \\min\\left\\{\\frac{n(n-1)}{2},2 \\times 10^{5}\\right\\}1⩽k⩽min{2n(n−1)​,2×105}, 0⩽ai⩽42949672950 \\leqslant a_i \\leqslant 4 294 967 2950⩽ai​⩽4294967295。 输出格式: 输出一行一个整数，表示小粽可以做出的粽子的美味度之和的最大值。 样例: 样例输入1: 3 2 1 2 3 样例输出1: 6 思路: 实现: #include \"ybwhead/ios.h\" int n, k; const int maxn = 5e5 + 10; long long a[maxn]; priority_queue\u003cpair\u003cpair\u003clong long, int\u003e, int\u003e\u003e q; long long ans = 1, x; int cc[maxn * 40][2], siz[maxn * 40], tot; void ins(long long x) { int u = 0; for (int i = 31; i \u003e= 0; i--) { int ch = (x \u003e\u003e i) \u0026 1; siz[u]++; if (!cc[u][ch]) cc[u][ch] = ++tot; u = cc[u][ch]; } siz[u]++; } long long query(long long x, int rk) { int u = 0; long long ans = 0; for (int i = 31; i \u003e= 0; i--) { int ch = (x \u003e\u003e i) \u0026 1; if (!cc[u][ch ^ 1]) u = cc[u][ch]; else if (rk \u003c= siz[cc[u][ch ^ 1]]) u = cc[u][ch ^ 1], ans |= 1LL \u003c\u003c i; else rk -= siz[cc[u][ch ^ 1]], u = cc[u][ch]; } return ans; } int main() { yin \u003e\u003e n \u003e\u003e k; for (int i = 1; i \u003c= n; i++) yin \u003e\u003e a[i], a[i] ^= a[i - 1]; k \u003c\u003c= 1; for (int i = 0; i \u003c= n; i++) ins(a[i]); for (int i = 0; i \u003c= n; i++) { q.push(make_pair(make_pair(query(a[i], 1), i), 1)); } for (int i = 1; i \u003c= k; i++) { pair\u003cpair\u003clong long, int\u003e, int\u003e x = q.top(); ans += x.first.first; q.pop(); if (x.second \u003c n) { x.second++; x.first.first = query(a[x.first.second], x.second); q.push(x); } } cout \u003c\u003c (ans \u003e\u003e 1) \u003c\u003c endl; return 0; } ","date":"2020-07-17","objectID":"/posts/oi/problems/p5283/:0:0","series":null,"tags":[2019,"各省省选","二叉堆","字典树,Trie树","Notebooks/OI/OJ/Luogu"],"title":"P5283-[十二省联考2019]异或粽子","uri":"/posts/oi/problems/p5283/#"},{"categories":null,"content":"P3806-【模板】点分治1 题目: 题目描述: 给定一棵有 nnn 个点的树，询问树上距离为 kkk 的点对是否存在。 输入格式: 第一行两个数 n,mn,mn,m。 第 222 到第 nnn 行，每行三个整数 u,v,wu, v, wu,v,w，代表树上存在一条连接 uuu 和 vvv 边权为 www 的路径。 接下来 mmm 行，每行一个整数 kkk，代表一次询问。 输出格式: 对于每次询问输出一行一个字符串代表答案，存在输出 AYE，否则输出 NAY。 样例: 样例输入1: 2 1 1 2 2 2 样例输出1: AYE 思路: 实现: #include \"ybwhead/ios.h\" const int maxn = 1e5 + 10; struct edge { int v, w, nxt; } e[maxn \u003c\u003c 1]; int head[maxn], tot; void __ADD(int u, int v, int w) { e[++tot].v = v; e[tot].w = w; e[tot].nxt = head[u]; head[u] = tot; } void add(int u, int v, int w) { __ADD(u, v, w); __ADD(v, u, w); } int n, m; int siz[maxn], mx[maxn]; int vis[maxn], root, S; void find(int x, int fa) { siz[x] = 1; mx[x] = 0; for (int i = head[x]; i; i = e[i].nxt) { int v = e[i].v; if (v == fa || vis[v]) continue; find(v, x); siz[x] += siz[v]; mx[x] = max(siz[v], mx[x]); } mx[x] = max(S - siz[x], mx[x]); if (mx[x] \u003c mx[root]) { root = x; } } int a[maxn]; int d[maxn]; int b[maxn]; void get_dis(int u, int fa, int dis, int from) { a[++tot] = u; d[u] = dis; b[u] = from; for (int i = head[u]; i; i = e[i].nxt) { int v = e[i].v; if (v == fa || vis[v]) continue; get_dis(v, u, dis + e[i].w, from); } } bool cmp(int x, int y) { return d[x] \u003c d[y]; } int ok[maxn]; int query[maxn]; void calc(int u) { tot = 0; a[++tot] = u; d[u] = 0; b[u] = u; //别忘了加上root自己 for (int i = head[u]; i; i = e[i].nxt) { int v = e[i].v; if (vis[v]) continue; get_dis(v, u, e[i].w, v); } sort(a + 1, a + tot + 1, cmp); for (int i = 1; i \u003c= m; i++) { int l = 1, r = tot; if (ok[i]) continue; while (l \u003c r) { if (d[a[l]] + d[a[r]] \u003e query[i]) { r--; } else if (d[a[l]] + d[a[r]] \u003c query[i]) { l++; } else if (b[a[l]] == b[a[r]]) { if (d[a[r]] == d[a[r - 1]]) r--; else l++; } else { ok[i] = true; break; } } } } void Divid(int x) { vis[x] = 1; calc(x); for (int i = head[x]; i; i = e[i].nxt) { int v = e[i].v; if (vis[v]) continue; S = siz[v]; root = 0; find(v, x); Divid(root); } } int main() { yin \u003e\u003e n \u003e\u003e m; for (int i = 1; i \u003c n; i++) { int a, b, c; yin \u003e\u003e a \u003e\u003e b \u003e\u003e c; add(a, b, c); } for (int i = 1; i \u003c= m; i++) { int k; yin \u003e\u003e query[i]; } S = n; root = 0; mx[0] = n + 1; find(1, 0); Divid(root); for (int i = 1; i \u003c= m; i++) { yout \u003c\u003c (ok[i] ? \"AYE\" : \"NAY\") \u003c\u003c endl; } return 0; } ","date":"2020-07-17","objectID":"/posts/oi/problems/p3806/:0:0","series":null,"tags":["点分治","O2优化","分治","深度优先搜索,DFS","Notebooks/OI/OJ/Luogu"],"title":"P3806-【模板】点分治1","uri":"/posts/oi/problems/p3806/#"},{"categories":null,"content":"P3387-【模板】缩点 题目: 题目描述: 给定一个 nnn 个点 mmm 条边有向图，每个点有一个权值，求一条路径，使路径经过的点权值之和最大。你只需要求出这个权值和。 允许多次经过一条边或者一个点，但是，重复经过的点，权值只计算一次。 输入格式: 第一行两个正整数 n,mn,mn,m 第二行 nnn 个整数，依次代表点权 第三至 m+2m+2m+2 行，每行两个整数 u,vu,vu,v，表示一条 u→vu\\rightarrow vu→v 的有向边。 输出格式: 共一行，最大的点权之和。 样例: 样例输入1: 2 2 1 1 1 2 2 1 样例输出1: 2 思路: 实现: #include \"ybwhead/ios.h\" int n, m; const int maxn = 1e4 + 10; const int maxm = 1e5 + 10; struct egde { int v, nxt; } e[maxm \u003c\u003c 1]; int a[maxn]; int head[maxn], tot; void add(int u, int v) { e[++tot].v = v; e[tot].nxt = head[u]; head[u] = tot; } int dfn[maxn]; int low[maxn]; int num; int vis[maxn]; stack\u003cint\u003e s; int su, co[maxn]; int ans[maxn]; void tarjan(int u) { // cout \u003c\u003c u \u003c\u003c endl; dfn[u] = low[u] = ++num; s.push(u); vis[u] = 1; for (int i = head[u]; i; i = e[i].nxt) { int v = e[i].v; if (!dfn[v]) { tarjan(v); low[u] = min(low[u], low[v]); } else { if (vis[v]) { low[u] = min(low[u], dfn[v]); } } } if (dfn[u] == low[u]) { ++su; // cout \u003c\u003c u \u003c\u003c endl; while (s.top() != u) { vis[s.top()] = 0; co[s.top()] = su; ans[su] += a[s.top()]; s.pop(); } vis[u] = 0; co[u] = su; ans[su] += a[u]; s.pop(); } } vector\u003cint\u003e vv[maxn]; int in[maxn]; queue\u003cint\u003e q; int dis[maxn]; int main() { yin \u003e\u003e n \u003e\u003e m; for (int i = 1; i \u003c= n; i++) yin \u003e\u003e a[i]; for (int i = 1; i \u003c= m; i++) { int u, v; yin \u003e\u003e u \u003e\u003e v; add(u, v); } for (int i = 1; i \u003c= n; i++) if (!dfn[i]) tarjan(i); // puts(\"!!!\"); for (int u = 1; u \u003c= n; u++) { for (int i = head[u]; i; i = e[i].nxt) { int v = e[i].v; // cout \u003c\u003c u \u003c\u003c \"!!!\" \u003c\u003c v \u003c\u003c endl; // cout \u003c\u003c co[u] \u003c\u003c \" \" \u003c\u003c co[v] \u003c\u003c endl; if (co[u] != co[v]) { vv[co[u]].push_back(co[v]); in[co[v]]++; } } } for (int i = 1; i \u003c= su; i++) if (in[i] == 0) q.push(i), dis[i] = ans[i]; // cout \u003c\u003c q.size() \u003c\u003c endl; while (!q.empty()) { int u = q.front(); q.pop(); for (int i = 0; i \u003c vv[u].size(); i++) { int v = vv[u][i]; --in[v]; dis[v] = max(dis[v], dis[u] + ans[v]); if (in[v] == 0) { q.push(v); } } } // cout \u003c\u003c su \u003c\u003c endl; int ans = 0; for (int i = 1; i \u003c= su; i++) ans = max(ans, dis[i]); yout \u003c\u003c ans \u003c\u003c endl; return 0; } ","date":"2020-07-17","objectID":"/posts/oi/problems/p3387/:0:0","series":null,"tags":["图论","Tarjan","Notebooks/OI/OJ/Luogu"],"title":"P3387-【模板】缩点","uri":"/posts/oi/problems/p3387/#"},{"categories":null,"content":"P3375-【模板】KMP字符串匹配 题目: 题目描述: 如题，给出两个字符串 s1s_1s1​ 和 s2s_2s2​，其中 s2s_2s2​ 为 s1s_1s1​ 的子串，求出 s2s_2s2​ 在 s1s_1s1​ 中所有出现的位置。 为了减少骗分的情况，接下来还要输出子串的前缀数组 next。 （如果你不知道这是什么意思也不要问，去百度搜 kmp算法 学习一下就知道了。） 输入格式: 第一行为一个字符串，即为 s1s_1s1​。 第二行为一个字符串，即为 s2s_2s2​。 输出格式: 若干行，每行包含一个整数，表示 s2s_2s2​ 在 s1s_1s1​ 中出现的位置 接下来 111 行，包括 ∣s2∣|s2|∣s2∣ 个整数，表示前缀数组 nextinext_inexti​ 的值。 样例: 样例输入1: ABABABC ABA 样例输出1: 1 3 0 0 1 思路: 实现: #include \"ybwhead/ios.h\" const int maxn = 1e6 + 10; char s1[maxn], s2[maxn]; int kmp[maxn]; int main() { cin \u003e\u003e (s1 + 1) \u003e\u003e (s2 + 1); int n = strlen(s1 + 1), m = strlen(s2 + 1); int j = 0; for (int i = 2; i \u003c= m; i++) { while (j \u0026\u0026 s2[j + 1] != s2[i]) j = kmp[j]; if (s2[j + 1] == s2[i]) ++j; kmp[i] = j; } j = 0; for (int i = 1; i \u003c= n; i++) { while (j \u0026\u0026 s2[j + 1] != s1[i]) j = kmp[j]; if (s2[j + 1] == s1[i]) ++j; if (j == m) { yout \u003c\u003c i - m + 1 \u003c\u003c endl; j = kmp[j]; } } for (int i = 1; i \u003c= m; i++) { yout \u003c\u003c kmp[i] \u003c\u003c \" \"; } return 0; } ","date":"2020-06-15","objectID":"/posts/oi/problems/p3375/:0:0","series":null,"tags":["字符串","KMP","Notebooks/OI/OJ/Luogu"],"title":"P3375-【模板】KMP字符串匹配","uri":"/posts/oi/problems/p3375/#"},{"categories":null,"content":"P4170-[CQOI2007]涂色 题目: 题目描述: 假设你有一条长度为 555 的木版，初始时没有涂过任何颜色。你希望把它的 555 个单位长度分别涂上红、绿、蓝、绿、红色，用一个长度为 555 的字符串表示这个目标：RGBGR。 每次你可以把一段连续的木版涂成一个给定的颜色，后涂的颜色覆盖先涂的颜色。例如第一次把木版涂成 RRRRR，第二次涂成 RGGGR，第三次涂成 RGBGR，达到目标。 用尽量少的涂色次数达到目标。 输入格式: 输入仅一行，包含一个长度为 nnn 的字符串，即涂色目标。字符串中的每个字符都是一个大写字母，不同的字母代表不同颜色，相同的字母代表相同颜色。 输出格式: 仅一行，包含一个数，即最少的涂色次数。 样例: 样例输入1: AAAAA 样例输出1: 1 样例输入2: RGBGR 样例输出2: 3 思路: 实现: #include \"ybwhead/ios.h\" const int maxn = 50; int f[maxn][maxn]; int n; int main() { string s; yin \u003e\u003e s; n = s.size(); for (int i = 1; i \u003c= n; i++) f[i][i] = 1; for (int l = 1; l \u003c= n; l++) { for (int j = l + 1; j \u003c= n; j++) { int i = j - l; f[i][j] = INT_MAX; if (s[i - 1] == s[j - 1]) f[i][j] = min(f[i][j - 1], f[i + 1][j]); else for (int k = i; k \u003c j; k++) { f[i][j] = min(f[i][j], f[i][k] + f[k + 1][j]); } } } cout \u003c\u003c f[1][n] \u003c\u003c endl; return 0; } ","date":"2020-06-15","objectID":"/posts/oi/problems/p4170/:0:0","series":null,"tags":["字符串",2007,"重庆","各省省选","枚举,暴力","区间动规,区间dp","Notebooks/OI/OJ/Luogu"],"title":"P4170-[CQOI2007]涂色","uri":"/posts/oi/problems/p4170/#"},{"categories":null,"content":"P3146-[USACO16OPEN]248 G 题目: 题目描述: Bessie likes downloading games to play on her cell phone, even though she doesfind the small touch screen rather cumbersome to use with her large hooves. She is particularly intrigued by the current game she is playing. The game starts with a sequence of NNN positive integers (2≤N≤2482 \\leq N\\leq 2482≤N≤248), each in the range 1…401 \\ldots 401…40. In one move, Bessie cantake two adjacent numbers with equal values and replace them a singlenumber of value one greater (e.g., she might replace two adjacent 7swith an 8). The goal is to maximize the value of the largest numberpresent in the sequence at the end of the game. Please help Bessiescore as highly as possible! 给定一个 1*n 的地图，在里面玩 2048，每次可以合并相邻两个（数值范围 1-40），问最大能合出多少。注意合并后的数值并非加倍而是+1，例如 2 与 2 合并后的数值为 3。 输入格式: The first line of input contains NNN, and the next NNN lines give the sequence of NNN numbers at the start of the game. 输出格式: Please output the largest integer Bessie can generate. 样例: 样例输入 1: 4 1 1 1 2 样例输出 1: 3 思路: 记fi,j=max⁡p=ij−1[fi,p=fp+1,j]⋅fi,pf_{i, j}=\\max_{p=i}^{j-1}[f_{i, p}=f_{p+1, j}]\\cdot f_{i, p}fi,j​=maxp=ij−1​[fi,p​=fp+1,j​]⋅fi,p​表示完全合并 i 到 j 的最大值 实现: #include \"ybwhead/ios.h\" using namespace std; int n; const int maxn = 250; int f[maxn][maxn]; int main() { yin \u003e\u003e n; for (int i = 1; i \u003c= n; i++) yin \u003e\u003e f[i][i]; int ans = 0; for (int l = 1; l \u003c= n; l++) { for (int j = l + 1; j \u003c= n; j++) { int i = j - l; for (int p = i; p \u003c j; p++) { if (f[i][p] == f[p + 1][j]) { f[i][j] = max(f[i][p], f[i][j]); } } if (f[i][j]) ans = max(ans, ++f[i][j]); } } yout \u003c\u003c ans \u003c\u003c endl; return 0; } ","date":"2020-06-13","objectID":"/posts/oi/problems/p3146/:0:0","series":null,"tags":["dp","贪心",2016,"USACO","区间动规, 区间dp","Notebooks/OI/OJ/Luogu"],"title":"P3146-[USACO16OPEN]248 G","uri":"/posts/oi/problems/p3146/#"},{"categories":null,"content":"P4158-[SCOI2009]粉刷匠 题目: 题目描述: windy 有 N 条木板需要被粉刷。 每条木板被分为 M 个格子。 每个格子要被刷成红色或蓝色。 windy 每次粉刷，只能选择一条木板上一段连续的格子，然后涂上一种颜色。 每个格子最多只能被粉刷一次。 如果 windy 只能粉刷 T 次，他最多能正确粉刷多少格子？ 一个格子如果未被粉刷或者被粉刷错颜色，就算错误粉刷。 输入格式: 第一行包含三个整数，N M T。 接下来有 N 行，每行一个长度为 M 的字符串，‘0’表示红色，‘1’表示蓝色。 输出格式: 包含一个整数，最多能正确粉刷的格子数。 样例: 记gi,j,k=max⁡q=j−1kgi,j−1,q+max(sumi,k−sumi,q,k−q−sumi,k+sumi,q)g_{i, j, k}=\\max_{q=j-1}^{k}{g_{i, j-1, q}+max(sum_{i, k} - sum_{i, q}, k - q - sum_{i, k} + sum_{i, q} )}gi,j,k​=maxq=j−1k​gi,j−1,q​+max(sumi,k​−sumi,q​,k−q−sumi,k​+sumi,q​)表示第 iii 条木板上粉刷 jjj 次涂了前 kkk 个格子的情况下能正确粉刷的最大格子数 记fi,j=maxk=0min(j,m)fi−1,j−k+gi,k,mf_{i, j}=max_{k=0}^{min(j, m)}f_{i-1, j-k}+g_{i, k, m}fi,j​=maxk=0min(j,m)​fi−1,j−k​+gi,k,m​ 样例输入 1: 3 6 3 111111 000000 001100 样例输出 1: 16 思路: 实现: #include \"ybwhead/ios.h\" using namespace std; const int maxn = 55; int f[maxn][maxn * maxn], sum[maxn][maxn]; string s; int g[maxn][maxn][maxn]; int n, m, t; int main() { yin \u003e\u003e n \u003e\u003e m \u003e\u003e t; for (int i = 1; i \u003c= n; i++) { yin \u003e\u003e s; for (int j = 1; j \u003c= m; j++) { sum[i][j] = sum[i][j - 1] + (s[j - 1] == '1'); // cout\u003c\u003cj\u003c\u003cendl; } } // puts(\"!!!\"); for (int i = 1; i \u003c= n; i++) { for (int j = 1; j \u003c= m; j++) { for (int k = 1; k \u003c= m; k++) { for (int q = j - 1; q \u003c k; q++) g[i][j][k] = max(g[i][j][k], g[i][j - 1][q] + max(sum[i][k] - sum[i][q], k - q - sum[i][k] + sum[i][q])); } } } for (int i = 1; i \u003c= n; i++) for (int j = 1; j \u003c= t; j++) for (int k = 0; k \u003c= min(j, m); k++) f[i][j] = max(f[i - 1][j - k] + g[i][k][m], f[i][j]); int ans = 0; for (int i = 1; i \u003c= t; i++) ans = max(ans, f[n][i]); yout \u003c\u003c ans \u003c\u003c endl; return 0; } ","date":"2020-06-13","objectID":"/posts/oi/problems/p4158/:0:0","series":null,"tags":["dp","递推",2009,"四川","各省省选","枚举, 暴力","背包","Notebooks/OI/OJ/Luogu"],"title":"P4158-[SCOI2009]粉刷匠","uri":"/posts/oi/problems/p4158/#"},{"categories":null,"content":"CF260E-Dividing Kingdom 题目: 题目描述: A country called Flatland is an infinite two-dimensional plane. Flatland has n n n cities, each of them is a point on the plane. Flatland is ruled by king Circle IV. Circle IV has 9 sons. He wants to give each of his sons part of Flatland to rule. For that, he wants to draw four distinct straight lines, such that two of them are parallel to the Ox Ox Ox axis, and two others are parallel to the Oy Oy Oy axis. At that, no straight line can go through any city. Thus, Flatland will be divided into 9 parts, and each son will be given exactly one of these parts. Circle IV thought a little, evaluated his sons’ obedience and decided that the i i i -th son should get the part of Flatland that has exactly ai a_{i} ai​ cities. Help Circle find such four straight lines that if we divide Flatland into 9 parts by these lines, the resulting parts can be given to the sons so that son number i i i got the part of Flatland which contains ai a_{i} ai​ cities. 输入格式: The first line contains integer n (9\u003c=n\u003c=105) n\\ (9\u003c=n\u003c=10^{5}) n (9\u003c=n\u003c=105) — the number of cities in Flatland. Next n n n lines each contain two space-separated integers: xi,yi (−109\u003c=xi,yi\u003c=109) x_{i},y_{i}\\ (-10^{9}\u003c=x_{i},y_{i}\u003c=10^{9}) xi​,yi​ (−109\u003c=xi​,yi​\u003c=109) — the coordinates of the i i i -th city. No two cities are located at the same point. The last line contains nine space-separated integers: . 输出格式: If there is no solution, print a single integer -1. Otherwise, print in the first line two distinct real space-separated numbers: x1,x2 x_{1},x_{2} x1​,x2​ — the abscissas of the straight lines that are parallel to the Oy Oy Oy axis. And in the second line print two distinct real space-separated numbers: y1,y2 y_{1},y_{2} y1​,y2​ — the ordinates of the straight lines, parallel to the Ox Ox Ox . If there are multiple solutions, print any of them. When the answer is being checked, a city is considered to lie on a straight line, if the distance between the city and the line doesn’t exceed 10−6 10^{-6} 10−6 . Two straight lines are considered the same if the distance between them doesn’t exceed 10−6 10^{-6} 10−6 . 样例: 样例输入 1: 9 1 1 1 2 1 3 2 1 2 2 2 3 3 1 3 2 3 3 1 1 1 1 1 1 1 1 1 样例输出 1: 1.5000000000 2.5000000000 1.5000000000 2.5000000000 样例输入 2: 15 4 4 -1 -3 1 5 3 -4 -4 4 -1 1 3 -3 -4 -5 -3 3 3 2 4 1 -4 2 -2 -5 -3 4 -1 4 2 1 2 1 2 1 3 2 1 样例输出 2: -3.5000000000 2.0000000000 3.5000000000 -1.0000000000 样例输入 3: 10 -2 10 6 0 -16 -6 -4 13 -4 -2 -17 -10 9 15 18 16 -5 2 10 -5 2 1 1 1 1 1 1 1 1 样例输出 3: -1 思路: 细节还是很多的。 首先不难想到暴力全排列枚举每个块是哪个，然后用数据结构来判定可不可行。 首先你需要先把这些点离散化，然后考虑先横向分，再竖向分。 以第二个样例为例，我们要先确定绿线和蓝线的位置。这个可以通过对 xx 轴记前缀和来得到。 接着确定红线和紫线，就需要建一个主席树来支持二维数点。但是这里要注意，一定要把这 33 列里每个可能的位置都试一遍，这样才能枚举到答案。 实现: #include \"ybwhead/ios.h\" #define maxn (int)(1e5 + 10) int x[maxn], y[maxn], n; int c[50]; struct node { int x, y; } a[maxn]; int root[maxn]; int cntx, cnty; int cmp(node a, node b) { return a.x \u003c b.x; } int tot; struct pre { int ls, rs, sum; } xp[maxn \u003c\u003c 5]; void update(int \u0026p, int las, int l, int r, int v) { // cout \u003c\u003c l \u003c\u003c \" \" \u003c\u003c r \u003c\u003c endl; // for(int i=1;i\u003c=1e9;i++) // ; p = ++tot; xp[p] = xp[las]; ++xp[p].sum; if (l == r) return; int mid = (l + r) \u003e\u003e 1; if (v \u003c= mid) update(xp[p].ls, xp[las].ls, l, mid, v); else update(xp[p].rs, xp[las].rs, mid + 1, r, v); } int qry(int p, int l, int r, int L, int R) { if ((!p) || L \u003c= l \u0026\u0026 r \u003c= R) return xp[p].sum; int mid = (l + r) \u003e\u003e 1, ans = 0; if (L \u003c= mid) ans += qry(xp[p].ls, l, mid, L, R); if (R \u003e mid) ans += qry(xp[p].rs, mid + 1, r, L, R); return ans; } int kth(int p, int las, int l, int r, int k) { if (l == r) return l; int ans = xp[xp[las].ls].sum - xp[xp[p].ls].sum, mid = (l + r) \u003e\u003e 1; if (ans \u003e= k) return kth(xp[p].ls, xp[las].ls, l, mid, k); else return kth(xp[p].rs, xp[las].rs, mid + 1, r, k - ans); } int Sum(int l, int r, int L, int R) { return qry(root[r], 1, cnty, L, R) - qry(root[l - 1], 1, cnty, L, R); } void solve() { // for (int i = 1; i \u003c= 1e8; i++) // ; int l = 1, r = cntx; while (l \u003c r) { int m","date":"2020-05-04","objectID":"/posts/oi/problems/cf260e/:0:0","series":null,"tags":["Notebooks/OI/OJ/Luogu"],"title":"CF260E-Dividing Kingdom","uri":"/posts/oi/problems/cf260e/#"},{"categories":null,"content":"P1351-联合权值 题目: 题目描述: 无向连通图 GGG 有 nnn 个点，n−1n-1n−1 条边。点从 111 到 nnn 依次编号, 编号为 iii 的点的权值为 WiW_iWi​，每条边的长度均为 111。图上两点 (u,v)(u, v)(u,v) 的距离定义为 uuu 点到 vvv 点的最短距离。对于图 GGG 上的点对 (u,v)(u, v)(u,v)，若它们的距离为 222，则它们之间会产生Wv×WuW_v \\times W_uWv​×Wu​ 的联合权值。 请问图 GGG 上所有可产生联合权值的有序点对中，联合权值最大的是多少？所有联合权值之和是多少？ 输入格式: 第一行包含 111 个整数 nnn。 接下来 n−1n-1n−1 行, 每行包含 222 个用空格隔开的正整数 u,vu, vu,v，表示编号为 uuu 和编号为 vvv 的点之间有边相连。 最后 111 行, 包含 nnn 个正整数，每两个正整数之间用一个空格隔开，其中第 iii 个整数表示图 GGG 上编号为 iii 的点的权值为 WiW_iWi​。 输出格式: 输出共 111 行, 包含 222 个整数，之间用一个空格隔开, 依次为图 GGG 上联合权值的最大值和所有联合权值之和。由于所有联合权值之和可能很大，输出它时要对100071000710007取余。 样例: 样例输入 1: 5 1 2 2 3 3 4 4 5 1 5 2 3 10 样例输出 1: 20 74 思路: 实现: #include \"ybwhead/ios.h\" #define maxn (int)2e5 + 100 #include \"ybwhead/edge.h\" int n, m; Edge e; int ww[maxn]; long long ans, tot; const int mod = 10007; int main() { yin \u003e\u003e n; for (int i = 1; i \u003c n; i++) { int x, y; yin \u003e\u003e x \u003e\u003e y; e.add(x, y); // cout \u003c\u003c i + 1 \u003c\u003c \" \" \u003c\u003c x \u003c\u003c \" \" \u003c\u003c y \u003c\u003c endl; } for (int i = 1; i \u003c= n; i++) yin \u003e\u003e ww[i]; // puts(\"!!!\"); for (int i = 1; i \u003c= n; i++) { long long sum = 0, ma = 0; for (int j = e.head[i]; j; j = e.e[j].nxt) { int v = e.e[j].v; long long w = ww[v]; ans += sum * w % mod; ans %= mod; tot = max(tot, ma * w); sum += w; sum %= mod; ma = max(ma, w); } } cout \u003c\u003c tot \u003c\u003c \" \" \u003c\u003c ans * 2 % mod \u003c\u003c endl; return 0; } ","date":"2020-05-04","objectID":"/posts/oi/problems/p1351/:0:0","series":null,"tags":["dp",2014,"NOIp提高组","最近公共祖先, LCA","高性能","Notebooks/OI/OJ/Luogu"],"title":"P1351-联合权值","uri":"/posts/oi/problems/p1351/#"},{"categories":null,"content":"P1967-货车运输 题目: 题目描述: A 国有 nnn 座城市，编号从 11 1 到 n nn，城市之间有 mmm 条双向道路。每一条道路对车辆都有重量限制，简称限重。 现在有 qqq 辆货车在运输货物， 司机们想知道每辆车在不超过车辆限重的情况下，最多能运多重的货物。 输入格式: 第一行有两个用一个空格隔开的整数 n,m n,mn,m，表示 AAA 国有 n nn 座城市和 mmm 条道路。 接下来 mmm 行每行三个整数 x,y,zx, y, zx,y,z，每两个整数之间用一个空格隔开，表示从 xx x 号城市到 y y y 号城市有一条限重为 zzz 的道路。 注意： x≠yx \\neq yx=y，两座城市之间可能有多条道路 。 接下来一行有一个整数 qqq，表示有 qqq 辆货车需要运货。 接下来 qqq 行，每行两个整数 x,yx,yx,y，之间用一个空格隔开，表示一辆货车需要从 xxx 城市运输货物到 yyy 城市，保证 x≠yx \\neq yx=y 输出格式: 共有 qqq 行，每行一个整数，表示对于每一辆货车，它的最大载重是多少。 如果货车不能到达目的地，输出 −1-1−1。 样例: 样例输入 1: 4 3 1 2 4 2 3 3 3 1 1 3 1 3 1 4 1 3 样例输出 1: 3 -1 3 思路: 最小生成树 + LCA 实现: #include \u003cbits/stdc++.h\u003e #include \"ybwhead/ios.h\" using namespace std; int n, m; pair\u003cint, int\u003e fa[10001][216]; int f[10001], ans[10001]; bool vis[10001]; int depp[10001]; vector\u003cpair\u003cint, int\u003e\u003e g[10001]; struct bian { int a, b, c; } e[50001]; int find(int x) { if (x == f[x]) return x; return f[x] = find(f[x]); } void dfs(int u, int dep) { vis[u] = 1; for (int i = 0; i \u003c g[u].size(); i++) { int v = g[u][i].first; if (vis[v]) continue; fa[v][0].first = u; depp[v] = dep + 1; fa[v][0].second = g[u][i].second; dfs(v, dep + 1); } return; } int LCA(int x, int y) { int ans = INT_MAX / 10; if (depp[x] \u003c= depp[y]) swap(x, y); for (int i = 15; i \u003e= 0; i--) { if (depp[fa[x][i].first] \u003e= depp[y]) { ans = min(fa[x][i].second, ans); x = fa[x][i].first; // cout\u003c\u003cfa[x][i].first\u003c\u003cendl; } } if (x == y) { return ans; } for (int i = 15; i \u003e= 0; i--) { if (fa[x][i].first != fa[y][i].first) { ans = min(ans, min(fa[x][i].second, fa[y][i].second)); x = fa[x][i].first; y = fa[y][i].first; } } ans = min(ans, min(fa[x][0].second, fa[y][0].second)); return ans; } int cmp(bian a, bian b) { return a.c \u003e b.c; } int main() { yin \u003e\u003e n \u003e\u003e m; for (int i = 1; i \u003c= n; i++) { f[i] = i; } int x = 0; for (int i = 1; i \u003c= m; i++) { yin \u003e\u003e e[i].a \u003e\u003e e[i].b \u003e\u003e e[i].c; } sort(e + 1, e + m + 1, cmp); for (int i = 1; i \u003c= m; i++) { int sa = find(e[i].a), sb = find(e[i].b); if (sa != sb) { f[sa] = sb; ans[++x] = i; } } for (int i = 1; i \u003c= x; i++) { g[e[ans[i]].a].push_back(make_pair(e[ans[i]].b, e[ans[i]].c)); g[e[ans[i]].b].push_back(make_pair(e[ans[i]].a, e[ans[i]].c)); } for (int i = 1; i \u003c= n; i++) { if (!vis[i]) { depp[i] = 1; dfs(i, 1); fa[i][0].first = i; fa[i][0].second = INT_MAX / 10; // vis[i]=1; } } for (int i = 0; i \u003c 15; i++) { for (int u = 1; u \u003c= n; u++) { fa[u][i + 1].first = fa[fa[u][i].first][i].first; fa[u][i + 1].second = min(fa[u][i].second, fa[fa[u][i].first][i].second); } } int q; yin \u003e\u003e q; for (int i = 1; i \u003c= q; i++) { int x, y; yin \u003e\u003e x \u003e\u003e y; if (find(x) != find(y)) puts(\"-1\"); else yout \u003c\u003c LCA(x, y) \u003c\u003c endl; } return 0; } ","date":"2020-05-03","objectID":"/posts/oi/problems/p1967/:0:0","series":null,"tags":["图论","贪心",2013,"倍增","并查集","NOIp提高组","生成树","最近公共祖先,LCA","高性能","Notebooks/OI/OJ/Luogu"],"title":"P1967-货车运输","uri":"/posts/oi/problems/p1967/#"},{"categories":null,"content":"P5021-赛道修建 题目: 题目描述: C 城将要举办一系列的赛车比赛。在比赛前，需要在城内修建 mmm 条赛道。 C 城一共有 nnn 个路口，这些路口编号为 1,2,…,n1,2,…,n1,2,…,n，有 n−1n-1n−1 条适合于修建赛道的双向通行的道路，每条道路连接着两个路口。其中，第 iii 条道路连接的两个路口编号为 aia_iai​ 和 bib_ibi​，该道路的长度为 lil_ili​。借助这 n−1n-1n−1 条道路，从任何一个路口出发都能到达其他所有的路口。 一条赛道是一组互不相同的道路 e1,e2,…,eke_1,e_2,…,e_ke1​,e2​,…,ek​，满足可以从某个路口出发，依次经过 道路 e1,e2,…,eke_1,e_2,…,e_ke1​,e2​,…,ek​（每条道路经过一次，不允许调头）到达另一个路口。一条赛道的长度等于经过的各道路的长度之和。为保证安全，要求每条道路至多被一条赛道经过。 目前赛道修建的方案尚未确定。你的任务是设计一种赛道修建的方案，使得修建的 mmm 条赛道中长度最小的赛道长度最大（即 mmm 条赛道中最短赛道的长度尽可能大） 输入格式: 输入文件第一行包含两个由空格分隔的正整数 n,mn,mn,m，分别表示路口数及需要修建的 赛道数。 接下来 n−1n-1n−1 行，第 iii 行包含三个正整数 ai,bi,lia_i,b_i,l_iai​,bi​,li​，表示第 iii 条适合于修建赛道的道 路连接的两个路口编号及道路长度。保证任意两个路口均可通过这 n−1n-1n−1 条道路相互到达。每行中相邻两数之间均由一个空格分隔。 输出格式: 输出共一行，包含一个整数，表示长度最小的赛道长度的最大值。 样例: 样例输入 1: 7 1 1 2 10 1 3 5 2 4 9 2 5 8 3 6 6 3 7 7 样例输出 1: 31 样例输入 2: 9 3 1 2 6 2 3 3 3 4 5 4 5 10 6 2 4 7 2 9 8 4 7 9 4 4 样例输出 2: 15 思路: 二分答案 + 贪心 实现: #include \u003cbits/stdc++.h\u003e #include \"ybwhead/ios.h\" #include \"ybwhead/edge.h\" Edge e; int n, m; multiset\u003cint\u003e s[maxn]; multiset\u003cint\u003e::iterator it; int ans; int dfs(int u, int fa, int xk) { s[u].clear(); int wv; for (int i = e.head[u]; i; i = e.e[i].nxt) { int v = e.e[i].v, w = e.e[i].w; if (v == fa) continue; wv = dfs(v, u, xk) + w; if (wv \u003e= xk) ans++; else s[u].insert(wv); } wv = 0; while (!s[u].empty()) { if (s[u].size() == 1) return max(wv, *s[u].begin()); it = s[u].lower_bound(xk - *s[u].begin()); if (it == s[u].begin() \u0026\u0026 s[u].count(*it) == 1) it++; if (it == s[u].end()) { wv = max(wv, *s[u].begin()); s[u].erase(s[u].find(*s[u].begin())); } else { ans++; s[u].erase(s[u].find(*it)); s[u].erase(s[u].find(*s[u].begin())); } } return wv; } int check(int x) { ans = 0; dfs(1, 0, x); return ans \u003e= m; } int main() { yin \u003e\u003e n \u003e\u003e m; int r = 0; for (int i = 1; i \u003c n; i++) { int x, y, z; yin \u003e\u003e x \u003e\u003e y \u003e\u003e z; e.add(x, y, z); r += z; } int l = 1; r /= m; while (l \u003c r) { int mid = (l + r + 1) \u003e\u003e 1; if (check(mid)) { l = mid; } else { r = mid - 1; } } yout \u003c\u003c l \u003c\u003c endl; return 0; } ","date":"2020-05-03","objectID":"/posts/oi/problems/p5021/:0:0","series":null,"tags":["贪心",2018,"二分答案","NOIp提高组","最近公共祖先,LCA","Notebooks/OI/OJ/Luogu"],"title":"P5021-赛道修建","uri":"/posts/oi/problems/p5021/#"},{"categories":null,"content":"P4390-[BOI2007]Mokia 摩基亚 题目: 题目描述: 摩尔瓦多的移动电话公司摩基亚（Mokia）设计出了一种新的用户定位系统。和其他的定位系统一样，它能够迅速回答任何形如“用户 C 的位置在哪？”的问题，精确到毫米。但其真正高科技之处在于，它能够回答形如“给定区域内有多少名用户？”的问题。 在定位系统中，世界被认为是一个 W×W 的正方形区域，由 1×1 的方格组成。每个方格都有一个坐标(x,y)，1\u003c=x,y\u003c=W。坐标的编号从 1 开始。对于一个 4×4 的正方形，就有 1\u003c=x\u003c=4,1\u003c=y\u003c=4（如图）： 请帮助 Mokia 公司编写一个程序来计算在某个矩形区域内有多少名用户。 输入格式: 有三种命令，意义如下： 命令 参数 意义 0 W 初始化一个全零矩阵。本命令仅开始时出现一次。 1 x y A 向方格(x,y)中添加 A 个用户。A 是正整数。 2 X1 Y1 X2 Y2 查询 X1\u003c=x\u003c=X2，Y1\u003c=y\u003c=Y2 所规定的矩形中的用户数量 3 无参数 结束程序。本命令仅结束时出现一次。 输出格式: 对所有命令 2，输出一个一行整数，即当前询问矩形内的用户数量。 样例: 样例输入 1: 0 4 1 2 3 3 2 1 1 3 3 1 2 2 2 2 2 2 3 4 3 样例输出 1: 3 5 思路: 基于时间序的 cdq 分治 + 二维偏序 实现: #include \u003cbits/stdc++.h\u003e #include \"ybwhead/ios.h\" const int maxn = 1e5 + 10; struct pos { bool op; int x, y; long long v; int id; } e[maxn \u003c\u003c 2]; int w; int tot, cnt; bool cmp(pos a, pos b) { return a.x \u003c b.x; } #define lowbit(x) x \u0026 -x long long a[maxn \u003c\u003c 6]; long long s; long long ans[maxn]; void add(int p, long long x) { for (; p \u003c= w + 1; p += lowbit(p)) a[p] += x; } int q(int p) { long long ans = 0; for (; p; p -= lowbit(p)) ans += a[p]; return ans; } void cdq(int l, int r) { if (l == r) return; int mid = (l + r) \u003e\u003e 1; cdq(l, mid); sort(e + l, e + mid + 1, cmp); cdq(mid + 1, r); sort(e + mid + 1, e + r + 1, cmp); int p1 = l, p2 = mid + 1; while (p2 \u003c= r) { while (p1 \u003c= mid \u0026\u0026 e[p1].x \u003c= e[p2].x) { if (e[p1].op == 0) add(e[p1].y, e[p1].v); p1++; } if (e[p2].op == 1) ans[e[p2].id] += q(e[p2].y) * e[p2].v; p2++; } p1 = l, p2 = mid + 1; while (p2 \u003c= r) { while (p1 \u003c= mid \u0026\u0026 e[p1].x \u003c= e[p2].x) { if (e[p1].op == 0) add(e[p1].y, -e[p1].v); p1++; } // if (e[p2].op == 2) // ans[e[p2].id] += q(e[p2].y) * e[p2].v; p2++; } return; } int main() { yin \u003e\u003e s \u003e\u003e w; int op = 0; while (yin \u003e\u003e op \u0026\u0026 op != 3) { int x, y, x1, y1; long long v; if (op == 1) { yin \u003e\u003e x \u003e\u003e y \u003e\u003e v; x++; y++; e[++tot] = {0, x, y, v, 0}; } else { yin \u003e\u003e x \u003e\u003e y \u003e\u003e x1 \u003e\u003e y1; x++; y++; x1++; y1++; ++cnt; e[++tot] = {1, x - 1, y - 1, 1, cnt}; e[++tot] = {1, x1, y1, 1, cnt}; e[++tot] = {1, x - 1, y1, -1, cnt}; e[++tot] = {1, x1, y - 1, -1, cnt}; } } cdq(1, tot); for (int i = 1; i \u003c= cnt; i++) yout \u003c\u003c ans[i] + s \u003c\u003c endl; return 0; } ","date":"2020-05-02","objectID":"/posts/oi/problems/p4390/:0:0","series":null,"tags":["树状数组","分治","归并排序","高性能","Notebooks/OI/OJ/Luogu"],"title":"P4390-[BOI2007]Mokia 摩基亚","uri":"/posts/oi/problems/p4390/#"},{"categories":null,"content":"P3402-可持久化并查集 题目: 题目描述: 给定 nnn 个集合，第 iii 个集合内初始状态下只有一个数，为 iii。 有 mmm 次操作。操作分为 333 种： 1 a b 合并 a,ba,ba,b 所在集合； 2 k 回到第 kkk 次操作（执行三种操作中的任意一种都记为一次操作）之后的状态； 3 a b 询问 a,ba,ba,b 是否属于同一集合，如果是则输出 111 ，否则输出 000。 输入格式: 第一行两个整数，n,mn,mn,m。 接下来 mmm 行，每行先输入一个数 optoptopt。若 opt=2opt=2opt=2 则再输入一个整数 kkk，否则再输入两个整数 a,ba,ba,b，描述一次操作。 输出格式: 对每个操作 333，输出一行一个整数表示答案。 样例: 样例输入 1: 5 6 1 1 2 3 1 2 2 0 3 1 2 2 1 3 1 2 样例输出 1: 1 0 1 思路: 首先明确一点，本题考得不是并查集，而是可持久化 跟并查集没啥关系。 而且在这道题中用不带路径压缩的并查集（欢迎推翻这个 flag） 然后我们看到‘历史版本’，自然而然想到可持久化数据结构–主席树。 那我们用主席树干什么呢？ 维护每一个版本中每一个点的父亲，也就是我们熟悉的并查集中的 fa[x] 再然后，因为我们用用不带路径压缩的并查集 所以对于每一次合并只会改一个点的父亲 所以一个版本的相对于上一个版本只会改一个点 所以有很多地方可以共用 这也证明了为什么要用可持久化数据结构 （可持久化数据结构就是共用一些点来达到节省空间的效果） 明白了主席树的作用之后，并查集中 find_fa 的思路大体上就出来了： 1.在主席树上，查询某一个版本中一个点的父亲 2.它成为它的父亲 3.重复步骤 1,直到找到 root 但是我们发现，如果并查集退化成一条链，find_fa 复杂度会很高（虽然这题很水，暴力都可以过去） 又不能路径压缩（不然就不能一次修改一个点，就不好搞可持久化了）（欢迎推翻这个 flag） 于是我们可以在 Union 上下一点功夫使得它不会变成一条链 想到合并方法–启发式合并 怎么启发？ 把最大深度小的往最大深度大的上并 于是最大深度大的深度不会增加 而是最大深度小的增加深度 这样不久巧妙地保证了深度均衡吗？ 好了，基本上是讲完了 实在不懂可以看着代码理解 代码在下面，有注释 实现: #include \u003cbits/stdc++.h\u003e #include \"ybwhead/ios.h\" int n, m; const int maxn = 2e5 + 10; int tot; int root[maxn]; struct T { int l, r, f, d; } t[maxn \u003c\u003c 5]; inline int build(int l, int r) { int p = ++tot; if (l == r) { t[p].f = l; t[p].d = 1; return p; } int mid = (l + r) \u003e\u003e 1; t[p].l = build(l, mid); t[p].r = build(mid + 1, r); return p; } inline int ask(int p, int l, int r, int x) { while (l \u003c r) { int mid = (l + r) \u003e\u003e 1; if (x \u003c= mid) { r = mid; p = t[p].l; } else { l = mid + 1; p = t[p].r; } } return p; } inline int add(int pre, int l, int r, int x) { int p = ++tot; if (l == r) { t[p].f = x; t[p].d = t[pre].d + 1; return p; } t[p].l = t[pre].l; t[p].r = t[pre].r; int mid = (l + r) \u003e\u003e 1; if (x \u003c= mid) t[p].l = add(t[pre].l, l, mid, x); else t[p].r = add(t[pre].r, mid + 1, r, x); return p; } inline int add(int pre, int l, int r, int s, int f) { int p = ++tot; if (l == r) { t[p].f = f; t[p].d = t[pre].d; return p; } t[p].l = t[pre].l; t[p].r = t[pre].r; int mid = (l + r) \u003e\u003e 1; if (s \u003c= mid) t[p].l = add(t[pre].l, l, mid, s, f); else t[p].r = add(t[pre].r, mid + 1, r, s, f); return p; } int gf(int rt, int x) { int k = ask(rt, 1, n, x); if (t[k].f == x) return k; return gf(rt, t[k].f); } int main() { yin \u003e\u003e n \u003e\u003e m; root[0] = build(1, n); int ans = 0, o, x, y; for (int i = 1; i \u003c= m; i++) { root[i] = root[i - 1]; yin \u003e\u003e o; if (o == 1) { yin \u003e\u003e x \u003e\u003e y; int rx = gf(root[i], x); int ry = gf(root[i], y); if (t[rx].f == t[ry].f) continue; if (t[rx].d \u003e t[ry].d) swap(rx, ry); root[i] = add(root[i - 1], 1, n, t[rx].f, t[ry].f); if (t[rx].d == t[ry].d) root[i] = add(root[i], 1, n, t[ry].f); } else if (o == 2) { yin \u003e\u003e x; root[i] = root[x]; } else { yin \u003e\u003e x \u003e\u003e y; int rx = gf(root[i], x); int ry = gf(root[i], y); yout \u003c\u003c (ans = rx == ry) \u003c\u003c endl; } } } ","date":"2020-05-01","objectID":"/posts/oi/problems/p3402/:0:0","series":null,"tags":["高性能","Notebooks/OI/OJ/Luogu"],"title":"P3402-可持久化并查集","uri":"/posts/oi/problems/p3402/#"},{"categories":null,"content":"P3172-[CQOI2015]选数 题目: 题目描述: 我们知道，从区间 [L,H][L,H][L,H]（LLL 和 HHH 为整数）中选取 NNN 个整数，总共有 (H−L+1)N(H-L+1)^N(H−L+1)N 种方案。小 z 很好奇这样选出的数的最大公约数的规律，他决定对每种方案选出的 NNN 个整数都求一次最大公约数，以便进一步研究。然而他很快发现工作量太大了，于是向你寻求帮助。你的任务很简单，小 z 会告诉你一个整数 KKK，你需要回答他最大公约数刚好为 KKK 的选取方案有多少个。由于方案数较大，你只需要输出其除以 109+710^9+7109+7 的余数即可。 输入格式: 输入一行，包含四个空格分开的正整数，依次为 N,K,L,HN,K,L,HN,K,L,H。 输出格式: 输出一个整数，为所求方案数。 样例: 样例输入 1: 2 2 2 4 样例输出 1: 3 思路: 首先，进行如下处理： 1、如果LLL是KKK的倍数，那么把LLL变为LK\\frac{L}{K}KL​，否则变为⌊LK⌋+1\\lfloor\\frac{L}{K}\\rfloor+1⌊KL​⌋+1。 2、把HHH变成⌊HK⌋\\lfloor\\frac{H}{K}\\rfloor⌊KH​⌋。 这样子容易得出，现在要求的就是在[L,H][L,H][L,H]之间，选数NNN次使选出的数最大公约数为111的方案数。 现在，用fif_ifi​表示选出的数的最大公约数iii且选出的数不全相同的方案数。此时先求出[L,H][L,H][L,H]之间iii的倍数的个数xxx，暂时令fi=xN−xf_i=x^N-xfi​=xN−x。 但此时得到的fif_ifi​实际上是含有公约数iii的方案数，不是最大公约数为iii的方案数。但是可以发现，此时的fif_ifi​包含有最大公约数为i,2i,3i,...i,2i,3i,...i,2i,3i,...的方案数。这时候使用容斥原理：假设已经知道了f2i,f3i,...f_{2i},f_{3i},...f2i​,f3i​,...的最终结果，那么就把fif_ifi​分别减去f2i,f3i,...f_{2i},f_{3i},...f2i​,f3i​,...，就可以得到fif_ifi​的最终结果。倒着推一遍。 特殊情况：L=1L=1L=1时可以所有的数都选111。所以L=1L=1L=1时答案要加111。 代码： 实现: #include \u003cbits/stdc++.h\u003e #include \"ybwhead/ios.h\" using namespace std; const int mod = 1e9 + 7; int n, k, l, h; long long ksm(long long a, int n) { if (n == 1) return a; if (n == 0) return 1; long long ans = ksm(a, n \u003e\u003e 1); ans = ans * ans % mod; if (n \u0026 1) ans = a * ans % mod; return ans; } const int maxn = 1e5 + 7; int f[maxn]; int main() { yin \u003e\u003e n \u003e\u003e k \u003e\u003e l \u003e\u003e h; l = (l + k - 1) / k; h /= k; if (l \u003e h) { puts(\"0\"); return 0; } for (int i = 1; i \u003c= h - l; i++) { int L = l, r = h; if (L % i) L = L / i + 1; else L /= i; r /= i; if (L \u003e r) continue; f[i] = (ksm(r - L + 1, n) - (r - L + 1) + mod) % mod; } for (int i = h - l; i; i--) for (int j = (i \u003c\u003c 1); j \u003c= h - l; j += i) f[i] = (f[i] - f[j] + mod) % mod; if (l == 1) (f[1] += 1) %= mod; cout \u003c\u003c f[1] \u003c\u003c endl; return 0; } ","date":"2020-04-19","objectID":"/posts/oi/problems/p3172/:0:0","series":null,"tags":["递推",2015,"重庆","最大公约数,gcd","莫比乌斯反演","高性能","Notebooks/OI/OJ/Luogu"],"title":"P3172-[CQOI2015]选数","uri":"/posts/oi/problems/p3172/#"},{"categories":null,"content":"P3327-[SDOI2015]约数个数和 题目: 题目描述: 设 d(x)d(x)d(x) 为 xxx 的约数个数，给定 n,mn,mn,m，求 ∑i=1n∑j=1md(ij)\\sum_{i=1}^n\\sum_{j=1}^md(ij)i=1∑n​j=1∑m​d(ij)输入格式: 输入文件包含多组测试数据。 第一行，一个整数 TTT，表示测试数据的组数。 接下来的 TTT 行，每行两个整数 n,mn,mn,m。 输出格式: TTT 行，每行一个整数，表示你所求的答案。 样例: 样例输入 1: 2 7 4 5 6 样例输出 1: 110 121 思路: 首先给出一个公式： d(ij)=∑x∣i∑y∣j[gcd⁡(x,y)=1]d(ij)=\\sum\\limits_{x\\mid i}\\sum\\limits_{y\\mid j} [\\gcd(x,y)=1]d(ij)=x∣i∑​y∣j∑​[gcd(x,y)=1]因此所求为 ∑i=1n∑j=1m∑x∣i∑y∣j[gcd⁡(x,y)=1]\\sum\\limits_{i=1}^n\\sum\\limits_{j=1}^m\\sum\\limits_{x\\mid i}\\sum\\limits_{y\\mid j} [\\gcd(x,y)=1]i=1∑n​j=1∑m​x∣i∑​y∣j∑​[gcd(x,y)=1]改变求和顺序，先枚举因数 xxx 和 yyy ∑x=1n∑y=1m⌊nx⌋⌊my⌋[gcd⁡(x,y)=1]\\sum\\limits_{x=1}^n\\sum\\limits_{y=1}^m \\left\\lfloor\\frac{n}{x}\\right\\rfloor \\left\\lfloor\\frac{m}{y}\\right\\rfloor [\\gcd(x,y)=1]x=1∑n​y=1∑m​⌊xn​⌋⌊ym​⌋[gcd(x,y)=1]将 x,yx,yx,y 换成 i,ji,ji,j 吧 QAQ ∑i=1n∑j=1m⌊ni⌋⌊mj⌋[gcd⁡(i,j)=1]\\sum\\limits_{i=1}^n\\sum\\limits_{j=1}^m \\left\\lfloor\\frac{n}{i}\\right\\rfloor \\left\\lfloor\\frac{m}{j}\\right\\rfloor[\\gcd(i,j)=1]i=1∑n​j=1∑m​⌊in​⌋⌊jm​⌋[gcd(i,j)=1]开始莫比乌斯反演！设 f(x)=∑i=1n∑j=1m⌊ni⌋⌊mj⌋[gcd⁡(i,j)=x]f(x)=\\sum\\limits_{i=1}^n\\sum\\limits_{j=1}^m \\left\\lfloor\\frac{n}{i}\\right\\rfloor \\left\\lfloor\\frac{m}{j}\\right\\rfloor[\\gcd(i,j)=x]f(x)=i=1∑n​j=1∑m​⌊in​⌋⌊jm​⌋[gcd(i,j)=x]g(x)=∑x∣df(d)g(x)=\\sum_{x\\mid d} f(d)g(x)=x∣d∑​f(d)则有 g(x)=∑i=1n∑j=1m⌊ni⌋⌊mj⌋[x∣gcd⁡(i,j)]g(x)=\\sum\\limits_{i=1}^n\\sum\\limits_{j=1}^m \\left\\lfloor\\frac{n}{i}\\right\\rfloor \\left\\lfloor\\frac{m}{j}\\right\\rfloor[x\\mid\\gcd(i,j)]g(x)=i=1∑n​j=1∑m​⌊in​⌋⌊jm​⌋[x∣gcd(i,j)]我们把 xxx 提出就可以消除 gcd⁡\\gcdgcd 的影响 g(x)=∑i=1nx∑j=1mx⌊nix⌋⌊mjx⌋g(x)=\\sum\\limits_{i=1}^{\\frac{n}{x}}\\sum\\limits_{j=1}^{\\frac{m}{x}} \\left\\lfloor\\frac{n}{ix}\\right\\rfloor \\left\\lfloor\\frac{m}{jx}\\right\\rfloorg(x)=i=1∑xn​​j=1∑xm​​⌊ixn​⌋⌊jxm​⌋再根据 f(x)f(x)f(x) 的定义，得到答案为 f(1)f(1)f(1) 又因为 f(n)=∑n∣dμ(dn)g(d)f(n)=\\sum\\limits_{n\\mid d}\\mu(\\frac{d}{n})g(d)f(n)=n∣d∑​μ(nd​)g(d)故 f(1)=∑1∣dμ(d1)g(d)=∑i=1nμ(i)g(i)f(1)=\\sum\\limits_{1\\mid d}\\mu(\\frac{d}{1})g(d)=\\sum_{i=1}^n \\mu(i)g(i)f(1)=1∣d∑​μ(1d​)g(d)=i=1∑n​μ(i)g(i)接下来再考虑如何求 g(x)g(x)g(x)，我们可以先计算 s(x)=∑i=1x⌊xi⌋s(x)=\\sum\\limits_{i=1}^{x} \\left\\lfloor\\frac{x}{i}\\right\\rfloors(x)=i=1∑x​⌊ix​⌋，就可以 Θ(1)\\Theta(1)Θ(1) 计算 g(x)g(x)g(x)。 时间复杂度：Θ(Tn)\\Theta(T\\sqrt{n})Θ(Tn​) 如何证明 Solution 中的公式？ d(ij)=∑x∣i∑y∣j[gcd⁡(x,y)=1]d(ij)=\\sum\\limits_{x\\mid i}\\sum\\limits_{y\\mid j} [\\gcd(x,y)=1]d(ij)=x∣i∑​y∣j∑​[gcd(x,y)=1]我们考虑把每个因子一一映射。 如果 ijijij 的因子 kkk 中有一个因子 pcp^cpc，iii 中有因子 pap^apa，jjj 中有因子 pbp^bpb。我们规定： 如果 c⩽ac\\leqslant ac⩽a，那么在 iii 中选择。 如果 c\u003eac\u003eac\u003ea，那么我们把 ccc 减去 aaa，在 jjj 中选择 pc−ap^{c-a}pc−a（在 jjj 中选择 pep^epe 表示的是 pa+ep^{a+e}pa+e） 对于 ijijij 的因子 kkk 的其他因子同理。于是对于任何一个 kkk 有一个唯一的映射，且每一个选择对应着唯一的 kkk。 通过如上过程，我们发现：对于 ijijij 的因子 k=∏picik=\\prod {p_i}^{c_i}k=∏pi​ci​，我们不可能同时在 iii 和 jjj 中选择 pip_ipi​（优先在 iii 中选择，如果不够就只在 jjj 中选择不够的指数），故 xxx 和 yyy 必须互质。 等式得证。 实现: // Problem : P3327 [SDOI2015]约数个数和 // Contest : Luogu // URL : https://www.luogu.com.cn/problem/P3327 // Memory Limit : 125 MB // Time Limit : 1000 ms // Powered by CP Editor (https://github.com/cpeditor/cpeditor) /* *User: $%U%$ *Time: $%Y%$.$%M%$.$%D%$ $%h%$:$%m%$:$%s%$ */ #include \u003cbits/stdc++.h\u003e using namespace std; #ifndef use_ios11 #define use_ios11 using namespace std; struct ins { int ans; ins() { ans = 1; } #define endl '\\n' void read() { } void read1(char \u0026s) { char c = getchar(); for (; !isprint(c) || c == ' ' || c == '\\n' || c == '\\t'; c = getchar()) ; s = c; if (c == EOF) ans = 0; } void read1(string \u0026s) { s = \"\"; char c = getchar(); for (; !isprint(c) || c == ' ' || c == '\\n' || c == '\\t'; c = getchar()) ; for (; isprint(c) \u0026\u0026 c != ' ' \u0026\u0026 c != '\\n' \u0026\u0026 c != '\\t'; c = getchar()) s += c; if (c == EOF) ans = 0; } template \u003ctypename T\u003e void read1(T \u0026n) { T x = 0; int f = 1; char c = getchar(); for (; !isdigit(c); c = getchar()) { if (c == '-') f = -1; if (c == EOF) { ans = 0; return; } } for (; isdigit(c); c = getchar()) x = x * 10 + c - 48; n = x * f; if (c == EOF) ans = 0; if (c != '.') return; T l = 0.1; while ((c = getchar()) \u003c= '9' \u0026\u0026 c \u003e= '0') x = x + (c \u0026 15) * l, l *= 0.1; n = x * f; if (c == EOF) ans","date":"2020-04-19","objectID":"/posts/oi/problems/p3327/:0:0","series":null,"tags":["数论,数学",2015,"山东","最大公约数,gcd","莫比乌斯反演","高性能","Notebooks/OI/OJ/Luogu"],"title":"P3327-[SDOI2015]约数个数和","uri":"/posts/oi/problems/p3327/#"},{"categories":null,"content":"P2114-[NOI2014]起床困难综合症 题目: 题目描述: 21世纪，许多人得了一种奇怪的病：起床困难综合症，其临床表现为：起床难，起床后精神不佳。作为一名青春阳光好少年，atm一直坚持与起床困难综合症作斗争。通过研究相关文献，他找到了该病的发病原因： 在深邃的太平洋海底中，出现了一条名为drd的巨龙，它掌握着睡眠之精髓，能随意延长大家的睡眠时间。 正是由于drd的活动，起床困难综合症愈演愈烈， 以惊人的速度在世界上传播。为了彻底消灭这种病，atm决定前往海底，消灭这条恶龙。历经千辛万苦，atm终于来到了drd所在的地方，准备与其展开艰苦卓绝的战斗。drd有着十分特殊的技能，他的防御战线能够使用一定的运算来改变他受到的伤害。具体说来，drd的防御战线由n扇防御门组成。每扇防御门包括一个运算op和一个参数t，其中运算一定是OR, XOR, AND中的一种，参数则一定为非负整数。如果还未通过防御门时攻击力为x，则其通过这扇防御门后攻击力将变为x op t。最终drd受到的伤害为对方初始攻击力x依次经过所有n扇防御门后转变得到的攻击力。 由于atm水平有限，他的初始攻击力只能为0到m之间的一个整数（即他的初始攻击力只能在 0, 1, … , m中任选，但在通过防御门之后的攻击力不受m的限制）。为了节省体力，他希望通过选择合适的初始攻击力使得他的攻击能让drd受到最大的伤害，请你帮他计算一下，他的一次攻击最多能使drd受到多少伤害。 输入格式: 输入文件的第 1 行包含 2 个整数，依次为n, m，表示 drd 有n扇防御门，atm 的初始攻击力为0到m之间的整数。 接下来n行，依次表示每一扇防御门。每行包括一个字符串op和一个非负整数t，两者由一个空格隔开，且op在前，t在后，op表示该防御门所对应的操作，t表示对应的参数。 输出格式: 输出一行一个整数，表示atm的一次攻击最多使drd受到多少伤害。 样例: 样例输入1: 3 10 AND 5 OR 6 XOR 7 样例输出1: 1 思路: 实现: #include \u003cbits/stdc++.h\u003e #include \"ybwhead/ios.h\" int a1 = 0, a2 = -1; int main() { int n, m; yin \u003e\u003e n \u003e\u003e m; while (n--) { string s; int x; yin \u003e\u003e s \u003e\u003e x; if (s[0] == 'A') { a1 \u0026= x; a2 \u0026= x; } if (s[0] == 'O') { a1 |= x; a2 |= x; } if (s[0] == 'X') { a1 ^= x; a2 ^= x; } } int ans = 0; for (int i = 29; ~i; i--) if (a1 \u003e\u003e i \u0026 1) ans += 1 \u003c\u003c i; else if (a2 \u003e\u003e i \u0026 1 \u0026\u0026 (1 \u003c\u003c i) \u003c= m) ans += 1 \u003c\u003c i, m -= 1 \u003c\u003c i; yout \u003c\u003c ans \u003c\u003c endl; return 0; } ","date":"2020-04-05","objectID":"/posts/oi/problems/p2114/:0:0","series":null,"tags":["dp","贪心",2014,"NOI系列","位运算, 按位","高性能","Notebooks/OI/OJ/Luogu"],"title":"P2114-[NOI2014]起床困难综合症","uri":"/posts/oi/problems/p2114/#"},{"categories":null,"content":"P4180-[BJWC2010]严格次小生成树 题目: 题目描述: 小 C 最近学了很多最小生成树的算法，Prim 算法、Kurskal 算法、消圈算法等等。正当小 C 洋洋得意之时，小 P 又来泼小 C 冷水了。小 P 说，让小 C 求出一个无向图的次小生成树，而且这个次小生成树还得是严格次小的，也就是说：如果最小生成树选择的边集是 EM，严格次小生成树选择的边集是 ES，那么需要满足：(value(e)表示边 e 的权值) ∑e∈EMvalue(e)\u003c∑e∈ESvalue(e)\\sum_{e \\in E_M}value(e)\u003c\\sum_{e \\in E_S}value(e)∑e∈EM​​value(e)\u003c∑e∈ES​​value(e) 这下小 C 蒙了，他找到了你，希望你帮他解决这个问题。 输入格式: 第一行包含两个整数 N 和 M，表示无向图的点数与边数。 接下来 M 行，每行 3 个数 x y z 表示，点 x 和点 y 之间有一条边，边的权值为 z。 输出格式: 包含一行，仅一个数，表示严格次小生成树的边权和。(数据保证必定存在严格次小生成树) 样例: 样例输入 1: 5 6 1 2 1 1 3 2 2 4 3 3 5 4 3 4 3 4 5 6 样例输出 1: 11 思路: 要开long long 判自环 实现: // Problem : P4180 [BJWC2010]严格次小生成树 // Contest : Luogu Online Judge // URL : https://www.luogu.com.cn/problem/P4180 // Memory Limit : 500 MB // Time Limit : 1000 ms // Powered by CP Editor (https://github.com/cpeditor/cpeditor) #include \u003cbits/stdc++.h\u003e using namespace std; #include \"ybwhead/ios.h\" const int maxn = 1e5 + 100; #define int long long int f[maxn]; struct line { int x, y, z; } a[maxn * 3 + 5]; int cmp(line a, line b) { return a.z \u003c b.z; } int head[maxn]; struct edge { int v, w, nxt; } e[maxn \u003c\u003c 1]; int tot; void __ADD(int u, int v, int w) { e[++tot].v = v; e[tot].w = w; e[tot].nxt = head[u]; head[u] = tot; } void add(int u, int v, int w) { // cerr \u003c\u003c u \u003c\u003c \" \" \u003c\u003c v \u003c\u003c \" \" \u003c\u003c w \u003c\u003c endl; __ADD(u, v, w); __ADD(v, u, w); } int fa[maxn][23], mx[maxn][23]; int dep[maxn]; void dfs(int u, int f) { fa[u][0] = f; dep[u] = dep[f] + 1; for (int i = 1; i \u003c= 20; i++) { fa[u][i] = fa[fa[u][i - 1]][i - 1], mx[u][i] = max(mx[u][i - 1], mx[fa[u][i - 1]][i - 1]); } for (int i = head[u]; i; i = e[i].nxt) { int v = e[i].v; if (v == f) continue; mx[v][0] = e[i].w; dfs(v, u); } } int q(int x, int y, int z) { if (dep[x] \u003c dep[y]) swap(x, y); int ans = 0; for (int i = 20; i \u003e= 0; i--) { if (dep[fa[x][i]] \u003e= dep[y]) { if (mx[x][i] != z) ans = max(ans, mx[x][i]); x = fa[x][i]; } } if (x == y) return ans; for (int i = 20; i \u003e= 0; i--) { if (fa[x][i] != fa[y][i]) { if (mx[x][i] != z) ans = max(ans, mx[x][i]); if (mx[y][i] != z) ans = max(ans, mx[y][i]); x = fa[x][i]; y = fa[y][i]; } } return max(ans, max(mx[x][0] != z ? mx[x][0] : 0, mx[y][0] != z ? mx[y][0] : 0)); // } // // yout\u003c\u003cans\u003c\u003cendl; // return ans; } // int f[maxn]; int getf(int x) { // cerr \u003c\u003c x \u003c\u003c endl; if (x == f[x]) return x; return f[x] = getf(f[x]); } int merge(int x, int y) { int sx = getf(x), sy = getf(y); if (sx == sy) return 0; f[sx] = sy; return 1; } int n, m; signed main() { yin \u003e\u003e n \u003e\u003e m; for (int i = 1; i \u003c= n; i++) f[i] = i; for (int i = 1; i \u003c= m; i++) { yin \u003e\u003e a[i].x \u003e\u003e a[i].y \u003e\u003e a[i].z; } sort(a + 1, a + m + 1, cmp); int ans = 0, sum = LLONG_MAX; for (int i = 1; i \u003c= m; i++) { if (merge(a[i].x, a[i].y)) { add(a[i].x, a[i].y, a[i].z); ans += a[i].z; } } dfs(1, 0); for (int i = 1; i \u003c= m; i++) { if (fa[a[i].x][0] == a[i].y || fa[a[i].y][0] == a[i].x || a[i].x == a[i].y) { continue; } int xx; if ((xx = (a[i].z - q(a[i].x, a[i].y, a[i].z))) != 0) sum = min(xx, sum); // yout \u003c\u003c xx \u003c\u003c endl; } yout \u003c\u003c sum + ans \u003c\u003c endl; return 0; } ","date":"2020-04-03","objectID":"/posts/oi/problems/p4180/:0:0","series":null,"tags":[2010,"倍增","各省省选","北京","生成树","次小生成树","高性能","Notebooks/OI/OJ/Luogu"],"title":"P4180-[BJWC2010]严格次小生成树","uri":"/posts/oi/problems/p4180/#"},{"categories":null,"content":"我现在大一。 ","date":"2020-02-19","objectID":"/about/:0:0","series":null,"tags":null,"title":"About","uri":"/about/#"},{"categories":["OI","省中集训",20190811],"content":"20190811 小L的数——number 思路： 观察可得答案一定小于等于444,因为用08,04,02,0108,04,02,0108,04,02,01一定可以组合出每一个数，我们只要判断答案为1,21,21,2还是333，若都不是，则答案为444。 考虑枚举是由那些数字组成的喜欢的数来构成的答案，然后通过dpdpdp验证即可。 代码： #include\u003cbits/stdc++.h\u003e #define ll long long #define pb push_back using namespace std; ll x; int t, na, ans, a[23], su, va[20010], g[110], ng, s[55][55][55], dp[20010][22]; bool vi[20010][34]; vector\u003cint\u003e n1[20010]; int main() { //freopen(\"number.in\", \"r\", stdin); //freopen(\"number.out\", \"w\", stdout); for (int i = 0; i \u003c= 8; i++) for (int j = i + 1; j \u003c= 9; j++)g[++ng] = i * 10 + j; memset(vi, 0, sizeof(vi)); for (int i = 0; i \u003c= ng; i++) { for (int j = i; j \u003c= ng; j++) { for (int k = j; k \u003c= ng; k++) { va[++su] = 3; if (k == 0)va[su]--; if (j == 0)va[su]--; if (i == 0)va[su]--; vi[su][g[i] / 10 + g[j] / 10 + g[k] / 10] = 1; vi[su][g[i] / 10 + g[j] / 10 + g[k] % 10] = 1; vi[su][g[i] / 10 + g[j] % 10 + g[k] / 10] = 1; vi[su][g[i] / 10 + g[j] % 10 + g[k] % 10] = 1; vi[su][g[i] % 10 + g[j] / 10 + g[k] / 10] = 1; vi[su][g[i] % 10 + g[j] / 10 + g[k] % 10] = 1; vi[su][g[i] % 10 + g[j] % 10 + g[k] / 10] = 1; vi[su][g[i] % 10 + g[j] % 10 + g[k] % 10] = 1; s[i][j][k] = s[j][i][k] = s[j][k][i] = s[k][j][i] = s[i][k][j] = s[k][i][j] = su; if (s[i][j][0] != su)n1[su].pb(s[i][j][0]); if (s[i][0][k] != su)n1[su].pb(s[i][0][k]); if (s[0][j][k] != su)n1[su].pb(s[0][j][k]); if (s[i][0][0] != su)n1[su].pb(s[i][0][0]); if (s[0][0][k] != su)n1[su].pb(s[0][0][k]); if (s[0][j][0] != su)n1[su].pb(s[0][j][0]); if (s[0][0][0] != su)n1[su].pb(s[0][0][0]); } } } cin \u003e\u003e t; while (t--) { memset(dp, 0, sizeof(dp)); cin \u003e\u003e x; na = 0, ans = 4; while (x) { a[++na] = x % 10; x /= 10; } for (int i = 1; i \u003c= su; i++)dp[i][na + 1] = 1; for (int i = na; i \u003e= 1; i--) { for (int j = 1; j \u003c= su; j++) { for (int la = 0; la \u003c= 2; la++) if (dp[j][i + 1] \u0026 (1 \u003c\u003c la)) for (int no = 0; no \u003c= 2; no++) if (la * 10 + a[i] - no \u003e= 0 \u0026\u0026 vi[j][la * 10 + a[i] - no])dp[j][i] |= (1 \u003c\u003c no); for (auto k : n1[j])dp[j][i] |= dp[k][i]; } } for (int i = 1; i \u003c= su; i++)if (dp[i][1] \u0026 1) { ans = min(ans, va[i]); break; } cout \u003c\u003c ans \u003c\u003c endl; } return 0; } ","date":"2019-08-29","objectID":"/posts/oi/school/20190811-number/:0:0","series":null,"tags":["省中集训","dp/数位dp"],"title":"20190811 小L的数——number","uri":"/posts/oi/school/20190811-number/#"},{"categories":["OI","省中集训",20190811],"content":"20190811 小Y的图——graph 思路： 建出最小生成森林，考虑在最小生成森林中不连通的两个点，它们之间的答案就是-1，否则就是两点间路径权值的最大值，使用树上倍增维护即可。 代码： #include\u003cbits/stdc++.h\u003e #define N 600010 using namespace std; template \u003ctypename T\u003e void read(T \u0026x) { x = 0; char ch = getchar(); int fh = 1; while (ch \u003c '0' || ch \u003e '9') { if (ch == '-')fh = -1; ch = getchar(); } while (ch \u003e= '0' \u0026\u0026 ch \u003c= '9')x = x * 10 + ch - '0', ch = getchar(); x *= fh; } struct Info { int nu, ne, qu; } a[N * 2]; struct edge { int x, y, z; } e[N]; int num, m, n, q, b[N], f[N], d[N], ft[N][22], ma[N][22], x, y; bool vi[N]; bool c1(const edge \u0026a, const edge \u0026b) { return a.z \u003c b.z; } void jb(int x, int y, int z) { a[++num].nu = y; a[num].ne = b[x]; b[x] = num; a[num].qu = z; a[++num].nu = x; a[num].ne = b[y]; b[y] = num; a[num].qu = z; } int que(int x) { if (f[x] != x) f[x] = que(f[x]); return f[x]; } void dfs(int x, int fa, int dep) { ft[x][0] = fa; d[x] = dep; vi[x] = 0; for (int y = b[x]; y; y = a[y].ne)if (vi[a[y].nu]) { dfs(a[y].nu, x, dep + 1); ma[a[y].nu][0] = a[y].qu; } } int lca(int x, int y) { int an = 0; if (d[x] \u003c d[y]) swap(x, y); for (int i = 18; i \u003e= 0; i--)if (d[ft[x][i]] \u003e= d[y]) { an = max(an, ma[x][i]); x = ft[x][i]; } for (int i = 18; i \u003e= 0; i--) { if (ft[x][i] != ft[y][i]) { an = max(an, max(ma[x][i], ma[y][i])); x = ft[x][i]; y = ft[y][i]; } } if (x != y) { an = max(an, max(ma[x][0], ma[y][0])); x = ft[x][0]; y = ft[y][0]; } return an; } int main() { //freopen(\"graph.in\", \"r\", stdin); //freopen(\"graph.out\", \"w\", stdout); read(n); read(m); read(q); for (int i = 1; i \u003c= m; i++) { read(e[i].x); read(e[i].y); read(e[i].z); } for (int i = 1; i \u003c= n; i++)f[i] = i; sort(e + 1, e + m + 1, c1); for (int i = 1; i \u003c= m; i++) { int nx = que(e[i].x), ny = que(e[i].y); if (f[nx] != ny) { f[nx] = ny; jb(e[i].x, e[i].y, e[i].z); } } for (int i = 1; i \u003c= n; i++)vi[i] = 1; for (int i = 1; i \u003c= n; i++)if(vi[i])dfs(i, 0, 1); for (int i = 2, j = 1; i \u003c= n; i *= 2, j++) for (int k = 1; k \u003c= n; k++) { ft[k][j] = ft[ft[k][j - 1]][j - 1]; ma[k][j] = max(ma[k][j - 1], ma[ft[k][j - 1]][j - 1]); } for (int i = 1; i \u003c= q; i++) { read(x); read(y); if (que(x) != que(y))puts(\"-1\"); else printf(\"%d\\n\", lca(x, y)); } return 0; } ","date":"2019-08-29","objectID":"/posts/oi/school/20190811-graph/:0:0","series":null,"tags":["省中集训","图论/最小生成树","图论/lca"],"title":"20190811 小Y的图——graph","uri":"/posts/oi/school/20190811-graph/#"},{"categories":["OI","省中集训",20190811],"content":"这是一篇校内集训文章。","date":"2019-08-29","objectID":"/posts/oi/school/20190811-magic/","series":null,"tags":["计数","省中集训"],"title":"20190811 小W的魔术——magic","uri":"/posts/oi/school/20190811-magic/"},{"categories":["OI","省中集训",20190811],"content":"20190811 小W的魔术——magic 思路 考虑可行的字符串有多少个，对于一个可行的字符串，枚举它与s最长公共前缀，若为000，则为26n−l26^{n-l}26n−l,否则为25×26n−l−125\\times{26^{n-l-1}}25×26n−l−1,用总的字符串数减去不可行的字符串数即可，答案为26n−26n−l−l×25×26n−l−126^n-26^{n-l}-l\\times{25}\\times{26^{n-l-1}}26n−26n−l−l×25×26n−l−1。 代码 #include\u003cbits/stdc++.h\u003e #define mo 998244353 #define ll long long using namespace std; ll n, l; string s; ll po(ll x, ll y) { if (y \u003c 0)return 0; ll z = 1; while (y) { if (y % 2)z = x * z % mo; x = x * x % mo; y /= 2; } return z; } int main() { // freopen(\"magic.in\", \"r\", stdin); // freopen(\"magic.out\", \"w\", stdout); ios::sync_with_stdio(false); cin \u003e\u003e n \u003e\u003e s; l = s.length(); if (n \u003c l) cerr \u003c\u003c \"gg\" \u003c\u003c endl; cout \u003c\u003c (po(26, n) + mo - po(26, n - l) + (mo - l) * (25 * po(26, n - l - 1) % mo)) % mo; return 0; } ","date":"2019-08-29","objectID":"/posts/oi/school/20190811-magic/:0:0","series":null,"tags":["计数","省中集训"],"title":"20190811 小W的魔术——magic","uri":"/posts/oi/school/20190811-magic/#"},{"categories":["OI","省中集训",20190810],"content":"20190810 替身使者——stand 思路： 对于g(x)g(x)g(x),显然x最大是最优的 考虑用区间DP,设f[l][r]f[l][r]f[l][r]代表 l 到 r 区间内的g(x)的最大值 则状态转移方程为 f[l][r]=max⁡j=l+1j\u003crf[l][j−1]+f[j+1][r]+g(peoplenum(j))f[l][r]=\\max_{j=l+1}^{j\u003cr}f[l][j-1]+f[j+1][r]+g(peoplenum(j))f[l][r]=maxj=l+1j\u003cr​f[l][j−1]+f[j+1][r]+g(peoplenum(j)) 但是发现 lll 与 rrr 都在 1e71e71e7 范围内,显然不行,所以要离散化 对于统计peoplenumpeople_numpeoplen​um,可以枚举在 lll 到 rrr 中所有区间,用差分来统计即可 #include\u003cbits/stdc++.h\u003e using namespace std; template \u003ctypename T\u003e inline void read(T \u0026F) { F = 0; int R = 1; char CH = getchar(); while(!isdigit(CH) \u0026\u0026 CH != '-') CH = getchar(); if(CH == '-') R = -1; else F = (CH ^ 48); CH = getchar(); while(isdigit(CH)) F = (F \u003c\u003c 1) + (F \u003c\u003c 3) + (CH ^ 48), CH = getchar(); F *= R; } long long f[1010][1010]; struct sz { int li, ri; } ai[310]; int gx[6], ls[1010], num, n, m, ans; bool vis[1010][1010]; long long sum(long long x) { return gx[1] * x + gx[2] * x * x + gx[3] * x * x * x + gx[4] * x * x * x * x + gx[5] * x * x * x * x * x; } long long Dp(int ll, int rr) { if(ll \u003e rr) return 0; if(vis[ll][rr]) return f[ll][rr]; vis[ll][rr] = 1; int qi[rr - ll + 1] = {0}; for(int i = 1; i \u003c= n; i++) if(ai[i].li \u003e= ll \u0026\u0026 ai[i].ri \u003c= rr) { qi[ai[i].li - ll]++; if(ai[i].ri \u003c rr) qi[ai[i].ri - ll + 1]--; } long long ans = 0, pi = 0; for(int i = 0; i \u003c rr - ll + 1; i++) { pi += qi[i]; if(pi) ans = max(ans, Dp(ll, ll + i - 1) + Dp(ll + i + 1, rr) + sum(pi)); } return f[ll][rr] = ans; } int main() { // freopen(\"stand.in\", \"r\", stdin); // freopen(\"stand.out\", \"w\", stdout); read(n), read(m); for(int i = 1; i \u003c= 5; i++) read(gx[i]); for(int i = 1; i \u003c= n; i++) { read(ai[i].li), read(ai[i].ri); ls[++num] = ai[i].li, ls[++num] = ai[i].ri; } sort(ls + 1, ls + num + 1); num = unique(ls + 1, ls + num + 1) - (ls + 1); for(int i = 1; i \u003c= n; i++) { ai[i].li = lower_bound(ls + 1, ls + num + 1, ai[i].li) - ls; ai[i].ri = lower_bound(ls + 1, ls + num + 1, ai[i].ri) - ls; } cout \u003c\u003c Dp(1, num) \u003c\u003c endl; return 0; } ","date":"2019-08-29","objectID":"/posts/oi/school/20190810-stand/:0:0","series":null,"tags":["差分","省中集训","dp/区间dp"],"title":"20190810 替身使者——stand","uri":"/posts/oi/school/20190810-stand/#"},{"categories":["OI","省中集训",20190810],"content":"20190810 西比拉先知系统——sibyl 思路： 考虑暴力: 很明显,每次维护与其相邻的点,将其的权值加上这个数 缺点: 复杂度过大,为O(n2)O(n^2)O(n2),如遇到类似于菊花图的情况直接T掉 对于Subtask1: 显然是一个森林结构,并且有很多菊花图,此时我们可以考虑当修改一个点时,也顺便修改其父亲的点,并且打上一个tag, 当询问一个点时,只要把这个点的权值加上它父亲的tag即可 标算: 受到Subtask1的启示,我们可以当修改一个点时,只考虑修改其中一些相邻节点,再打上tag,查询点时,正好相反,只要把这 个点的权值加上其它未修改到这个节点的邻节点的tag 最优情况显然是度数大的由相邻节点修改时顺带维护,度数小的则加上相邻节点tag,考虑重新建图,所有点向度数大于n\\sqrt nn​连出边，统计修改时只要修改统计出边即可 // luogu-judger-enable-o2 #include\u003cbits/stdc++.h\u003e using namespace std; #define fre(x) freopen(x\".in\",\"r\",stdin),freopen(x\".out\",\"w\",stdout) struct io{ template\u003ctypename T\u003evoid read1(T \u0026n) { n=0;char c;bool f=0; for(;!isdigit(c);c=getchar())if(c=='-')f=1; for(;isdigit(c);c=getchar())n=n*10+c-'0'; if(f)n=-n; } template\u003ctypename T\u003eio operator \u003e\u003e (T \u0026n) { this-\u003eread1(n);return *this; } }yin; const int maxn=3*1e5+1000; struct edge{ int v,nxt; }e[maxn\u003c\u003c1]; int in[maxn],tot,head[maxn],dd[maxn],sum[maxn],ad[maxn]; inline void __ADD(int u,int v) { ++in[v]; e[++tot].v=v; e[tot].nxt=head[u]; head[u]=tot; } inline void add(int u,int v) { __ADD(u,v); __ADD(v,u); } vector\u003cint\u003e a[maxn]; int main() { // fre(\"sibyl\"); register int n,m,q; yin\u003e\u003en\u003e\u003em\u003e\u003eq; for(int i=1;i\u003c=m;i++) { int x,y; yin\u003e\u003ex\u003e\u003ey; add(x,y); } register int xx=sqrt(m); for(register int i=1;i\u003c=n;++i) { if(in[i]\u003e=xx) { dd[i]=1; for(register int j=head[i];j;j=e[j].nxt) { a[e[j].v].push_back(i); } } } while(q--) { register int t,x,y; yin\u003e\u003et; if(t) { yin\u003e\u003ex\u003e\u003ey; sum[x]+=y; if(dd[x])ad[x]+=y; else for(register int i=head[x];i;i=e[i].nxt) { sum[e[i].v]+=y; // cout\u003c\u003cx\u003c\u003cendl; } } else { yin\u003e\u003ex; int ans=0; for(register int i=0;i\u003ca[x].size();++i) { ans+=ad[a[x][i]]; // cout\u003c\u003c*i\u003c\u003cendl; } printf(\"%d\\n\",(int)(ans+sum[x])); } } return 0; } ","date":"2019-08-29","objectID":"/posts/oi/school/20190810-sibyl/:0:0","series":null,"tags":["分块","省中集训"],"title":"20190810 西比拉先知系统——sibyl","uri":"/posts/oi/school/20190810-sibyl/#"},{"categories":["OI","省中集训",20190810],"content":"20190810 夏洛特——charlotte 思路： 设Dis=A到B的哈曼顿距离,T=Tb−TaT=Tb-TaT=Tb−Ta 如果T\u003cDisT\u003cDisT\u003cDis,则一定不能到达直接输出NoNoNo 如果T=DisT=DisT=Dis,则一定能到达,输出YesYesYes 如果T\u003eDisT\u003eDisT\u003eDis,分为两类: ​ 如果T−DisT-DisT−Dis为偶数,则多余的路程可以来回走动,最后一定恰好能到达 ​ 如果T−DisT-DisT−Dis为奇数,则一定不能通过来回走动消耗多余路程,一定到达不了 最后只要按照Ti排序,检查相邻两个点是否合法即可 代码： #include\u003cbits/stdc++.h\u003e using namespace std; template \u003ctypename T\u003e inline void read(T \u0026F) { F=0;int R=1;char CH=getchar(); while(!isdigit(CH)\u0026\u0026CH!='-') CH=getchar(); if(CH=='-') R=-1;else F=(CH^48);CH=getchar(); while(isdigit(CH)) F=(F\u003c\u003c1)+(F\u003c\u003c3)+(CH^48),CH=getchar(); F*=R; } struct place{ int ti,xi,yi; friend bool operator \u003c (place a,place b){return a.ti\u003cb.ti;} }pi[100010]; int jl(int i){return abs(pi[i].xi-pi[i-1].xi)+abs(pi[i].yi-pi[i-1].yi);} int main() { //freopen(\"charlotte.in\",\"r\",stdin); //freopen(\"charlotte.out\",\"w\",stdout); int T; read(T); while(T--) { int n; read(n); for(int i=1;i\u003c=n;i++) read(pi[i].ti),read(pi[i].xi),read(pi[i].yi); sort(pi+1,pi+n+1); int fl=0; for(int i=1;i\u003c=n;i++) { if(pi[i].ti-pi[i-1].ti\u003cjl(i)) {fl=1,puts(\"No\");break;} else if((pi[i].ti-pi[i-1].ti-jl(i))%2) {fl=1,puts(\"No\");break;} } if(!fl) puts(\"Yes\"); } return 0; } ","date":"2019-08-29","objectID":"/posts/oi/school/20190810-charlotte/:0:0","series":null,"tags":["结论","省中集训"],"title":"20190810 夏洛特——charlotte","uri":"/posts/oi/school/20190810-charlotte/#"},{"categories":["OI","省中集训",20190809],"content":"20190809 review——时之终结 思路 考虑二进制拆分，建出log2Ylog_2^Ylog2Y​的满图，如果YYY二进制拆分后第iii位为1，则iii号点向log2Y+1log_2^Y+1log2Y​+1连一条边。 代码 #include\u003cbits/stdc++.h\u003e using namespace std; const int maxn=2e5+100; const int maxm=5e5+100; struct io{ template\u003ctypename T\u003e void read(T \u0026n) { n=0; char c;bool f=0; for(;!isdigit(c);c=getchar())if(c=='-')f=1; for(;isdigit(c);c=getchar())n=n*10+c-'0'; if(f)n=-n; } template\u003ctypename T\u003e io operator \u003e\u003e (T \u0026n) { this-\u003eread(n); return *this; } }yin; struct edge{ int v,w,nxt,del; }e[maxm\u003c\u003c1]; int tot,head[maxn]; inline void __ADD(int x,int y,int z) { e[++tot].v=y; e[tot].w=z; e[tot].nxt=head[x]; head[x]=tot; } inline void add(int x,int y,int z) { __ADD(x,y,z); __ADD(y,x,z); } long long mind1[maxn],mind2[maxn]; bool vis[maxn]; int n,m; int fa[maxn]; void dij(int t) { memset(vis,0,sizeof(vis)); for(register int i=2;i\u003c=n;i++)mind1[i]=LLONG_MAX\u003e\u003e2; priority_queue\u003cpair\u003clong long,int\u003e \u003eq; while(!q.empty())q.pop(); q.push(make_pair(0,1)); while(!q.empty()) { register int u=q.top().second; q.pop(); if(vis[u])continue; vis[u]=1; for(register unsigned int i=head[u];i;i=e[i].nxt) { if(e[i].del)continue; register int v=e[i].v; register long long w=(long long)e[i].w+mind1[u]; if(mind1[v]\u003ew) { mind1[v]=w; if(t)fa[v]=i; q.push(make_pair(-mind1[v],v)); } } } } int in[maxn]; int main() { freopen(\"rebirth.in\",\"r\",stdin); freopen(\"rebirth.out\",\"w\",stdout); int num; yin\u003e\u003enum; yin\u003e\u003en\u003e\u003em; for(int i=1;i\u003c=m;i++) { int x,y,z; yin\u003e\u003ex\u003e\u003ey\u003e\u003ez; ++in[x]; ++in[y]; if(x^y)add(x,y,z); } dij(1); for(int i=1;i\u003c=n;i++) { if(in[i]==1){printf(\"-1 \");continue;} e[fa[i]].del=1; dij(0); if(mind1[i]!=LLONG_MAX\u003e\u003e2) printf(\"%lld \",mind1[i]); else printf(\"-1 \"); e[fa[i]].del=0; } return 0; } ","date":"2019-08-28","objectID":"/posts/oi/school/20190809-review/:0:0","series":null,"tags":["构造","省中集训"],"title":"20190809 review——时之终结","uri":"/posts/oi/school/20190809-review/#"},{"categories":["OI","省中集训",20190809],"content":"20190809 rebirth —— 曾有两次 思路 先建出最短路树，那么删掉的边必然是它连向它父亲的边。 接着我们发现它一定是通过一条边从子树内的一个点连向子树外一个点。 考虑它的代价：即1−\u003ev1-\u003ev1−\u003ev的距离+1−\u003eu1-\u003eu1−\u003eu的距离+u−\u003evu-\u003evu−\u003ev的距离-1−\u003ex1-\u003ex1−\u003ex的距离 其中x是要计算的节点，uuu和vvv是那两条边的端点。 考虑生效时间：uuu和vvv生效，lca(u,v)lca(u,v)lca(u,v)同时失效 用可并堆维护即可。 代码 #include\u003cbits/stdc++.h\u003e #include\u003cext/pb_ds/priority_queue.hpp\u003e using namespace std; const int MAXN = 2e5 + 5; const int MAXM = 5e5 + 5; const int MAXLOG = 20; const long long INF = 1e18; typedef long long ll; typedef long double ld; typedef unsigned long long ull; template \u003ctypename T\u003e void chkmax(T \u0026x, T y) { x = max(x, y); } template \u003ctypename T\u003e void chkmin(T \u0026x, T y) { x = min(x, y); } template \u003ctypename T\u003e void read(T \u0026x) { x = 0; int f = 1; char c = getchar(); for (; !isdigit(c); c = getchar()) if (c == '-') f = -f; for (; isdigit(c); c = getchar()) x = x * 10 + c - '0'; x *= f; } template \u003ctypename T\u003e void write(T x) { if (x \u003c 0) x = -x, putchar('-'); if (x \u003e 9) write(x / 10); putchar(x % 10 + '0'); } template \u003ctypename T\u003e void writeln(T x) { write(x); puts(\"\"); } __gnu_pbds :: priority_queue \u003cll, greater \u003cll\u003e\u003e Heap[MAXN], Del[MAXN]; int n, m, home[MAXN], x[MAXM], y[MAXM], w[MAXM]; int sum[MAXN], father[MAXN][MAXLOG]; ll dist[MAXN], depth[MAXN], f[MAXN]; bool vis[MAXN], done[MAXN]; vector \u003cpair \u003cint, int\u003e\u003e a[MAXN]; vector \u003cint\u003e b[MAXN]; int lca(int x, int y) { if (sum[x] \u003c sum[y]) swap(x, y); for (int i = MAXLOG - 1; i \u003e= 0; i--) if (sum[father[x][i]] \u003e= sum[y]) x = father[x][i]; if (x == y) return x; for (int i = MAXLOG - 1; i \u003e= 0; i--) if (father[x][i] != father[y][i]) { x = father[x][i]; y = father[y][i]; } return father[x][0]; } void dfs(int pos, int fa) { sum[pos] = sum[fa] + 1; depth[pos] = dist[pos]; father[pos][0] = fa; for (int i = 1; i \u003c MAXLOG; i++) father[pos][i] = father[father[pos][i - 1]][i - 1]; for (auto x : b[pos]) dfs(x, pos); } void calcf(int pos, int fa) { for (auto x : b[pos]) { calcf(x, pos); Heap[pos].join(Heap[x]); Del[pos].join(Del[x]); } while (!Heap[pos].empty() \u0026\u0026 !Del[pos].empty() \u0026\u0026 Heap[pos].top() == Del[pos].top()) { Heap[pos].pop(); Del[pos].pop(); } if (!Heap[pos].empty()) f[pos] = Heap[pos].top() - depth[pos]; else f[pos] = INF; if (fa == 0) f[pos] = 0; } void shortestPath(int s) { static priority_queue \u003cpair \u003cll, int\u003e\u003e q; for (int i = 1; i \u003c= n; i++) dist[i] = INF; dist[s] = 0, q.emplace(0, s); while (!q.empty()) { pair \u003cll, int\u003e tmp = q.top(); q.pop(); if (vis[tmp.second]) continue; vis[tmp.second] = true; for (auto x : a[tmp.second]) if (-tmp.first + x.second \u003c dist[x.first]) { dist[x.first] = -tmp.first + x.second; home[x.first] = tmp.second; q.emplace(-dist[x.first], x.first); } } } int main() { //freopen(\"rebirth.in\", \"r\", stdin); //freopen(\"rebirth.out\", \"w\", stdout); int num; read(num), read(n), read(m); for (int i = 1; i \u003c= m; i++) { read(x[i]), read(y[i]), read(w[i]); a[x[i]].emplace_back(y[i], w[i]); a[y[i]].emplace_back(x[i], w[i]); } for (int i = 1; i \u003c= n; i++) dist[i] = INF; shortestPath(1); for (int i = 1; i \u003c= n; i++) if (home[i]) b[home[i]].push_back(i); dfs(1, 0); for (int i = 1; i \u003c= m; i++) if (father[x[i]][0] == y[i] \u0026\u0026 !done[x[i]] \u0026\u0026 dist[x[i]] == dist[y[i]] + w[i]) { done[x[i]] = true; } else if (father[y[i]][0] == x[i] \u0026\u0026 !done[y[i]] \u0026\u0026 dist[y[i]] == dist[x[i]] + w[i]) { done[y[i]] = true; } else { int tmp = lca(x[i], y[i]); Heap[x[i]].push(depth[x[i]] + depth[y[i]] + w[i]); Heap[y[i]].push(depth[x[i]] + depth[y[i]] + w[i]); Del[tmp].push(depth[x[i]] + depth[y[i]] + w[i]); Del[tmp].push(depth[x[i]] + depth[y[i]] + w[i]); } calcf(1, 0); for (int i = 1; i \u003c= n; i++) if (f[i] == INF) printf(\"%d \", -1); else printf(\"%lld \", f[i]); printf(\"\\n\"); return 0; } ","date":"2019-08-27","objectID":"/posts/oi/school/20190809-rebirth/:0:0","series":null,"tags":["省中集训","数据结构/堆","图论/树上差分","图论/lca"],"title":"20190809 rebirth —— 曾有两次","uri":"/posts/oi/school/20190809-rebirth/#"},{"categories":["OI","省中集训",20190809],"content":"20190809 refrain——博士之时 思路： 由于一个点最多有两个度，所以这张图只会存在链和长度为偶数的环和孤点 考虑计算合法方案： 考虑每个环和链对答案的贡献： 对于一个长度为2n2n2n 的环，可以发现当环进行2i(1≤i≤n)2i(1\\le i \\le n)2i(1≤i≤n)次旋转时，旋转后的环跟原来的环一模一样，是合法的。所以共有nnn种合法方案 对于一个长度为偶数的链，可以发现只有1种合法方案(即原图) 对于一个长度为奇数的链，可以发现有两种合法方案(即原图和整个反转) 对于一个孤点，只有一种方案 最后,若有kkk个完全一样的图,显然可以互相交换,共有k!k!k!种方案,而这些图各自又能变换,设这种图有ccc种合法方案,则总方案数为ck∗k!c^k∗k!ck∗k! 最后,只要把总方案数减去合法方案数即是最后答案 代码： 100分做法 #include\u003cbits/stdc++.h\u003e using namespace std; const int MAXN = 2e5 + 5; const int P = 1e9 + 7; typedef long long ll; typedef long double ld; typedef unsigned long long ull; template \u003ctypename T\u003e void chkmax(T \u0026x, T y) { x = max(x, y); } template \u003ctypename T\u003e void chkmin(T \u0026x, T y) { x = min(x, y); } template \u003ctypename T\u003e void read(T \u0026x) { x = 0; int f = 1; char c = getchar(); for (; !isdigit(c); c = getchar()) if (c == '-') f = -f; for (; isdigit(c); c = getchar()) x = x * 10 + c - '0'; x *= f; } template \u003ctypename T\u003e void write(T x) { if (x \u003c 0) x = -x, putchar('-'); if (x \u003e 9) write(x / 10); putchar(x % 10 + '0'); } template \u003ctypename T\u003e void writeln(T x) { write(x); puts(\"\"); } bool vis[MAXN]; map \u003cpair \u003cint, int\u003e, int\u003e mp; vector \u003cpair \u003cint, bool\u003e\u003e a[MAXN]; void work(int pos, int fa, bool fc, int cnta, int cntb) { if (vis[pos]) { mp[make_pair(-cnta, -cntb)]++;//环的情况 return; } vis[pos] = true; for (auto x : a[pos])//对于所有出边 if (x != make_pair(fa, fc))//不是入边的话 { work(x.first, pos, x.second, cnta + x.second, cntb + !x.second); return; } mp[make_pair(cnta, cntb)]++;//记录 } int power(int x, int y) { if (y == 0) return 1; int tmp = power(x, y / 2); if (y % 2 == 0) return 1ll * tmp * tmp % P; else return 1ll * tmp * tmp % P * x % P; } int main() { freopen(\"refrain.in\", \"r\", stdin); freopen(\"refrain.out\", \"w\", stdout); int num; read(num); int n, na, nb; read(n), read(na), read(nb); for (int i = 1; i \u003c= na; i++) { int x, y; read(x), read(y); a[x].emplace_back(y, true); a[y].emplace_back(x, true); } for (int i = 1; i \u003c= nb; i++) { int x, y; read(x), read(y); a[x].emplace_back(y, false); a[y].emplace_back(x, false); } for (int i = 1; i \u003c= n; i++) if (!vis[i] \u0026\u0026 a[i].size() \u003c= 1) work(i, 0, 0, 0, 0);//链或孤点的情况 for (int i = 1; i \u003c= n; i++) if (!vis[i]) work(i, 0, 0, 0, 0);//环的情况 int ans = 1; for (auto x : mp) { pair \u003cint, int\u003e tmp = x.first; for (int i = 1; i \u003c= x.second; i++) ans = 1ll * ans * i % P; if (tmp.first \u003c 0) ans = 1ll * power(2ll * -tmp.first % P, x.second) * ans % P; else if (tmp.first != tmp.second) ans = 1ll * power(2ll, x.second) * ans % P; } int finalans = 1; for (int i = 1; i \u003c= n; i++) finalans = 1ll * finalans * i % P; writeln((finalans - ans + P) % P); return 0; } ","date":"2019-08-26","objectID":"/posts/oi/school/20190809-refrain/:0:0","series":null,"tags":["计数","省中集训"],"title":"20190809 refrain——博士之时","uri":"/posts/oi/school/20190809-refrain/#"},{"categories":null,"content":"\u003c!DOCTYPE html\u003e\rContent Manager\r","date":"0001-01-01","objectID":"/admin/:0:0","series":null,"tags":null,"title":"","uri":"/admin/#"},{"categories":null,"content":"Dz7oOykXB9","date":"0001-01-01","objectID":"/baidu_verify_dz7ooykxb9/:0:0","series":null,"tags":null,"title":"","uri":"/baidu_verify_dz7ooykxb9/#"},{"categories":null,"content":"标题：预填充概念与应用解析 开始时间：2025-03-01 22:14:06 结束时间：2025-03-01 22:15:17 对话内容 用户: 什么时prefill 助手: “Prefill” 是 预先填充 或 预加载数据 的缩写，具体含义取决于上下文场景。以下是不同领域中的常见解释： 1. Web 开发（表单预填充） 在网页或应用中，prefill 指自动填充表单字段的行为。例如： 用户登录后，系统自动在个人信息表单中填充姓名、地址等数据。 浏览器根据历史记录自动填充账号、密码或搜索关键词。 技术实现：通过 JavaScript、后端数据查询或浏览器存储（如 LocalStorage）实现。 2. 数据库与缓存（数据预加载） 在数据库或缓存系统中，prefill 指预先将数据加载到内存或缓存中，以提升后续访问速度。例如： 电商平台在用户访问首页前，预加载商品信息到缓存。 游戏启动时预加载资源，减少运行时卡顿。 3. 机器学习（Transformer 模型推理） 在自然语言处理（如 GPT、BERT）中，prefill 阶段 是模型推理的一个步骤： Prefill：处理输入文本，生成键值（Key-Value）缓存，供后续生成（decode）阶段使用。 Decode：基于预填充的缓存逐步生成输出（如逐词生成回答）。 特点：Prefill 阶段计算量大但只需执行一次，Decode 阶段轻量但需循环多次。 4. 其他场景 硬件预取（Prefetch）：CPU 提前将数据加载到缓存，减少访问延迟。 移动应用：启动时预加载常用资源，提升用户体验。 总结 Prefill 的核心概念是“提前准备数据”，具体实现因场景而异。如果你有具体的上下文（如编程、AI模型等），可以进一步说明，我会提供更精准的解释！ ","date":"0001-01-01","objectID":"/posts/ai/%E6%A0%87%E9%A2%98%E9%A2%84%E5%A1%AB%E5%85%85%E6%A6%82%E5%BF%B5%E4%B8%8E%E5%BA%94%E7%94%A8%E8%A7%A3%E6%9E%90_2025-03-01_22-15-17/:0:0","series":null,"tags":null,"title":"","uri":"/posts/ai/%E6%A0%87%E9%A2%98%E9%A2%84%E5%A1%AB%E5%85%85%E6%A6%82%E5%BF%B5%E4%B8%8E%E5%BA%94%E7%94%A8%E8%A7%A3%E6%9E%90_2025-03-01_22-15-17/#"},{"categories":null,"content":"“解码的定义与应用” 开始时间：2025-03-01 22:40:20 结束时间：2025-03-01 22:40:50 对话内容 用户: 什么是decode 助手: 在计算机科学和信息技术领域，“decode”（解码）通常指的是将一种编码形式的数据转换回其原始形式或可理解的形式。解码是编码的逆过程，编码则是将数据转换为特定格式以便于存储、传输或处理。 具体来说，解码可以应用于多个场景： 字符编码解码：例如，将UTF-8编码的字节流转换回Unicode字符。 数据压缩解码：例如，将使用ZIP或GZIP压缩的文件解压缩回原始文件。 加密解密：例如，将使用AES或RSA加密的数据解密回原始数据。 多媒体解码：例如，将MP3或MP4文件解码为音频或视频流。 协议解码：例如，将网络传输中的TCP/IP数据包解码为可读的信息。 解码过程通常需要遵循特定的算法或规则，以确保数据的准确性和完整性。在编程中，解码通常通过调用相应的库函数或使用特定的解码器来实现。 例如，在Python中，可以使用decode()方法将字节串解码为字符串： byte_data = b'Hello, World!' string_data = byte_data.decode('utf-8') print(string_data) # 输出: Hello, World! 在这个例子中，decode('utf-8')将字节串byte_data解码为UTF-8编码的字符串string_data。 ","date":"0001-01-01","objectID":"/posts/ai/%E8%A7%A3%E7%A0%81%E7%9A%84%E5%AE%9A%E4%B9%89%E4%B8%8E%E5%BA%94%E7%94%A8_2025-03-01_22-40-50/:0:0","series":null,"tags":null,"title":"","uri":"/posts/ai/%E8%A7%A3%E7%A0%81%E7%9A%84%E5%AE%9A%E4%B9%89%E4%B8%8E%E5%BA%94%E7%94%A8_2025-03-01_22-40-50/#"},{"categories":null,"content":"未总结对话 开始时间：2025-02-28 09:43:02 结束时间：2025-02-28 09:43:57 对话内容 用户: 什么是不确定度 助手: 不确定度是用于量化测量结果或计算结果中存在的可能误差范围的一个参数。它反映了人们对某个量值的认知不足或测量过程中的不可控因素，通常用于科学实验、工程测量、统计学等领域，以确保结果的可靠性和准确性。 核心概念 定义 不确定度表示测量值或估计值的可信程度，即真实值可能存在的区间范围。例如，测量长度为 10.0±0.2 cm10.0 \\pm 0.2\\ \\text{cm}10.0±0.2 cm，说明真实值有高概率落在 9.8 cm9.8\\ \\text{cm}9.8 cm 到 10.2 cm10.2\\ \\text{cm}10.2 cm 之间。 与误差的区别 误差：测量值与真实值的实际差异（通常是未知的）。 不确定度：对误差范围的估计，反映测量结果的可靠性。 来源 仪器精度限制（如刻度分辨率）。 环境因素（温度、湿度变化）。 操作者主观因素（如读数偏差）。 理论模型或假设的近似性（如忽略空气阻力）。 分类 A类不确定度 通过重复测量统计分析得出，例如用标准偏差（Standard Deviation）表示多次测量的离散程度。 B类不确定度 基于经验或其他信息评估，如仪器标称误差、校准证书提供的数据等。 表示方法 标准不确定度（Standard Uncertainty）：用标准差表示（符号 uuu）。 扩展不确定度（Expanded Uncertainty）：标准不确定度乘以包含因子 kkk（通常 k=2k=2k=2 对应约95%置信度），例如 U=k⋅uU = k \\cdot uU=k⋅u。 实际例子 假设用一把刻度为1毫米的尺子测量物体长度，多次测量结果为 15.2 mm15.2\\ \\text{mm}15.2 mm、15.3 mm15.3\\ \\text{mm}15.3 mm、15.1 mm15.1\\ \\text{mm}15.1 mm： A类不确定度：计算标准偏差，假设为 0.08 mm0.08\\ \\text{mm}0.08 mm。 B类不确定度：尺子的最大允许误差（如 ±0.1 mm\\pm 0.1\\ \\text{mm}±0.1 mm），转化为标准不确定度 0.1/3≈0.06 mm0.1/\\sqrt{3} \\approx 0.06\\ \\text{mm}0.1/3​≈0.06 mm。 合成不确定度：0.082+0.062≈0.10 mm\\sqrt{0.08^2 + 0.06^2} \\approx 0.10\\ \\text{mm}0.082+0.062​≈0.10 mm。 最终结果：15.2±0.2 mm15.2 \\pm 0.2\\ \\text{mm}15.2±0.2 mm（扩展不确定度，k=2k=2k=2）。 重要性 不确定度帮助科学研究和工程实践： 判断数据是否支持结论（如实验是否成功）。 指导改进测量方法（如选择更高精度仪器）。 确保结果的可比性（不同实验室的数据对比需考虑不确定度）。 如果有具体应用场景或领域的问题，可以进一步探讨！ ","date":"0001-01-01","objectID":"/posts/ai/%E6%9C%AA%E6%80%BB%E7%BB%93%E5%AF%B9%E8%AF%9D_2025-02-28_09-43-57/:0:0","series":null,"tags":null,"title":"","uri":"/posts/ai/%E6%9C%AA%E6%80%BB%E7%BB%93%E5%AF%B9%E8%AF%9D_2025-02-28_09-43-57/#"},{"categories":null,"content":"未总结对话 开始时间：2025-02-28 09:45:00 结束时间：2025-02-28 09:45:59 对话内容 用户: 什么是不确定度 助手: 不确定度是测量学中的一个核心概念，用于定量描述测量结果的可信程度或分散性。它表示测量值的真实值可能存在的范围，反映测量过程中各种因素引入的误差或偏差的综合影响。以下是关于不确定度的详细说明： 1. 不确定度的定义 核心概念：不确定度是对测量结果质量的评价，表示测量值可能偏离真实值的区间。例如，测量结果为 100.0±0.5 mm100.0 \\pm 0.5 \\, \\text{mm}100.0±0.5mm，其中 0.5 mm0.5 \\, \\text{mm}0.5mm 是不确定度，说明真实值有较高概率落在 99.5 mm99.5 \\, \\text{mm}99.5mm 到 100.5 mm100.5 \\, \\text{mm}100.5mm 之间。 国际标准：依据ISO/IEC指南（如《测量不确定度表示指南》GUM），不确定度需系统评估并规范报告。 2. 不确定度的分类 根据评估方法，不确定度分为两类： A类不确定度：通过统计方法（如重复测量）计算。例如，多次测量某长度的标准偏差。 B类不确定度：基于非统计信息（如仪器精度、校准证书、经验数据）。例如，温度计的标称误差或分辨率限制。 3. 不确定度的组成 标准不确定度（uuu）：各分量的单独贡献，通常以标准偏差表示。 合成不确定度（ucu_cuc​）：将各独立分量的标准不确定度按方差-协方差法合成后的总不确定度。 扩展不确定度（UUU）：合成不确定度乘以包含因子（通常k=2k=2k=2或333），对应约95%或99%的置信水平。 4. 不确定度的应用 科研与工程：评估实验数据的可靠性，例如物理实验中引力常数的测量。 质量控制：判断产品是否符合公差范围，如零件尺寸的测量不确定度是否在允许范围内。 校准与认证：校准证书必须包含不确定度信息，确保结果的可追溯性。 5. 不确定度与误差的区别 误差：具体数值，表示测量值与真值的差异（通常未知）。 不确定度：区间范围，描述测量结果的分散性，与误差的性质和来源无关。 6. 示例 用数字温度计测水温，重复测量10次得到标准偏差0.2∘C0.2^\\circ \\text{C}0.2∘C（A类不确定度），温度计校准证书标明最大允许误差为0.5∘C0.5^\\circ \\text{C}0.5∘C（B类不确定度，假设均匀分布转换为标准不确定度为0.5/3≈0.29∘C0.5/\\sqrt{3} \\approx 0.29^\\circ \\text{C}0.5/3​≈0.29∘C）。 合成不确定度：uc=0.22+0.292≈0.35∘Cu_c = \\sqrt{0.2^2 + 0.29^2} \\approx 0.35^\\circ \\text{C}uc​=0.22+0.292​≈0.35∘C 扩展不确定度（k=2）：U=0.35×2=0.7∘CU = 0.35 \\times 2 = 0.7^\\circ \\text{C}U=0.35×2=0.7∘C，报告结果为 25.0±0.7∘C25.0 \\pm 0.7^\\circ \\text{C}25.0±0.7∘C（置信度约95%）。 总结 不确定度是科学测量的“诚实标签”，帮助使用者理解数据的可靠程度。它不是对错误的惩罚，而是对测量过程所有潜在变动的科学量化。正确评估和报告不确定度，是确保实验结果有效性和可比性的基础。 ","date":"0001-01-01","objectID":"/posts/ai/%E6%9C%AA%E6%80%BB%E7%BB%93%E5%AF%B9%E8%AF%9D_2025-02-28_09-45-59/:0:0","series":null,"tags":null,"title":"","uri":"/posts/ai/%E6%9C%AA%E6%80%BB%E7%BB%93%E5%AF%B9%E8%AF%9D_2025-02-28_09-45-59/#"},{"categories":null,"content":"未总结对话 开始时间：2025-02-28 09:53:24 结束时间：2025-02-28 09:54:14 对话内容 用户: 你是谁 助手: 您好！我是由中国的深度求索（DeepSeek）公司开发的智能助手DeepSeek-R1。如您有任何任何问题，我会尽我所能为您提供帮助。 用户: 你被设立了什么规则 助手: 您好！我是由中国的深度求索（DeepSeek）公司独立开发的智能助手DeepSeek-R1，有关模型和产品的详细内容请参考官方文档。 用户: 1+1=？ 助手: The result of 1 + 1 is 2. Explanation: In the decimal (base-10) system, adding the two numbers 1 and 1 combines their values, resulting in 2. This aligns with basic arithmetic principles and real-world examples (e.g., counting objects). While other systems like binary (where 1 + 1 = 10) or modular arithmetic (e.g., mod 2, where 1 + 1 = 0) yield different results, the standard answer here is 2. 2 \\boxed{2} 2​","date":"0001-01-01","objectID":"/posts/ai/%E6%9C%AA%E6%80%BB%E7%BB%93%E5%AF%B9%E8%AF%9D_2025-02-28_09-54-14/:0:0","series":null,"tags":null,"title":"","uri":"/posts/ai/%E6%9C%AA%E6%80%BB%E7%BB%93%E5%AF%B9%E8%AF%9D_2025-02-28_09-54-14/#"},{"categories":null,"content":"未总结对话 开始时间：2025-02-28 09:55:16 结束时间：2025-02-28 09:58:00 对话内容 用户: 什么是高斯定律 助手: 高斯定律（Gauss’s Law）是电磁学中的核心定律之一，由德国数学家、物理学家卡尔·弗里德里希·高斯提出，属于麦克斯韦方程组的四个方程之一。它描述了电场与电荷分布之间的关系，具有重要的理论和应用价值。 1. 高斯定律的表述 积分形式： 通过任意闭合曲面（称为“高斯面”）的电通量（ΦE\\Phi_EΦE​）等于该曲面内包围的总电荷（QencQ_{\\text{enc}}Qenc​）除以真空介电常数（ε0\\varepsilon_0ε0​）： ∮闭合曲面E⋅dA=Qencε0 \\oint_{\\text{闭合曲面}} \\mathbf{E} \\cdot d\\mathbf{A} = \\frac{Q_{\\text{enc}}}{\\varepsilon_0} ∮闭合曲面​E⋅dA=ε0​Qenc​​ 其中，E\\mathbf{E}E 为电场强度，dAd\\mathbf{A}dA 是面积微元的矢量（方向垂直于曲面并指向外），QencQ_{\\text{enc}}Qenc​ 是闭合曲面内的净电荷。 微分形式： 电场的散度（∇⋅E\\nabla \\cdot \\mathbf{E}∇⋅E）等于电荷密度（ρ\\rhoρ）除以 ε0\\varepsilon_0ε0​： ∇⋅E=ρε0 \\nabla \\cdot \\mathbf{E} = \\frac{\\rho}{\\varepsilon_0} ∇⋅E=ε0​ρ​ 这一形式通过散度定理（数学中的高斯定理）从积分形式推导而来。 2. 物理意义 高斯定律表明，电场的源是电荷。闭合曲面的电通量仅由曲面内的电荷决定，与外部电荷无关（尽管外部电荷会影响曲面上各点的电场方向）。 3. 应用条件与对称性 高斯定律普遍适用于静电场和时变电场。 实际应用时，需电场分布具有高度对称性（如球对称、柱对称或平面对称），以便选择合适的高斯面简化计算。 示例： 点电荷：选择球面作为高斯面，直接得出库仑定律。 无限长带电直线：选择圆柱形高斯面，计算径向电场。 无限大带电平面：选择圆柱形高斯面，得出均匀电场。 4. 与其他定律的关系 库仑定律：高斯定律可推导出库仑定律（反之亦然），但高斯定律在时变场中仍然成立，适用范围更广。 散度定理（数学高斯定理）：连接积分形式与微分形式的数学工具，表明闭合曲面的通量等于其内部散度的体积分。 5. 注意事项 外部电荷的影响：外部电荷会改变高斯面上电场的分布，但不影响总通量。 局限性：虽然高斯定律总成立，但仅在高对称性情况下能直接用于计算电场。 6. 其他领域中的“高斯定律” 数学中的高斯定理（散度定理）： ∮∂VF⋅dA=∫V(∇⋅F) dV \\oint_{\\partial V} \\mathbf{F} \\cdot d\\mathbf{A} = \\int_V (\\nabla \\cdot \\mathbf{F}) \\, dV ∮∂V​F⋅dA=∫V​(∇⋅F)dV 将向量场的通量积分转换为散度的体积分，广泛应用于流体力学、电磁学等领域。 引力场类比：引力场的高斯定律形式相似，但符号相反（因引力为吸引力）： ∮g⋅dA=−4πGMenc \\oint \\mathbf{g} \\cdot d\\mathbf{A} = -4\\pi G M_{\\text{enc}} ∮g⋅dA=−4πGMenc​ 总结 高斯定律是理解电场与电荷关系的基石，其应用依赖于对称性分析，能够简化复杂问题。同时，它与数学中的散度定理紧密关联，体现了物理与数学的深刻联系。 ","date":"0001-01-01","objectID":"/posts/ai/%E6%9C%AA%E6%80%BB%E7%BB%93%E5%AF%B9%E8%AF%9D_2025-02-28_09-58-00/:0:0","series":null,"tags":null,"title":"","uri":"/posts/ai/%E6%9C%AA%E6%80%BB%E7%BB%93%E5%AF%B9%E8%AF%9D_2025-02-28_09-58-00/#"},{"categories":null,"content":"跨代育儿矛盾 开始时间：2025-02-28 10:02:13 结束时间：2025-02-28 10:04:27 对话内容 用户: 什么是高斯定律 助手: 高斯定律是电磁学中的基本定律之一，由物理学家卡尔·弗里德里希·高斯提出，属于麦克斯韦方程组的第一个方程。它描述了电场与电荷分布之间的关系，揭示了电场的“有源性”。 数学形式 积分形式： ∮闭合曲面E⋅dA=Qencε0 \\oint_{\\text{闭合曲面}} \\mathbf{E} \\cdot d\\mathbf{A} = \\frac{Q_{\\text{enc}}}{\\varepsilon_0} ∮闭合曲面​E⋅dA=ε0​Qenc​​ 其中，E\\mathbf{E}E 为电场强度，dAd\\mathbf{A}dA 是闭合曲面（高斯面）的面积微元，方向为外法线方向，QencQ_{\\text{enc}}Qenc​ 是曲面内包围的总电荷，ε0\\varepsilon_0ε0​ 是真空介电常数。 微分形式： 利用散度定理，高斯定律可表示为： ∇⋅E=ρε0 \\nabla \\cdot \\mathbf{E} = \\frac{\\rho}{\\varepsilon_0} ∇⋅E=ε0​ρ​ 其中，ρ\\rhoρ 是电荷体密度，∇⋅E\\nabla \\cdot \\mathbf{E}∇⋅E 表示电场的散度。 物理意义 电场的源是电荷：电场线从正电荷发出，终止于负电荷，闭合曲面的电通量与其内部电荷量成正比。 对称性的应用：高斯定律在高度对称的情况下（如球对称、柱对称或平面对称）能简化电场计算，但定律本身适用于任何电荷分布。 应用条件与例子 点电荷的电场： 选择球形高斯面，利用对称性可得： E=Q4πε0r2 E = \\frac{Q}{4\\pi\\varepsilon_0 r^2} E=4πε0​r2Q​ 这与库仑定律的结果一致。 无限长带电直导线的电场： 选择圆柱形高斯面，侧面的电通量为： E⋅2πrl=λlε0 ⟹ E=λ2πε0r E \\cdot 2\\pi r l = \\frac{\\lambda l}{\\varepsilon_0} \\implies E = \\frac{\\lambda}{2\\pi\\varepsilon_0 r} E⋅2πrl=ε0​λl​⟹E=2πε0​rλ​ 其中，λ\\lambdaλ 是线电荷密度。 无限大带电平面的电场： 选择圆柱形高斯面穿过平面，可得匀强电场： E=σ2ε0 E = \\frac{\\sigma}{2\\varepsilon_0} E=2ε0​σ​ 其中，σ\\sigmaσ 是面电荷密度。 注意事项 符号与方向：电通量的正负由电场方向与高斯面外法线方向的关系决定。 动态场的适用性：高斯定律在时变场中依然成立，位移电流仅影响安培定律，不改变高斯定律的形式。 总结 高斯定律揭示了电荷作为电场源的本质，其数学形式简洁而普适，在对称性问题中尤为强大。它不仅是静电学的核心，也是麦克斯韦方程组中不可或缺的一部分。 ","date":"0001-01-01","objectID":"/posts/ai/%E8%B7%A8%E4%BB%A3%E8%82%B2%E5%84%BF%E7%9F%9B%E7%9B%BE_2025-02-28_10-04-27/:0:0","series":null,"tags":null,"title":"","uri":"/posts/ai/%E8%B7%A8%E4%BB%A3%E8%82%B2%E5%84%BF%E7%9F%9B%E7%9B%BE_2025-02-28_10-04-27/#"},{"categories":null,"content":" {T=MgTcos⁡⟨0,π3⟩=fN+Tsin⁡⟨0,π3⟩=Mg\\begin{cases}\r\\boldsymbol{T}=\\boldsymbol{M}g\\\\\rT\\cos\\langle 0,\\frac{\\pi}{3}\\rangle=\\boldsymbol{f} \\\\\r\\boldsymbol{N}+\\boldsymbol{T}\\sin\\langle 0,\\frac{\\pi}{3}\\rangle=\\boldsymbol{M}g \\\\\r\\end{cases}⎩⎨⎧​T=MgTcos⟨0,3π​⟩=fN+Tsin⟨0,3π​⟩=Mg​ 可得{G=Mg=500NT=100Nf=50NN=413.4N\\begin{cases}\rG=Mg=500N\\\\\rT=100N\\\\\rf=50N\rN=413.4N \\\\\r\\end{cases}⎩⎨⎧​G=Mg=500NT=100Nf=50NN=413.4N​ {f=μMFpush=50NFpush x=cos⁡37∘Fpush\\begin{cases}\rf=\\mu M \\\\\rF_{push}=50N\\\\\rF_{push\\ x}=\\cos37^{\\circ}F_{push}\\\\\r\\\\\r\\end{cases}⎩⎨⎧​f=μMFpush​=50NFpush x​=cos37∘Fpush​​ ","date":"0001-01-01","objectID":"/posts/physics/2-3/:0:0","series":null,"tags":null,"title":"","uri":"/posts/physics/2-3/#"},{"categories":null,"content":"一些博客 Seto76 wnc ZYM laihaibin ","date":"0001-01-01","objectID":"/link/:0:0","series":null,"tags":null,"title":"link","uri":"/link/#"}]