<!doctype html><html itemscope itemtype=http://schema.org/WebPage lang=zh-CN><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=2"><meta name=robots content="noodp"><title>Chapter3 - MoonWonder</title><meta name=author content="MoonWonder"><meta name=description content="第 3 章 深入 JavaScript：搞定闭包、原型与 this 本章我们聚焦 JavaScript 的核心概念和一些 “奇妙” 特性，包括闭包、this 和原型继承。这些概念经常令初学者困惑，但对于有工程经验的你来说，只需一点类比就能豁然开朗。
"><meta name=keywords content='AI,Computer Science,Math'><meta itemprop=name content="Chapter3"><meta itemprop=description content="第 3 章 深入 JavaScript：搞定闭包、原型与 this 本章我们聚焦 JavaScript 的核心概念和一些 “奇妙” 特性，包括闭包、this 和原型继承。这些概念经常令初学者困惑，但对于有工程经验的你来说，只需一点类比就能豁然开朗。"><meta itemprop=datePublished content="2025-10-26T21:32:27+08:00"><meta itemprop=dateModified content="2025-10-28T09:28:15+08:00"><meta itemprop=wordCount content="2607"><meta itemprop=image content="https://moonwonder.top/logo.png"><meta property="og:url" content="https://moonwonder.top/books/javascript/part1/chapter3/"><meta property="og:site_name" content="MoonWonder"><meta property="og:title" content="Chapter3"><meta property="og:description" content="第 3 章 深入 JavaScript：搞定闭包、原型与 this 本章我们聚焦 JavaScript 的核心概念和一些 “奇妙” 特性，包括闭包、this 和原型继承。这些概念经常令初学者困惑，但对于有工程经验的你来说，只需一点类比就能豁然开朗。"><meta property="og:locale" content="zh_CN"><meta property="og:type" content="article"><meta property="article:section" content="books"><meta property="article:published_time" content="2025-10-26T21:32:27+08:00"><meta property="article:modified_time" content="2025-10-28T09:28:15+08:00"><meta property="og:image" content="https://moonwonder.top/logo.png"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://moonwonder.top/logo.png"><meta name=twitter:title content="Chapter3"><meta name=twitter:description content="第 3 章 深入 JavaScript：搞定闭包、原型与 this 本章我们聚焦 JavaScript 的核心概念和一些 “奇妙” 特性，包括闭包、this 和原型继承。这些概念经常令初学者困惑，但对于有工程经验的你来说，只需一点类比就能豁然开朗。"><meta name=application-name content="MoonWonder"><meta name=apple-mobile-web-app-title content="MoonWonder"><meta name=theme-color data-light=#f8f8f8 data-dark=#252627 content="#f8f8f8"><meta name=msapplication-TileColor content="#da532c"><link rel="shortcut icon" type=image/x-icon href=/favicon.ico><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><link rel=manifest href=/site.webmanifest><link rel=canonical type=text/html href=https://moonwonder.top/books/javascript/part1/chapter3/ title="Chapter3 - MoonWonder"><link rel=prev type=text/html href=https://moonwonder.top/books/javascript/part1/chapter2/ title=Chapter2><link rel=alternate type=text/plain href=https://moonwonder.top/books/javascript/part1/chapter3/index.md title="Chapter3 - MoonWonder"><link rel=stylesheet href=/css/config.min.251880c471e90abe5f3e03b6b6ff7ebf.css integrity="md5-JRiAxHHpCr5fPgO2tv9+vw=="><link rel=stylesheet href=/css/style.min.c3fbd99ca3a9e2cb28f2cffa1a3a4541.css integrity="md5-w/vZnKOp4sso8s/6GjpFQQ=="><link rel=preload href=/lib/fontawesome-free/all.min.bde2a1ac06ec87a30967e54da50f5c15.css integrity="md5-veKhrAbsh6MJZ+VNpQ9cFQ==" as=style onload='this.removeAttribute("onload"),this.rel="stylesheet"'><noscript><link rel=stylesheet href=/lib/fontawesome-free/all.min.bde2a1ac06ec87a30967e54da50f5c15.css integrity="md5-veKhrAbsh6MJZ+VNpQ9cFQ=="></noscript><link rel=preload href=/lib/animate/animate.min.c0be8e53226ac34833fd9b5dbc01ebc5.css integrity="md5-wL6OUyJqw0gz/ZtdvAHrxQ==" as=style onload='this.removeAttribute("onload"),this.rel="stylesheet"'><noscript><link rel=stylesheet href=/lib/animate/animate.min.c0be8e53226ac34833fd9b5dbc01ebc5.css integrity="md5-wL6OUyJqw0gz/ZtdvAHrxQ=="></noscript><meta name=google-site-verification content="MQ8DNu27ayX6B_4ObiEDK09vGr1fdy7kOAnbd09hJk4"><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","headline":"Chapter3","inLanguage":"zh-CN","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/moonwonder.top\/books\/javascript\/part1\/chapter3\/"},"image":["https:\/\/moonwonder.top\/images\/Apple-Devices-Preview.png"],"genre":"books","wordcount":2607,"url":"https:\/\/moonwonder.top\/books\/javascript\/part1\/chapter3\/","datePublished":"2025-10-26T21:32:27+08:00","dateModified":"2025-10-28T09:28:15+08:00","license":"This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.","publisher":{"@type":"Organization","name":"xxxx","logo":"https:\/\/moonwonder.top\/images\/avatar.png"},"author":{"@type":"Person","name":"MoonWonder"},"description":""}</script><script src=/js/head/color-scheme.min.9577b206ee497277eba5813880d7978c.js integrity="md5-lXeyBu5JcnfrpYE4gNeXjA=="></script></head><body data-header-desktop=sticky data-header-mobile=auto><div class=wrapper data-page-style=normal><header class="desktop animate__faster" id=header-desktop><div class=header-wrapper><div class=header-title><a href=/ title=MoonWonder><span class=header-title-pre><svg class="icon" viewBox="0 0 576 512"><path d="M402.3 344.9l32-32c5-5 13.7-1.5 13.7 5.7V464c0 26.5-21.5 48-48 48H48c-26.5.0-48-21.5-48-48V112c0-26.5 21.5-48 48-48h273.5c7.1.0 10.7 8.6 5.7 13.7l-32 32c-1.5 1.5-3.5 2.3-5.7 2.3H48v352h352V350.5c0-2.1.8-4.1 2.3-5.6zm156.6-201.8L296.3 405.7l-90.4 10c-26.2 2.9-48.5-19.2-45.6-45.6l10-90.4L432.9 17.1c22.9-22.9 59.9-22.9 82.7.0l43.2 43.2c22.9 22.9 22.9 60 .1 82.8zM460.1 174 402 115.9 216.2 301.8l-7.3 65.3 65.3-7.3L460.1 174zm64.8-79.7-43.2-43.2c-4.1-4.1-10.8-4.1-14.8.0L436 82l58.1 58.1 30.9-30.9c4-4.2 4-10.8-.1-14.9z"/></svg></span><span class=typeit><template>MoonWonder</template></span></a><span class=header-subtitle></span></div><nav><ul class=menu><li class=menu-item><a class=menu-link href=/posts/>所有文章</a></li><li class=menu-item><a class=menu-link href=/tags/>标签</a></li><li class=menu-item><a class=menu-link href=/categories/>分类</a></li><li class=menu-item><a class=menu-link href=/books/>系列</a></li><li class=menu-item><a class=menu-link href=/about/>关于</a></li><li class=menu-item><a class=menu-link href=/heatmap/>热力图</a></li><li class=menu-item><a class=menu-link href=/link/>友链</a></li><li class=menu-item><a class=menu-link href=https://github.com/MoonWonder/moonwonder.github.io title=GitHub rel="noopener noreferrer" target=_blank><svg class="icon" viewBox="0 0 496 512"><path d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6.0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6.0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3zm44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3.0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1.0-6.2-.3-40.4-.3-61.4.0.0-70 15-84.7-29.8.0.0-11.4-29.1-27.8-36.6.0.0-22.9-15.7 1.6-15.4.0.0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5.0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9.0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4.0 33.7-.3 75.4-.3 83.6.0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6.0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9.0-6.2-1.4-2.3-4-3.3-5.6-2z"/></svg></a></li><li class="menu-item delimiter"></li><li class="menu-item search" id=search-desktop><input type=text placeholder=搜索文章标题或内容…… id=search-input-desktop>
<a href=javascript:void(0); class="search-button search-toggle" id=search-toggle-desktop title=搜索><i class="fa-solid fa-search fa-fw" aria-hidden=true></i>
</a><a href=javascript:void(0); class="search-button search-clear" id=search-clear-desktop title=清空><i class="fa-solid fa-times-circle fa-fw" aria-hidden=true></i>
</a><span class="search-button search-loading" id=search-loading-desktop><i class="fa-solid fa-spinner fa-fw fa-spin" aria-hidden=true></i></span></li><li class="menu-item theme-switch" title=切换主题><i class="fa-solid fa-adjust fa-fw" aria-hidden=true></i></li><li class="menu-item language-switch"><span role=button aria-label=选择语言 title=选择语言><i class="fa-solid fa-language fa-fw" aria-hidden=true></i></span><ul class=sub-menu><li class=menu-item>没有更多翻译</li></ul></li></ul></nav></div></header><header class="mobile animate__faster" id=header-mobile><div class=header-container><div class=header-wrapper><div class=header-title><a href=/ title=MoonWonder><span class=header-title-pre><svg class="icon" viewBox="0 0 576 512"><path d="M402.3 344.9l32-32c5-5 13.7-1.5 13.7 5.7V464c0 26.5-21.5 48-48 48H48c-26.5.0-48-21.5-48-48V112c0-26.5 21.5-48 48-48h273.5c7.1.0 10.7 8.6 5.7 13.7l-32 32c-1.5 1.5-3.5 2.3-5.7 2.3H48v352h352V350.5c0-2.1.8-4.1 2.3-5.6zm156.6-201.8L296.3 405.7l-90.4 10c-26.2 2.9-48.5-19.2-45.6-45.6l10-90.4L432.9 17.1c22.9-22.9 59.9-22.9 82.7.0l43.2 43.2c22.9 22.9 22.9 60 .1 82.8zM460.1 174 402 115.9 216.2 301.8l-7.3 65.3 65.3-7.3L460.1 174zm64.8-79.7-43.2-43.2c-4.1-4.1-10.8-4.1-14.8.0L436 82l58.1 58.1 30.9-30.9c4-4.2 4-10.8-.1-14.9z"/></svg></span><span class=typeit><template>MoonWonder</template></span></a><span class=header-subtitle></span></div><div class=menu-toggle id=menu-toggle-mobile><span></span><span></span><span></span></div></div><nav><ul class=menu id=menu-mobile><li class=search-wrapper><div class="search mobile" id=search-mobile><input type=text placeholder=搜索文章标题或内容…… id=search-input-mobile>
<a href=javascript:void(0); class="search-button search-toggle" id=search-toggle-mobile title=搜索><i class="fa-solid fa-search fa-fw" aria-hidden=true></i>
</a><a href=javascript:void(0); class="search-button search-clear" id=search-clear-mobile title=清空><i class="fa-solid fa-times-circle fa-fw" aria-hidden=true></i>
</a><span class="search-button search-loading" id=search-loading-mobile><i class="fa-solid fa-spinner fa-fw fa-spin" aria-hidden=true></i></span></div><a href=javascript:void(0); class=search-cancel id=search-cancel-mobile>取消</a></li><li class=menu-item><a class=menu-link href=/posts/>所有文章</a></li><li class=menu-item><a class=menu-link href=/tags/>标签</a></li><li class=menu-item><a class=menu-link href=/categories/>分类</a></li><li class=menu-item><a class=menu-link href=/books/>系列</a></li><li class=menu-item><a class=menu-link href=/about/>关于</a></li><li class=menu-item><a class=menu-link href=/heatmap/>热力图</a></li><li class=menu-item><a class=menu-link href=/link/>友链</a></li><li class=menu-item><a class=menu-link href=https://github.com/MoonWonder/moonwonder.github.io title=GitHub rel="noopener noreferrer" target=_blank><svg class="icon" viewBox="0 0 496 512"><path d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6.0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6.0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3zm44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3.0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1.0-6.2-.3-40.4-.3-61.4.0.0-70 15-84.7-29.8.0.0-11.4-29.1-27.8-36.6.0.0-22.9-15.7 1.6-15.4.0.0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5.0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9.0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4.0 33.7-.3 75.4-.3 83.6.0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6.0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9.0-6.2-1.4-2.3-4-3.3-5.6-2z"/></svg></a></li><li class="menu-item menu-system"><span class="menu-system-item theme-switch" title=切换主题><i class="fa-solid fa-adjust fa-fw" aria-hidden=true></i></span><span class="menu-system-item language-switch">
<span role=button aria-label=选择语言 title=选择语言>简体中文<i class="dropdown-icon fa-solid fa-chevron-down" aria-hidden=true></i></span>
<select class=language-select onchange="location=this.value"><option disabled>没有更多翻译</option></select></span></li></ul></nav></div></header><div class="search-dropdown desktop"><div id=search-dropdown-desktop></div></div><div class="search-dropdown mobile"><div id=search-dropdown-mobile></div></div><main class=fi-container><article class="page single special"><div class=header><h1 class="single-title animate__animated animate__pulse animate__faster">Chapter3</h1></div><div class=content id=content><h3 class=heading-element id=第-3-章-深入-javascript搞定闭包原型与-this><span>第 3 章 深入 JavaScript：搞定闭包、原型与 <code>this</code></span>
<a href=#%e7%ac%ac-3-%e7%ab%a0-%e6%b7%b1%e5%85%a5-javascript%e6%90%9e%e5%ae%9a%e9%97%ad%e5%8c%85%e5%8e%9f%e5%9e%8b%e4%b8%8e-this class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h3><p>本章我们聚焦 JavaScript 的核心概念和一些 “奇妙” 特性，包括闭包、<code>this</code> 和原型继承。这些概念经常令初学者困惑，但对于有工程经验的你来说，只需一点类比就能豁然开朗。</p><p><strong>闭包（Closure）：函数里的 “小精灵”</strong><br>如果你听过 “闭包” 这个词，可能会觉得高深莫测。其实闭包的原理可以打个比方：想象在函数内部藏了一个<strong>记性很好的小精灵</strong>，它能记住函数被定义时周围的环境（变量），即使函数执行完，这些变量也不会丢失。当日后再次调用这个内部函数时，这些被记住的变量仍然保持着当初的值，这种现象就叫闭包。</p><p>用正式一点的话说，<strong>闭包是函数与其周围状态（词法环境）的组合</strong> 。也就是说，闭包让一个函数可以访问并保留其词法作用域中的变量。当我们在 JavaScript 中定义函数时，每次都会创建闭包——函数本身和对外部变量的引用绑定在一起</p><p>来看个例子体会闭包的威力：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=kd>function</span> <span class=nx>createCounter</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kd>let</span> <span class=nx>count</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=kd>function</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>count</span><span class=o>++</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=s2>&#34;计数器：&#34;</span> <span class=o>+</span> <span class=nx>count</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=p>};</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=kr>const</span> <span class=nx>counter</span> <span class=o>=</span> <span class=nx>createCounter</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=nx>counter</span><span class=p>();</span> <span class=c1>// 输出: 计数器：1
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>counter</span><span class=p>();</span> <span class=c1>// 输出: 计数器：2
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>counter</span><span class=p>();</span> <span class=c1>// 输出: 计数器：3
</span></span></span></code></pre></td></tr></table></div></div><p>这里 <code>createCounter</code> 返回了一个内部函数。注意，<code>createCounter</code> 在第一次调用后，其内部局部变量 <code>count</code> 按理说应该随函数执行完毕而销毁。然而，由于内部函数引用了 <code>count</code>，闭包使得 <code>count</code> 的值被一直保留下来。每次调用 <code>counter()</code>，它都能访问和修改 <code>createCounter</code> 作用域中的 <code>count</code> 变量。闭包实现了一种<strong>数据私有化</strong>：<code>count</code> 对外不可见，却始终驻留在内部函数的作用域里。好一个忠诚勤劳的 “小精灵”！</p><p>闭包在 JavaScript 中非常常见。比如我们常用的事件监听器、定时器回调，都经常利用闭包保存一些状态。理解闭包有助于我们编写模块化的代码，例如实现私有变量、封装业务逻辑等。在调试时也要注意闭包可能导致的内存占用，因为被闭包引用的外部变量不会被垃圾回收，需要手动注意避免不必要的闭包引用。</p><p><strong><code>this</code> 的多变与箭头函数：</strong><br>JavaScript 的 <code>this</code> 关键字可谓 “千面娇娃”，在不同场景下扮演不同角色，让不少人直呼看不懂。这里我们总结 <code>this</code> 常见的指向规则：</p><ul><li><p><strong>作为对象方法调用：</strong> <code>obj.method()</code> 调用时，<code>method</code> 内部的 <code>this</code> 指向该对象 <code>obj</code>。例如：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=kr>const</span> <span class=nx>pet</span> <span class=o>=</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nx>name</span><span class=o>:</span> <span class=s2>&#34;旺财&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>  <span class=nx>speak</span><span class=o>:</span> <span class=kd>function</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=k>this</span><span class=p>.</span><span class=nx>name</span> <span class=o>+</span> <span class=s2>&#34;在叫：汪汪！&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl><span class=nx>pet</span><span class=p>.</span><span class=nx>speak</span><span class=p>();</span> <span class=c1>// 输出: 旺财在叫：汪汪！
</span></span></span></code></pre></td></tr></table></div></div><p>上例中，<code>speak</code> 方法内的 <code>this</code> 即指向调用它的对象 <code>pet</code>。</p></li><li><p><strong>普通函数调用：</strong> <code>func()</code> 直接调用一个函数（非作为对象属性），在非严格模式下函数内 <code>this</code> 默认指向全局对象（浏览器中是 <code>window</code>，Node 中是 <code>global</code>）；在严格模式下则为 <code>undefined</code>。比如：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=kd>function</span> <span class=nx>foo</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=k>this</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=nx>foo</span><span class=p>();</span> <span class=c1>// 非严格模式下输出 Window（全局对象）
</span></span></span></code></pre></td></tr></table></div></div><p>这一点和 C++/Java 的习惯很不同——它们没有类似的全局 <code>this</code> 概念。JavaScript 设计如此，主要历史原因是早期方便直接调用函数访问全局。</p></li><li><p><strong>构造函数调用：</strong> 使用 <code>new Func()</code> 时，<code>Func</code> 内部的 <code>this</code> 被绑定到新创建的对象。例如：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=kd>function</span> <span class=nx>Person</span><span class=p>(</span><span class=nx>name</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>this</span><span class=p>.</span><span class=nx>name</span> <span class=o>=</span> <span class=nx>name</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=kr>const</span> <span class=nx>p</span> <span class=o>=</span> <span class=k>new</span> <span class=nx>Person</span><span class=p>(</span><span class=s2>&#34;Tom&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=c1>// 构造过程中 this 指向 p，赋值后 p.name === &#34;Tom&#34;
</span></span></span></code></pre></td></tr></table></div></div></li><li><p><strong><code>call/apply</code>/<code>bind</code> 强制绑定：</strong> JavaScript 提供了 <code>func.call(thisArg, ...)</code> 和 <code>func.apply(thisArg, [...])</code> 来指定调用时的 <code>this</code>。还有 <code>func.bind(thisArg)</code> 可生成一个永久绑定 <code>this</code> 的新函数。比如：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=kd>function</span> <span class=nx>greet</span><span class=p>()</span> <span class=p>{</span> <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=s2>&#34;Hi, &#34;</span> <span class=o>+</span> <span class=k>this</span><span class=p>.</span><span class=nx>name</span><span class=p>);</span> <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=kr>const</span> <span class=nx>alice</span> <span class=o>=</span> <span class=p>{</span> <span class=nx>name</span><span class=o>:</span> <span class=s2>&#34;Alice&#34;</span> <span class=p>};</span>
</span></span><span class=line><span class=cl><span class=nx>greet</span><span class=p>.</span><span class=nx>call</span><span class=p>(</span><span class=nx>alice</span><span class=p>);</span> <span class=c1>// 输出: Hi, Alice
</span></span></span></code></pre></td></tr></table></div></div><p>通过 <code>call</code> 我们把 <code>greet</code> 函数的 <code>this</code> 硬生生成了 <code>alice</code> 对象。</p></li></ul><p>怎么样，是不是眼花缭乱 🤯？别急，ES6 的箭头函数在某种程度上帮我们简化了 <code>this</code> 问题。<strong>箭头函数没有自己的 <code>this</code></strong>，它会捕获外层（定义时）环境的 <code>this</code> 值。这意味着在箭头函数内部访问 <code>this</code>，就是在访问外部上下文的 <code>this</code>。因此，箭头函数非常适合用作回调，以避免 <code>this</code> 被改变。例如：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=kr>const</span> <span class=nx>team</span> <span class=o>=</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nx>name</span><span class=o>:</span> <span class=s2>&#34;勇士队&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>  <span class=nx>players</span><span class=o>:</span> <span class=p>[</span><span class=s2>&#34;Stephen&#34;</span><span class=p>,</span> <span class=s2>&#34;Klay&#34;</span><span class=p>],</span>
</span></span><span class=line><span class=cl>  <span class=nx>showList</span><span class=o>:</span> <span class=kd>function</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>this</span><span class=p>.</span><span class=nx>players</span><span class=p>.</span><span class=nx>forEach</span><span class=p>(</span><span class=nx>player</span> <span class=p>=&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=k>this</span><span class=p>.</span><span class=nx>name</span> <span class=o>+</span> <span class=s2>&#34; 球员：&#34;</span> <span class=o>+</span> <span class=nx>player</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>});</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl><span class=nx>team</span><span class=p>.</span><span class=nx>showList</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=c1>// 输出:
</span></span></span><span class=line><span class=cl><span class=c1>// 勇士队 球员：Stephen
</span></span></span><span class=line><span class=cl><span class=c1>// 勇士队 球员：Klay
</span></span></span></code></pre></td></tr></table></div></div><p>如果不用箭头函数，而用普通匿名函数，<code>forEach</code> 内部函数的 <code>this</code> 将指向全局，无法访问到 <code>team.name</code>。箭头函数完美地保持了外部 <code>this</code>（即 <code>team</code> 对象）。正因如此，许多框架（如 React）中大量使用箭头函数来避免手动绑定 <code>this</code>。</p><p>你可以把 <code>this</code> 看作 JavaScript 里一个爱变装的角色，根据剧情需要（调用方式）换不同衣服。而箭头函数就像给 <code>this</code> 套上了保护壳，使它不受外界干扰。</p><p><strong>原型与继承：</strong><br>在 JavaScript 中，一切几乎都是对象，对象之间通过<strong>原型链</strong>建立继承关系。不同于 Java/C++ 基于类（class）的继承模型，JavaScript 采用<strong>原型继承</strong>模型：每个对象都有一个 “隐藏属性” 指向它的原型对象（可以理解为模版对象），对象在查找属性时，如果自身没有会沿着原型链向上查找。</p><p>ES6 虽然引入了 <code>class</code> 关键字，但实际上只是语法糖，本质还是基于原型机制。例如：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=kr>class</span> <span class=nx>Animal</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nx>speak</span><span class=p>()</span> <span class=p>{</span> <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=s2>&#34;Animal speaks&#34;</span><span class=p>);</span> <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=kr>class</span> <span class=nx>Dog</span> <span class=kr>extends</span> <span class=nx>Animal</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nx>speak</span><span class=p>()</span> <span class=p>{</span> <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=s2>&#34;Woof!&#34;</span><span class=p>);</span> <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=kd>let</span> <span class=nx>d</span> <span class=o>=</span> <span class=k>new</span> <span class=nx>Dog</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=nx>d</span><span class=p>.</span><span class=nx>speak</span><span class=p>();</span> <span class=c1>// 输出: Woof!
</span></span></span></code></pre></td></tr></table></div></div><p>在底层，<code>Dog</code> 的原型继承了 <code>Animal</code> 的原型，实例 <code>d</code> 调用 <code>speak</code> 时，找到的是 <code>Dog.prototype.speak</code>；如果没有，则会沿原型链查找 <code>Animal.prototype.speak</code>。JavaScript 这套继承机制实现简单灵活，因此 <strong>JavaScript 是典型的原型继承的面向对象语言</strong>，不像 Java、C++ 等严格按类构造对象。</p><p>值得注意的是，你可以动态地给原型添加方法，影响所有继承该原型的对象。例如：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=kd>function</span> <span class=nx>Person</span><span class=p>(</span><span class=nx>name</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>this</span><span class=p>.</span><span class=nx>name</span> <span class=o>=</span> <span class=nx>name</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=nx>Person</span><span class=p>.</span><span class=nx>prototype</span><span class=p>.</span><span class=nx>sayHi</span> <span class=o>=</span> <span class=kd>function</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=s2>&#34;Hi, I&#39;m &#34;</span> <span class=o>+</span> <span class=k>this</span><span class=p>.</span><span class=nx>name</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl><span class=kd>let</span> <span class=nx>p1</span> <span class=o>=</span> <span class=k>new</span> <span class=nx>Person</span><span class=p>(</span><span class=s2>&#34;Alice&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=nx>p1</span><span class=p>.</span><span class=nx>sayHi</span><span class=p>();</span> <span class=c1>// 输出: Hi, I&#39;m Alice
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>let</span> <span class=nx>p2</span> <span class=o>=</span> <span class=k>new</span> <span class=nx>Person</span><span class=p>(</span><span class=s2>&#34;Bob&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=nx>p2</span><span class=p>.</span><span class=nx>sayHi</span><span class=p>();</span> <span class=c1>// 输出: Hi, I&#39;m Bob
</span></span></span></code></pre></td></tr></table></div></div><p>我们定义了构造函数 <code>Person</code> 及其原型方法 <code>sayHi</code>。两个实例 <code>p1</code>、<code>p2</code> 分别调用时，<code>this</code> 指向各自实例，输出各自的名字。可以看到，它们<strong>共享</strong>了原型上的同一个 <code>sayHi</code> 函数定义。这种机制节省内存并且灵活：可以在程序运行时修改 <code>Person.prototype.sayHi</code>，所有实例的方法行为将随之改变（在大型项目中这并不推荐，只作了解）。</p><p>概括来说，<strong>原型继承</strong>允许我们用对象去模版另一个对象，直接继承其属性和方法，不需要像类那样先定义抽象蓝图再实例化。这赋予了 JavaScript 极大的动态性。但对于习惯了 class 的开发者，刚接触可能会有些不适应。好消息是，ES6 <code>class</code> 让语法看起来更像传统类，方便面向对象思维的人使用。不过记住，其本质仍是原型链。</p><p><strong>小结：</strong> 本章揭开了 JavaScript 一些核心概念的神秘面纱。<strong>闭包</strong>就像函数里驻守的 “小精灵”，使函数记住定义时的环境 ；<strong><code>this</code></strong> 则如同变装演员，根据调用场景变化多端，而箭头函数给它套上 “紧身衣”，固定了其指向；<strong>原型继承</strong>则是 JavaScript 面向对象的基石，与传统类继承各有千秋，却更为灵活。理解这些概念后，你将更游刃有余地编写复杂的 JavaScript 程序，并避免掉入常见陷阱。</p></div><div id=comments><div id=valine class=comment></div><noscript>Please enable JavaScript to view the comments powered by <a href=https://valine.js.org/ rel="external nofollow noopener noreferrer">Valine</a>.</noscript></div></article></main><footer class=footer><div class=footer-container><div class="footer-line powered">由 <a href=https://gohugo.io/ target=_blank rel="external nofollow noopener noreferrer" title="Hugo 0.147.9"><img class=hugo-icon src=/images/hugo.min.svg alt="Hugo logo"> Hugo</a> 强力驱动 | 主题 - <a href=https://github.com/hugo-fixit/FixIt target=_blank rel=external title="FixIt v0.4.0-alpha.2-20251023040336-063af2cd"><img class=fixit-icon src=/images/fixit.min.svg alt="FixIt logo"> FixIt</a></div><div class="footer-line copyright" itemscope itemtype=http://schema.org/CreativeWork><i class="fa-regular fa-copyright fa-fw" aria-hidden=true></i>
<span itemprop=copyrightYear>2021 - 2025</span><span class=author itemprop=copyrightHolder>
<a href=https://github.com/moonwonder target=_blank rel="external nofollow noopener noreferrer">MoonWonder</a></span><span class="license footer-divider"><a rel="license external nofollow noopener noreferrer" href=https://creativecommons.org/licenses/by-nc/4.0/ target=_blank>CC BY-NC 4.0</a></span></div></div></footer></div><div class=widgets><div class="fixed-buttons animate__faster d-none"><div class="fixed-button back-to-top" role=button aria-label=回到顶部><i class="fa-solid fa-arrow-up fa-fw" aria-hidden=true></i><span class=variant-numeric>0%</span></div><div class="fixed-button view-comments d-none" role=button aria-label=查看评论><i class="fa-solid fa-comment fa-fw" aria-hidden=true></i></div></div><div id=mask></div><div class=reading-progress-bar style=left:0;top:0></div><noscript><div class=noscript-warning>该网站在启用 JavaScript 的情况下效果最佳。</div></noscript></div><link rel=stylesheet href=/lib/valine/valine.min.css><script src=/lib/valine/Valine.min.91ad455f2b872ce889395474e4609481.js integrity="md5-ka1FXyuHLOiJOVR05GCUgQ=="></script><script src=/lib/autocomplete/autocomplete.min.553edd1b8dd335ab4626f05e6131812a.js integrity="md5-VT7dG43TNatGJvBeYTGBKg==" defer></script><script src=/lib/algoliasearch/algoliasearch-lite.umd.min.339e44173f7561e5ba328301e972bc2f.js integrity="md5-M55EFz91YeW6MoMB6XK8Lw==" defer></script><script src=/lib/instant-page/instantpage.min.d4be8390e577e842090e98303563633e.js integrity="md5-1L6DkOV36EIJDpgwNWNjPg==" async defer type=module></script><script src=/lib/sharer/sharer.min.9c17fd8602aab18b8337139614a30fda.js integrity="md5-nBf9hgKqsYuDNxOWFKMP2g==" async defer></script><script src=/lib/typeit/index.umd.10b1c79fdaa004fa101077c3fc636a5a.js integrity="md5-ELHHn9qgBPoQEHfD/GNqWg==" defer></script><script src=/books/javascript/part1/chapter3/config/page.js defer></script><script src=/js/theme.min.e245c9c9d0171e1e3ecf45805f56a0f8.js integrity="md5-4kXJydAXHh4+z0WAX1ag+A==" defer></script></body></html>